Index: Source/FIM/Public/FIMCharacter.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright Epic Games, Inc. All Rights Reserved.\r\n\r\n#pragma once\r\n\r\n#include \"CoreMinimal.h\"\r\n#include \"GameFramework/Character.h\"\r\n#include \"AbilitySystemComponent.h\"\r\n#include \"AbilitySystemInterface.h\"\r\n#include \"Abilities/GameplayAbility.h\"\r\n#include <GameplayEffectTypes.h>\r\n#include \"Components/TimelineComponent.h\"\r\n#include \"FIMCharacter.generated.h\"\r\n\r\n\r\nclass USAttributeSet;\r\nclass USActionComponent;\r\nclass UCurveFloat;\r\n\r\nDECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FReverseTimeDelegate, bool, bReverseTime);\r\n\r\nUCLASS(config = Game)\r\nclass AFIMCharacter : public ACharacter\r\n{\r\n\tGENERATED_BODY()\r\n\r\n\t\t/** Camera boom positioning the camera behind the character */\r\n\t\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\"))\r\n\t\tclass USpringArmComponent* CameraBoom;\r\n\r\n\t/** Follow camera */\r\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = \"true\"))\r\n\t\tclass UCameraComponent* CameraComp;\r\npublic:\r\n\tAFIMCharacter();\r\n\r\n\t/** Base turn rate, in deg/sec. Other scaling may affect final turn rate. */\r\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Input)\r\n\t\tfloat TurnRateGamepad;\r\n\r\n\t/** Base turn rate, in deg/sec. Other scaling may affect final turn rate. */\r\n\tUPROPERTY(BlueprintReadOnly, Category = Camera)\r\n\t\tfloat BaseTurnRate;\r\n\r\n\t/** Base look up/down rate, in deg/sec. Other scaling may affect final rate. */\r\n\tUPROPERTY(BlueprintReadOnly, Category = Camera)\r\n\t\tfloat BaseLookUpRate;\r\n\r\n\t/** Returns CameraBoom subobject **/\r\n\tFORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }\r\n\t/** Returns CameraComp subobject **/\r\n\tFORCEINLINE class UCameraComponent* GetFollowCamera() const { return CameraComp; }\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"CharacterInput\")\r\n\t\tbool IsMoving;\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"CharacterInput\")\r\n\t\tfloat InputX;\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"CharacterInput\")\r\n\t\tfloat InputZ;\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"ServerMode\")\r\n\t\tbool IsCombatMode;\r\n\r\n\tUPROPERTY(BlueprintReadOnly, Category = \"CharacterInput\")\r\n\t\tbool IsSprinting;\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"Dash\")\r\n\t\tbool bIsDashing;\r\n\r\n\tUPROPERTY(BlueprintReadOnly, Category = \"Dead\")\r\n\t\tbool bIsDead;\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"Blocking\")\r\n\t\tbool bIsBlock;\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"Hit\")\r\n\t\tbool bIsHitted;\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"ReverseTime\")\r\n\t\tbool IsReverseTime;\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"Falling\")\r\n\t\tbool IsFalling;\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"Attack\")\r\n\t\tbool IsAttacking;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"MontagerRate\")\r\n\t\tfloat PlayMontageRate;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Camera\")\r\n\t\tfloat RotationSpeed;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Melee\")\r\n\t\tbool IsInvincible;\r\n\r\nprotected:\r\n\r\n\t/** Called for forwards/backward input */\r\n\tvoid MoveForward(float Value);\r\n\r\n\t/** Called for side to side input */\r\n\tvoid MoveRight(float Value);\r\n\r\n\t/**\r\n\t * Called via input to turn at a given rate.\r\n\t * @param Rate\tThis is a normalized rate, i.e. 1.0 means 100% of desired turn rate\r\n\t */\r\n\tvoid TurnAtRate(float Rate);\r\n\r\n\t/**\r\n\t * Called via input to turn look up/down at a given rate.\r\n\t * @param Rate\tThis is a normalized rate, i.e. 1.0 means 100% of desired turn rate\r\n\t */\r\n\tvoid LookUpAtRate(float Rate);\r\n\r\n\t/** Handler for when a touch input begins. */\r\n\tvoid TouchStarted(ETouchIndex::Type FingerIndex, FVector Location);\r\n\r\n\t/** Handler for when a touch input stops. */\r\n\tvoid TouchStopped(ETouchIndex::Type FingerIndex, FVector Location);\r\n\r\n\t// APawn interface\r\n\tvirtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;\r\n\t// End of APawn interface\r\n\r\npublic:\r\n\t/*Set up attack*/\r\n\r\n\tUFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = \"ServerMode\")\r\n\t\tvoid Server_CombatMode();\r\n\r\n\tUFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = \"ServerMode\")\r\n\t\tvoid Server_Equip(FName SkeletalName_L, FName SkeletalName_R);\r\n\r\n/*\r\n\tUFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = \"ServerMode\")\r\n\t\tvoid Server_Equip();*/\r\n\r\n\tUFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = \"ServerMode\")\r\n\t\tvoid Server_Attack();\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"NormalAttack\")\r\n\t\tvoid NormalAttack(UAnimMontage* NormalAttack_1, UAnimMontage* NormalAttack_2, UAnimMontage* NormalAttack_3, UAnimMontage* NormalAttack_4);\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"Normal_Attack\")\r\n\t\tconst UAnimMontage* AM_Attack;\r\n\r\n\tFTimerHandle TH_EndAttack;\r\n\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"Normal_Attack\")\t\r\n\t\tint32 Attack_Num;\r\n\r\n\tUPROPERTY(EditDefaultsOnly, Category = \"Normal_Attack\")\r\n\t\tfloat DelayAttackEnd;\r\n\r\n\tUFUNCTION()\r\n\t\tvoid EndNormalAttack();\r\n\r\n\tUFUNCTION(BlueprintNativeEvent, Category = \"ServerMode\")\r\n\t\tvoid CombatModeEvent(bool OnCombatStart);\r\n\r\n\tFVector LastInput;\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"ServerMode\")\r\n\t\tvoid ConculateLastInput();\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"ServerMode\")\r\n\t\tvoid InterToRotation(bool IsInter);\r\n\r\n\tbool IsInput;\r\n\r\n\tFRotator LastRotation;\r\n\r\n\t/*initialize character moving speed*/\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Speed\")\r\n\t\tfloat WalkingSpeed;\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Speed\")\r\n\t\tfloat BlockSpeed;\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"Character\")\r\n\t\tbool IsOtherHostile(AFIMCharacter* Other);\r\n\r\n\tuint8 GetTeamID() const;\r\n\r\n\tUFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = \"Dead\")\r\n\t\tvoid Dead();\r\n\r\n\tUSkeletalMeshComponent* CharacterMeshComp;\r\n\r\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Weapon\")\r\n\t\tUStaticMeshComponent* WeaponComp_R;\r\n\r\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Weapon\")\r\n\t\tUStaticMeshComponent* WeaponComp_L;\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"Dashing\")\r\n\t\tvoid Dashing();\r\n\r\n\t/*Set up Sprint*/\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Sprint\")\r\n\t\tfloat SprintSpeed;\r\n\tfloat StopMovementSpeed;\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"Sprint\")\r\n\t\tvoid SprintStart();\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"Sprint\")\r\n\t\tvoid SprintEnd();\r\n\r\nprotected:\r\n\r\n\tUPROPERTY(VisibleAnywhere, Category = \"Effects\")\r\n\t\tFName TimeToHitParamName;\r\n\r\n\tvirtual void Tick(float DeltaTime) override;\r\n\r\n\tvirtual void BeginPlay()override;\r\n\r\n\tUCapsuleComponent* CapsuleComp;\r\n\r\n\tUPROPERTY(BlueprintReadOnly, Category = \"CharacterMovement\")\r\n\t\tUCharacterMovementComponent* CMComp;\r\n\r\n\t/*Set up Dashing*/\r\n\tUFUNCTION(BlueprintCallable, Category = \"Dashing\")\r\n\t\tvoid DashingMovement(UCharacterMovementComponent* MovementComp);\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"Dashing\")\r\n\t\tvoid PlayDashingMontage();\r\n\r\n\tvoid DashingEnd();\r\n\tUPROPERTY(EditAnywhere, BlueprintReadWrite, Category = \"Dash\")\r\n\t\tfloat DashDistance;\r\n\r\n\tFVector CharacterLocation;\r\n\tFVector ActorDirection;\r\n\tFVector ForwardDir;\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"Combat\")\r\n\t\tvoid CombatStart(bool DoCombatMode, bool IsOrientRotationToMovement, bool IsUseControllerDesiredRotation);\r\n\tvoid DisableRotationInWalking();\r\n\r\n\tFVector DirectionX;\r\n\tFVector DirectionZ;\r\n\r\n\tUPROPERTY(BlueprintReadOnly, Category = \"CharacterInput\")\r\n\t\tfloat PlayerDirection;\r\n\r\n\tFTimerHandle EquipTimeDelay;\r\n\r\n\tFTimerHandle TH_Dashing;\r\n\r\n\tUPROPERTY(EditAnywhere, Category = \"Dash\")\r\n\t\tfloat DashDelayTime;\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"CharacterInput\")\r\n\t\tint32 InputValue();\r\n\r\n\t/*setup block event*/\r\n\tvoid BlockingStart();\r\n\r\n\tvoid BlockingEnd();\r\n\r\n\tUFUNCTION(BlueprintNativeEvent, Category = \"Melee\")\r\n\t\tvoid OnInvicinble();\r\n\r\n\t/*Team ID*/\r\n\tUPROPERTY(BlueprintReadOnly, Category = \"Hit\")\r\n\t\tuint8 TeamID;\r\n\tvoid AutoDeterminTeamIDbyControllerType();\r\n\r\nprotected:\r\n\r\n\tUPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = \"Components\")\r\n\t\tUSActionComponent* ActionComp;\r\n\r\n\tclass UInputComponent* PlayerInputComp;\r\n\r\n\t/*setup dash animation montage*/\r\n\tUPROPERTY(BlueprintReadWrite, Category = \"AnimMontage\")\r\n\t\tUAnimMontage* Montage_GetAttack;\r\n\r\n\tUPROPERTY(EditAnywhere, Category = \"AnimMontage\")\r\n\t\tUAnimMontage* Montage_FDodge;\r\n\r\n\tUPROPERTY(EditAnywhere, Category = \"AnimMontage\")\r\n\t\tUAnimMontage* Montage_RDodge;\r\n\r\n\tUPROPERTY(EditAnywhere, Category = \"AnimMontage\")\r\n\t\tUAnimMontage* Montage_LDodge;\r\n\r\n\tUPROPERTY(EditAnywhere, Category = \"AnimMontage\")\r\n\t\tUAnimMontage* Montage_BDodge;\r\n\r\n\tUPROPERTY(EditAnywhere, Category = \"AnimMontage\")\r\n\t\tUAnimMontage* Montage_Equip;\r\n\r\n\tUPROPERTY(EditAnywhere, Category = \"AnimMontage\")\r\n\t\tUAnimMontage* Montage_Unequip;\r\n\r\npublic:\r\n\r\n\t/*Ability System setup*/\r\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \"GAS\")\r\n\t\tclass USAbilitySystemComponent* AbilitySystemComp;\r\n\r\n\tUPROPERTY(EditAnywhere, Category = \"GAS\")\r\n\t\tTArray<TSubclassOf<UGameplayAbility>> GA_Ability;\r\n\r\n\tvirtual UAbilitySystemComponent* GetAbilitySystemComponent() const;\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"GAS\")\r\n\t\tvirtual void InitializeAttributes(TSubclassOf<UGameplayAbility> AbilityToGet, int32 AbilityLevel);\r\n\r\n\tint32 AbilityLevelSetup;\r\n\r\n\t/*Attribute setup*/\r\n\tUPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = \"GAS\")\r\n\t\tconst class USAttributeSet* AttributeSettings;\r\n\r\n\tUFUNCTION(BlueprintPure, Category = \"GAS\")\r\n\t\tvoid GetHealthValues(float& Health, float& MaxHealth);\r\n\tUFUNCTION(BlueprintPure, Category = \"GAS\")\r\n\t\tvoid GethManaValues(float& Mana, float& MaxMana);\r\n\tUFUNCTION(BlueprintPure, Category = \"GAS\")\r\n\t\tvoid GetStaminaValues(float& Stamina, float& MaxStamina);\r\n\tUFUNCTION(BlueprintPure, Category = \"GAS\")\r\n\t\tvoid GetAttackPowerValues(float& AttackPower, float& MaxAttackPower);\r\n\r\n\tvoid OnHealthChangedNative(const FOnAttributeChangeData& Data);\r\n\tvoid OnManaChangedNative(const FOnAttributeChangeData& Data);\r\n\tvoid OnStaminaChangedNative(const FOnAttributeChangeData& Data);\r\n\tvoid OnAttackPowerChangedNative(const FOnAttributeChangeData& Data);\r\n\r\n\tUFUNCTION(BlueprintImplementableEvent, Category = \"GAS\")\r\n\t\tvoid OnHealthChanged(float OldValue, float NewValue);\r\n\tUFUNCTION(BlueprintImplementableEvent, Category = \"GAS\")\r\n\t\tvoid BP_Die();\r\n\tUFUNCTION(BlueprintImplementableEvent, Category = \"GAS\")\r\n\t\tvoid OnManaChanged(float OldValue, float NewValue);\r\n\tUFUNCTION(BlueprintImplementableEvent, Category = \"GAS\")\r\n\t\tvoid OnStaminaChanged(float OldValue, float NewValue);\r\n\tUFUNCTION(BlueprintImplementableEvent, Category = \"GAS\")\r\n\t\tvoid OnAttackPowerChanged(float OldValue, float NewValue);\r\n\r\n\t/*Setup Revering Time function*/\r\n\tUFUNCTION(BlueprintCallable, Category = \"ReverseTime\")\r\n\t\tvoid StartReversingTime();\r\n\r\n\tUFUNCTION(BlueprintCallable, Category = \"ReverseTime\")\r\n\t\tvoid EndReversingTime();\r\n\r\n\tFReverseTimeDelegate ReverseTimeDelegate;\r\n};\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FIM/Public/FIMCharacter.h b/Source/FIM/Public/FIMCharacter.h
--- a/Source/FIM/Public/FIMCharacter.h	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Source/FIM/Public/FIMCharacter.h	(date 1723483093573)
@@ -23,27 +23,28 @@
 {
 	GENERATED_BODY()
 
-		/** Camera boom positioning the camera behind the character */
-		UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
-		class USpringArmComponent* CameraBoom;
+	/** Camera boom positioning the camera behind the character */
+	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
+	class USpringArmComponent* CameraBoom;
 
 	/** Follow camera */
 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
-		class UCameraComponent* CameraComp;
+	class UCameraComponent* CameraComp;
+
 public:
 	AFIMCharacter();
 
 	/** Base turn rate, in deg/sec. Other scaling may affect final turn rate. */
 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Input)
-		float TurnRateGamepad;
+	float TurnRateGamepad;
 
 	/** Base turn rate, in deg/sec. Other scaling may affect final turn rate. */
 	UPROPERTY(BlueprintReadOnly, Category = Camera)
-		float BaseTurnRate;
+	float BaseTurnRate;
 
 	/** Base look up/down rate, in deg/sec. Other scaling may affect final rate. */
 	UPROPERTY(BlueprintReadOnly, Category = Camera)
-		float BaseLookUpRate;
+	float BaseLookUpRate;
 
 	/** Returns CameraBoom subobject **/
 	FORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }
@@ -51,52 +52,54 @@
 	FORCEINLINE class UCameraComponent* GetFollowCamera() const { return CameraComp; }
 
 	UPROPERTY(BlueprintReadWrite, Category = "CharacterInput")
-		bool IsMoving;
+	bool IsMoving;
 
 	UPROPERTY(BlueprintReadWrite, Category = "CharacterInput")
-		float InputX;
+	float InputX;
 
 	UPROPERTY(BlueprintReadWrite, Category = "CharacterInput")
-		float InputZ;
+	float InputZ;
 
 	UPROPERTY(BlueprintReadWrite, Category = "ServerMode")
-		bool IsCombatMode;
+	bool IsCombatMode;
 
 	UPROPERTY(BlueprintReadOnly, Category = "CharacterInput")
-		bool IsSprinting;
+	bool IsSprinting;
 
 	UPROPERTY(BlueprintReadWrite, Category = "Dash")
-		bool bIsDashing;
+	bool bIsDashing;
 
 	UPROPERTY(BlueprintReadOnly, Category = "Dead")
-		bool bIsDead;
+	bool bIsDead;
 
 	UPROPERTY(BlueprintReadWrite, Category = "Blocking")
-		bool bIsBlock;
+	bool bIsBlock;
 
 	UPROPERTY(BlueprintReadWrite, Category = "Hit")
-		bool bIsHitted;
+	bool bIsHitted;
 
 	UPROPERTY(BlueprintReadWrite, Category = "ReverseTime")
-		bool IsReverseTime;
+	bool IsReverseTime;
 
 	UPROPERTY(BlueprintReadWrite, Category = "Falling")
-		bool IsFalling;
+	bool IsFalling;
 
 	UPROPERTY(BlueprintReadWrite, Category = "Attack")
-		bool IsAttacking;
+	bool IsAttacking;
 
 	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "MontagerRate")
-		float PlayMontageRate;
+	float PlayMontageRate;
 
 	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Camera")
-		float RotationSpeed;
+	float RotationSpeed;
 
 	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Melee")
-		bool IsInvincible;
+	bool IsInvincible;
 
+	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Devour")
+	bool IsDevour;
+
 protected:
-
 	/** Called for forwards/backward input */
 	void MoveForward(float Value);
 
@@ -129,135 +132,136 @@
 	/*Set up attack*/
 
 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "ServerMode")
-		void Server_CombatMode();
+	void Server_CombatMode();
 
 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "ServerMode")
-		void Server_Equip(FName SkeletalName_L, FName SkeletalName_R);
+	void Server_Equip(FName SkeletalName_L, FName SkeletalName_R);
 
-/*
-	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "ServerMode")
-		void Server_Equip();*/
+	/*
+		UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "ServerMode")
+			void Server_Equip();*/
 
 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "ServerMode")
-		void Server_Attack();
+	void Server_Attack();
 
 	UFUNCTION(BlueprintCallable, Category = "NormalAttack")
-		void NormalAttack(UAnimMontage* NormalAttack_1, UAnimMontage* NormalAttack_2, UAnimMontage* NormalAttack_3, UAnimMontage* NormalAttack_4);
+	void NormalAttack(const TArray<UAnimMontage*>& NormalAttacks);
 
 	UPROPERTY(BlueprintReadWrite, Category = "Normal_Attack")
-		const UAnimMontage* AM_Attack;
+	const UAnimMontage* AM_Attack;
 
 	FTimerHandle TH_EndAttack;
 
-	UPROPERTY(BlueprintReadWrite, Category = "Normal_Attack")	
-		int32 Attack_Num;
+	UPROPERTY(BlueprintReadWrite, Category = "Normal_Attack")
+	int32 Attack_Num;
 
 	UPROPERTY(EditDefaultsOnly, Category = "Normal_Attack")
-		float DelayAttackEnd;
+	float DelayAttackEnd;
 
 	UFUNCTION()
-		void EndNormalAttack();
+	void EndNormalAttack();
 
 	UFUNCTION(BlueprintNativeEvent, Category = "ServerMode")
-		void CombatModeEvent(bool OnCombatStart);
+	void CombatModeEvent(bool OnCombatStart);
 
 	FVector LastInput;
 
 	UFUNCTION(BlueprintCallable, Category = "ServerMode")
-		void ConculateLastInput();
+	void ConculateLastInput();
 
 	UFUNCTION(BlueprintCallable, Category = "ServerMode")
-		void InterToRotation(bool IsInter);
+	void InterToRotation(bool IsInter);
 
 	bool IsInput;
 
 	FRotator LastRotation;
 
 	/*initialize character moving speed*/
+	bool forBackup;
+
 	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Speed")
-		float WalkingSpeed;
+	float WalkingSpeed;
 
 	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Speed")
-		float BlockSpeed;
+	float BlockSpeed;
 
 	UFUNCTION(BlueprintCallable, Category = "Character")
-		bool IsOtherHostile(AFIMCharacter* Other);
+	bool IsOtherHostile(AFIMCharacter* Other);
 
 	uint8 GetTeamID() const;
 
 	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Dead")
-		void Dead();
+	void Dead();
 
 	USkeletalMeshComponent* CharacterMeshComp;
 
 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Weapon")
-		UStaticMeshComponent* WeaponComp_R;
+	UStaticMeshComponent* WeaponComp_R;
 
 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Weapon")
-		UStaticMeshComponent* WeaponComp_L;
+	UStaticMeshComponent* WeaponComp_L;
 
 	UFUNCTION(BlueprintCallable, Category = "Dashing")
-		void Dashing();
+	void Dashing();
 
 	/*Set up Sprint*/
 	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Sprint")
-		float SprintSpeed;
+	float SprintSpeed;
 	float StopMovementSpeed;
 
 	UFUNCTION(BlueprintCallable, Category = "Sprint")
-		void SprintStart();
+	void SprintStart();
 
 	UFUNCTION(BlueprintCallable, Category = "Sprint")
-		void SprintEnd();
+	void SprintEnd();
 
 protected:
-
 	UPROPERTY(VisibleAnywhere, Category = "Effects")
-		FName TimeToHitParamName;
+	FName TimeToHitParamName;
 
 	virtual void Tick(float DeltaTime) override;
 
-	virtual void BeginPlay()override;
+	virtual void BeginPlay() override;
 
 	UCapsuleComponent* CapsuleComp;
 
 	UPROPERTY(BlueprintReadOnly, Category = "CharacterMovement")
-		UCharacterMovementComponent* CMComp;
+	UCharacterMovementComponent* CMComp;
 
 	/*Set up Dashing*/
 	UFUNCTION(BlueprintCallable, Category = "Dashing")
-		void DashingMovement(UCharacterMovementComponent* MovementComp);
+	void DashingMovement(UCharacterMovementComponent* MovementComp);
 
 	UFUNCTION(BlueprintCallable, Category = "Dashing")
-		void PlayDashingMontage();
+	void PlayDashingMontage();
 
 	void DashingEnd();
 	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Dash")
-		float DashDistance;
+	float DashDistance;
 
 	FVector CharacterLocation;
 	FVector ActorDirection;
 	FVector ForwardDir;
 
 	UFUNCTION(BlueprintCallable, Category = "Combat")
-		void CombatStart(bool DoCombatMode, bool IsOrientRotationToMovement, bool IsUseControllerDesiredRotation);
+	void CombatStart(bool DoCombatMode, bool IsOrientRotationToMovement, bool IsUseControllerDesiredRotation);
 	void DisableRotationInWalking();
 
 	FVector DirectionX;
 	FVector DirectionZ;
 
 	UPROPERTY(BlueprintReadOnly, Category = "CharacterInput")
-		float PlayerDirection;
+	float PlayerDirection;
 
 	FTimerHandle EquipTimeDelay;
 
 	FTimerHandle TH_Dashing;
 
 	UPROPERTY(EditAnywhere, Category = "Dash")
-		float DashDelayTime;
+	float DashDelayTime;
 
 	UFUNCTION(BlueprintCallable, Category = "CharacterInput")
-		int32 InputValue();
+	int32 InputValue();
 
 	/*setup block event*/
 	void BlockingStart();
@@ -265,94 +269,155 @@
 	void BlockingEnd();
 
 	UFUNCTION(BlueprintNativeEvent, Category = "Melee")
-		void OnInvicinble();
+	void OnInvicinble();
 
+	/*Devour System*/
+	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "DevourSystem")
+	void DevourEvent();
+
+	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "DevourSystem")
+	void Devour();
+
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "DevourSystem")
+	float CurrentMaximonn_BASIC_HP;
+
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "DevourSystem")
+	int DevourTest;
+
+	/*Possessed*/
+	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "DevourSystem")
+	void PossessedEvent();
+
+	UPROPERTY(BlueprintReadWrite, Category = "CharacterInput")
+	bool ProcessPossess;
+	
+	UPROPERTY(BlueprintReadWrite, Category = "CharacterInput")
+	bool OnPossess;
+
+
 	/*Team ID*/
 	UPROPERTY(BlueprintReadOnly, Category = "Hit")
-		uint8 TeamID;
+	uint8 TeamID;
 	void AutoDeterminTeamIDbyControllerType();
 
 protected:
-
 	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Components")
-		USActionComponent* ActionComp;
+	USActionComponent* ActionComp;
 
 	class UInputComponent* PlayerInputComp;
 
 	/*setup dash animation montage*/
 	UPROPERTY(BlueprintReadWrite, Category = "AnimMontage")
-		UAnimMontage* Montage_GetAttack;
+	UAnimMontage* Montage_GetAttack;
 
 	UPROPERTY(EditAnywhere, Category = "AnimMontage")
-		UAnimMontage* Montage_FDodge;
+	UAnimMontage* Montage_FDodge;
 
 	UPROPERTY(EditAnywhere, Category = "AnimMontage")
-		UAnimMontage* Montage_RDodge;
+	UAnimMontage* Montage_RDodge;
 
 	UPROPERTY(EditAnywhere, Category = "AnimMontage")
-		UAnimMontage* Montage_LDodge;
+	UAnimMontage* Montage_LDodge;
 
 	UPROPERTY(EditAnywhere, Category = "AnimMontage")
-		UAnimMontage* Montage_BDodge;
+	UAnimMontage* Montage_BDodge;
 
 	UPROPERTY(EditAnywhere, Category = "AnimMontage")
-		UAnimMontage* Montage_Equip;
+	UAnimMontage* Montage_Equip;
 
 	UPROPERTY(EditAnywhere, Category = "AnimMontage")
-		UAnimMontage* Montage_Unequip;
+	UAnimMontage* Montage_Unequip;
 
 public:
-
 	/*Ability System setup*/
 	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "GAS")
-		class USAbilitySystemComponent* AbilitySystemComp;
+	class USAbilitySystemComponent* AbilitySystemComp;
 
 	UPROPERTY(EditAnywhere, Category = "GAS")
-		TArray<TSubclassOf<UGameplayAbility>> GA_Ability;
+	TArray<TSubclassOf<UGameplayAbility>> GA_Ability;
 
 	virtual UAbilitySystemComponent* GetAbilitySystemComponent() const;
 
 	UFUNCTION(BlueprintCallable, Category = "GAS")
-		virtual void InitializeAttributes(TSubclassOf<UGameplayAbility> AbilityToGet, int32 AbilityLevel);
+	virtual void InitializeAttributes(TSubclassOf<UGameplayAbility> AbilityToGet, int32 AbilityLevel);
 
 	int32 AbilityLevelSetup;
 
 	/*Attribute setup*/
 	UPROPERTY(VisibleAnywhere, BlueprintReadWrite, Category = "GAS")
-		const class USAttributeSet* AttributeSettings;
+	const class USAttributeSet* AttributeSettings;
 
 	UFUNCTION(BlueprintPure, Category = "GAS")
-		void GetHealthValues(float& Health, float& MaxHealth);
+	void Getn_BASIC_HPValues(float& n_BASIC_HP, float& Maxn_BASIC_HP);
+	UFUNCTION(BlueprintPure, Category = "GAS")
+	void Gethn_BASIC_MPValues(float& n_BASIC_MP, float& Maxn_BASIC_MP);
 	UFUNCTION(BlueprintPure, Category = "GAS")
-		void GethManaValues(float& Mana, float& MaxMana);
+	void Getn_BASIC_SPValues(float& n_BASIC_SP, float& Maxn_BASIC_SP);
 	UFUNCTION(BlueprintPure, Category = "GAS")
-		void GetStaminaValues(float& Stamina, float& MaxStamina);
+	void Getn_BAISC_DPValues(float& n_BAISC_DP, float& Maxn_BAISC_DP);
 	UFUNCTION(BlueprintPure, Category = "GAS")
-		void GetAttackPowerValues(float& AttackPower, float& MaxAttackPower);
+	void Getn_LVValues(float& n_LV, float& Maxn_LV);
+	UFUNCTION(BlueprintPure, Category = "GAS")
+	void Getn_EXPValues(float& n_EXP, float& Maxn_EXP);
+	UFUNCTION(BlueprintPure, Category = "GAS")
+	void Getn_BAISC_DATKValues(float& n_BAISC_DATK, float& Maxn_BAISC_DATK);
+	UFUNCTION(BlueprintPure, Category = "GAS")
+	void Getn_BAISC_DDEFValues(float& n_BAISC_DDEF, float& Maxn_BAISC_DDEF);
+	UFUNCTION(BlueprintPure, Category = "GAS")
+	void Getn_BAISC_MOVE_SPEEDValues(float& n_BAISC_MOVE_SPEED, float& Maxn_BAISC_MOVE_SPEED);
+	UFUNCTION(BlueprintPure, Category = "GAS")
+	void Getn_BAISC_ATTACK_SPEEDValues(float& n_BAISC_ATTACK_SPEED, float& Maxn_BAISC_ATTACK_SPEED);
+	UFUNCTION(BlueprintPure, Category = "GAS")
+	void Getn_CRIValues(float& n_CRI, float& Maxn_CRI);
+	UFUNCTION(BlueprintPure, Category = "GAS")
+	void Getn_CRI_PROPORTIONValues(float& n_CRI_PROPORTION, float& Maxn_CRI_PROPORTION);
 
-	void OnHealthChangedNative(const FOnAttributeChangeData& Data);
-	void OnManaChangedNative(const FOnAttributeChangeData& Data);
-	void OnStaminaChangedNative(const FOnAttributeChangeData& Data);
-	void OnAttackPowerChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_BASIC_HPChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_BASIC_MPChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_BASIC_SPChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_BAISC_DPChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_LVChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_EXPChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_BAISC_DATKChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_BAISC_DDEFChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_BAISC_MOVE_SPEEDChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_BAISC_ATTACK_SPEEDChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_CRIChangedNative(const FOnAttributeChangeData& Data);
+	void Onn_CRI_PROPORTIONChangedNative(const FOnAttributeChangeData& Data);
 
 	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
-		void OnHealthChanged(float OldValue, float NewValue);
+	void Onn_BASIC_HPChanged(float OldValue, float NewValue);
+	UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "GAS")
+	void BP_Die();
 	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
-		void BP_Die();
+	void Onn_BASIC_MPChanged(float OldValue, float NewValue);
+	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
+	void Onn_BASIC_SPChanged(float OldValue, float NewValue);
+	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
+	void Onn_BAISC_DPChanged(float OldValue, float NewValue);
+	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
+	void Onn_LVChanged(float OldValue, float NewValue);
+	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
+	void Onn_EXPChanged(float OldValue, float NewValue);
+	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
+	void Onn_BAISC_DATKChanged(float OldValue, float NewValue);
+	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
+	void Onn_BAISC_DDEFChanged(float OldValue, float NewValue);
 	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
-		void OnManaChanged(float OldValue, float NewValue);
+	void Onn_BAISC_MOVE_SPEEDChanged(float OldValue, float NewValue);
 	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
-		void OnStaminaChanged(float OldValue, float NewValue);
+	void Onn_BAISC_ATTACK_SPEEDChanged(float OldValue, float NewValue);
 	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
-		void OnAttackPowerChanged(float OldValue, float NewValue);
+	void Onn_CRIChanged(float OldValue, float NewValue);
+	UFUNCTION(BlueprintImplementableEvent, Category = "GAS")
+	void Onn_CRI_PROPORTIONChanged(float OldValue, float NewValue);
 
 	/*Setup Revering Time function*/
 	UFUNCTION(BlueprintCallable, Category = "ReverseTime")
-		void StartReversingTime();
+	void StartReversingTime();
 
 	UFUNCTION(BlueprintCallable, Category = "ReverseTime")
-		void EndReversingTime();
+	void EndReversingTime();
 
 	FReverseTimeDelegate ReverseTimeDelegate;
 };
-
Index: Source/FIM/Private/FIMCharacter.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Copyright Epic Games, Inc. All Rights Reserved.\r\n\r\n#include \"FIMCharacter.h\"\r\n#include \"Camera/CameraComponent.h\"\r\n#include \"Components/CapsuleComponent.h\"\r\n#include \"Components/InputComponent.h\"\r\n#include \"GameFramework/CharacterMovementComponent.h\"\r\n#include \"GameFramework/Controller.h\"\r\n#include \"GameFramework/SpringArmComponent.h\"\r\n#include \"Components/SkeletalMeshComponent.h\"\r\n#include \"Components/StaticMeshComponent.h\"\r\n#include \"Components/SceneComponent.h\"\r\n#include \"Logging/LogMacros.h\"\r\n#include \"Kismet/KismetMathLibrary.h\"\r\n#include \"Math/RotationMatrix.h\"\r\n#include \"Animation/AnimInstance.h\"\r\n#include \"Animation/AnimMontage.h\"\r\n#include \"Kismet/GameplayStatics.h\"\r\n#include \"Misc/App.h\"\r\n#include \"TimerManager.h\"\r\n#include \"Engine/World.h\"\r\n#include \"SAbilitySystemComponent.h\"\r\n#include \"SAttributeSet.h\"\r\n#include \"GameplayAbilitySpec.h\"\r\n#include <GameplayEffectTypes.h>\r\n#include \"SGameplayAbility.h\"\r\n#include \"Abilities/Tasks/AbilityTask.h\"\r\n#include \"Components/PrimitiveComponent.h\"\r\n#include \"Animation/AnimNotifies/AnimNotify.h\"\r\n//#include \"HeadMountedDisplayFunctionLibrary.h\"\r\n#include \"FIM/FIM.h\"\r\n#include \"SActionComponent.h\"\r\n#include \"AIController.h\"\r\n#include \"BrainComponent.h\"\r\n#include \"Net/UnrealNetwork.h\"\r\n#include \"Engine/Engine.h\"\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n// AFIMCharacter\r\n\r\nAFIMCharacter::AFIMCharacter()\r\n{\r\n\t// Set size for collision capsule\r\n\tCapsuleComp = GetCapsuleComponent();\r\n\tGetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);\r\n\r\n\t//get skeletal mesh & set up weapon for it.\r\n// \tCharacterMeshComp = GetMesh();\r\n\tCharacterMeshComp = GetMesh();\r\n\tCharacterMeshComp->SetSimulatePhysics(true);\r\n\tCharacterMeshComp->SetAllBodiesSimulatePhysics(true);\r\n\t\r\n\tWeaponComp_R = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Weapon_R\"));\r\n   \tWeaponComp_R->SetupAttachment(CharacterMeshComp);\r\n\r\n\tWeaponComp_L = CreateDefaultSubobject<UStaticMeshComponent>(TEXT(\"Weapon_L\"));\r\n  \tWeaponComp_L->SetupAttachment(CharacterMeshComp);\r\n\r\n\t// set our turn rate for input\r\n\tTurnRateGamepad = 50.f;\r\n\tBaseTurnRate = 45.f;\r\n\tBaseLookUpRate = 45.f;\r\n\r\n\t// Don't rotate when the controller rotates. Let that just affect the camera.\r\n\tbUseControllerRotationPitch = false;\r\n\tbUseControllerRotationYaw = false;\r\n\tbUseControllerRotationRoll = false;\r\n\r\n\t// Configure character movement\r\n\tCMComp = GetCharacterMovement();\r\n\tCMComp->bOrientRotationToMovement = true; // Character moves in the direction of input...\t\r\n\tCMComp->bAllowPhysicsRotationDuringAnimRootMotion = false;\r\n\tCMComp->RotationRate = FRotator(0.0f, 500.0f, 0.0f); // ...at this rotation rate\r\n\tCMComp->JumpZVelocity = 600.0f;\r\n\tCMComp->AirControl = 0.2f;\r\n\r\n\r\n\t// Configure character movement\r\n\tGetCharacterMovement()->bOrientRotationToMovement = true; // Character moves in the direction of input...\t\r\n\tGetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f); // ...at this rotation rate\r\n\r\n\t// Note: For faster iteration times these variables, and many more, can be tweaked in the Character Blueprint\r\n\t// instead of recompiling to adjust them\r\n\tGetCharacterMovement()->JumpZVelocity = 700.f;\r\n\tGetCharacterMovement()->AirControl = 0.35f;\r\n\tGetCharacterMovement()->MaxWalkSpeed = 500.f;\r\n\tGetCharacterMovement()->MinAnalogWalkSpeed = 20.f;\r\n\tGetCharacterMovement()->BrakingDecelerationWalking = 2000.f;\r\n\r\n\t// Create a camera boom (pulls in towards the player if there is a collision)\r\n\tCameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT(\"CameraBoom\"));\r\n\tCameraBoom->SetupAttachment(RootComponent);\r\n\tCameraBoom->TargetArmLength = 400.0f; // The camera follows at this distance behind the character\t\r\n\tCameraBoom->bUsePawnControlRotation = true; // Rotate the arm based on the controller\r\n\tCameraBoom->SetRelativeRotation(FRotator(-45.0f, 0.0f, 0.0f));\r\n\t//make camera more realistic and heavy\r\n\tCameraBoom->bEnableCameraLag = true;\r\n\tCameraBoom->bEnableCameraRotationLag = true;\r\n\tCameraBoom->CameraLagSpeed = 50.0f;\r\n\tCameraBoom->CameraRotationLagSpeed = 50.0f;\r\n\tCameraBoom->CameraLagMaxDistance = 10.0f;\r\n\r\n\t// Create a follow camera\r\n\tCameraComp = CreateDefaultSubobject<UCameraComponent>(TEXT(\"FollowCamera\"));\r\n\tCameraComp->SetupAttachment(CameraBoom, USpringArmComponent::SocketName); // Attach the camera to the end of the boom and let the boom adjust to match the controller orientation\r\n\tCameraComp->bUsePawnControlRotation = false; // Camera does not rotate relative to arm\r\n\r\n\tWalkingSpeed = 200;\r\n\tSprintSpeed = 800;\r\n\tDashDistance = 5000.0f;\r\n\tDashDelayTime = 1.0f;\r\n\tDelayAttackEnd = 2.0f;\r\n\r\n\tBlockSpeed = 200;\r\n\tIsCombatMode = false;\r\n\r\n\tTimeToHitParamName = \"TimeToHit\";\r\n\r\n\t// Ability System Components\r\n\tAbilitySystemComp = CreateDefaultSubobject<USAbilitySystemComponent>(\"AbilitySystemComp\");\r\n\tAbilitySystemComp->SetIsReplicated(true);\r\n\tAbilitySystemComp->SetReplicationMode(EGameplayEffectReplicationMode::Minimal);\r\n\r\n\tAttributeSettings = CreateDefaultSubobject<USAttributeSet>(\"AttributeSettings\");\r\n\r\n\tActionComp = CreateDefaultSubobject<USActionComponent>(\"ActionComp\");\r\n\r\n\tbIsDead = false;\r\n\r\n\tbIsBlock = false;\r\n\r\n\tbIsHitted = false;\r\n\r\n\tTeamID = 255;\r\n\r\n\tIsMoving = false;\r\n\r\n\tPlayMontageRate = 1.0f;\r\n\r\n\tbReplicates = true;\r\n\r\n\tStopMovementSpeed = 0;\r\n}\r\n\r\nvoid AFIMCharacter::BeginPlay()\r\n{\r\n\tSuper::BeginPlay();\r\n\tServer_Equip(\"S_Unequip_L\", \"S_Unequip_R\");\r\n\r\n\tif (AbilitySystemComp)\r\n\t{\r\n\t\tAttributeSettings = AbilitySystemComp->GetSet<USAttributeSet>();\r\n\r\n\t\tAbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->GetHealthAttribute()).AddUObject(this, &AFIMCharacter::OnHealthChangedNative);\r\n\t\tAbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->GetManaAttribute()).AddUObject(this, &AFIMCharacter::OnManaChangedNative);\r\n\t\tAbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->GetStaminaAttribute()).AddUObject(this, &AFIMCharacter::OnStaminaChangedNative);\r\n\t\tAbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->GetAttackPowerAttribute()).AddUObject(this, &AFIMCharacter::OnAttackPowerChangedNative);\r\n\t\tAbilityLevelSetup = 1;\r\n\t}\r\n\r\n\tAutoDeterminTeamIDbyControllerType();\r\n}\r\n\r\nvoid AFIMCharacter::Tick(float DeltaTime)\r\n{\r\n\tSuper::Tick(DeltaTime);\r\n\r\n\t/*\r\n\t\tGEngine->AddOnScreenDebugMessage(-1, 0.0f, FColor::Yellow, FString::Printf(TEXT(\"Player InputZ %f\"), InputZ));\r\n\t\tGEngine->AddOnScreenDebugMessage(-1, 0.0f, FColor::Yellow, FString::Printf(TEXT(\"Player InputX %f\"), InputX));\r\n\t\tGEngine->AddOnScreenDebugMessage(-1, 0.0f, FColor::Yellow, FString::Printf(TEXT(\"ActorDirection %s\"), *ActorDirection.ToString()));\r\n\t\tGEngine->AddOnScreenDebugMessage(-1, 0.0f, FColor::Yellow, FString::Printf(TEXT(\"ForwardDir %s\"), *ForwardDir.ToString()));\r\n\t\tGEngine->AddOnScreenDebugMessage(-1, 0.0f, FColor::Yellow, FString::Printf(TEXT(\"Player Speed %f\"), CM->MaxWalkSpeed));\r\n\t\tGEngine->AddOnScreenDebugMessage(-1, 0.0f, FColor::Yellow, FString::Printf(TEXT(\"Player Direction %f\"), PlayerDirection));\r\n\t\tGEngine->AddOnScreenDebugMessage(-1, 0.0f, FColor::Yellow, FString::Printf(TEXT(\"AttackNumber %i\"), Attack_Num));\r\n\r\n\t\tGEngine->AddOnScreenDebugMessage(-1, 0.0f, FColor::Yellow, FString::Printf(TEXT(\"IsDashing %s\"), (bIsDashing ? TEXT(\"true\") : TEXT(\"false\"))));\r\n\t*/\r\n\r\n\tInputZ = InputZ * DeltaTime;\r\n\tInputX = InputX * DeltaTime;\r\n\r\n\tDisableRotationInWalking();\r\n\tConculateLastInput();\r\n}\r\n\r\nvoid AFIMCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)\r\n{\r\n\t// Set up gameplay key bindings\r\n\tcheck(PlayerInputComponent);\r\n\tPlayerInputComponent->BindAction(\"Jump\", IE_Pressed, this, &ACharacter::Jump);\r\n\tPlayerInputComponent->BindAction(\"Jump\", IE_Released, this, &ACharacter::StopJumping);\r\n\r\n\tPlayerInputComponent->BindAction(\"CombatMode\", IE_Pressed, this, &AFIMCharacter::Server_CombatMode);\r\n\tPlayerInputComponent->BindAction(\"Sprint\", IE_Pressed, this, &AFIMCharacter::SprintStart);\r\n\tPlayerInputComponent->BindAction(\"Sprint\", IE_Released, this, &AFIMCharacter::SprintEnd);\r\n\tPlayerInputComponent->BindAction(\"Dash\", IE_Pressed, this, &AFIMCharacter::Dashing);\r\n\r\n\tPlayerInputComponent->BindAction(\"NormlaAttack\", IE_Pressed, this, &AFIMCharacter::Server_Attack);\r\n\r\n\tPlayerInputComponent->BindAction(\"Blocking\", IE_Pressed, this, &AFIMCharacter::BlockingStart);\r\n\tPlayerInputComponent->BindAction(\"Blocking\", IE_Released, this, &AFIMCharacter::BlockingEnd);\r\n\r\n\tPlayerInputComponent->BindAction(\"ReverseTime\", IE_Pressed, this, &AFIMCharacter::StartReversingTime);\r\n\tPlayerInputComponent->BindAction(\"ReverseTime\", IE_Released, this, &AFIMCharacter::EndReversingTime);\r\n\r\n\tPlayerInputComponent->BindAxis(\"Move Forward / Backward\", this, &AFIMCharacter::MoveForward);\r\n\tPlayerInputComponent->BindAxis(\"Move Right / Left\", this, &AFIMCharacter::MoveRight);\r\n\r\n\t// We have 2 versions of the rotation bindings to handle different kinds of devices differently\r\n\t// \"turn\" handles devices that provide an absolute delta, such as a mouse.\r\n\t// \"turnrate\" is for devices that we choose to treat as a rate of change, such as an analog joystick\r\n\tPlayerInputComponent->BindAxis(\"Turn Right / Left Mouse\", this, &APawn::AddControllerYawInput);\r\n\tPlayerInputComponent->BindAxis(\"Turn Right / Left Gamepad\", this, &AFIMCharacter::TurnAtRate);\r\n\tPlayerInputComponent->BindAxis(\"Look Up / Down Mouse\", this, &APawn::AddControllerPitchInput);\r\n\tPlayerInputComponent->BindAxis(\"Look Up / Down Gamepad\", this, &AFIMCharacter::LookUpAtRate);\r\n\r\n\t// handle touch devices\r\n\tPlayerInputComponent->BindTouch(IE_Pressed, this, &AFIMCharacter::TouchStarted);\r\n\tPlayerInputComponent->BindTouch(IE_Released, this, &AFIMCharacter::TouchStopped);\r\n\r\n\tif (AbilitySystemComp && InputComponent)\r\n\t{\r\n\t\tconst FGameplayAbilityInputBinds Binds(\"Confirm\", \"Cancel\", \"EGASAbilityInputID\", static_cast<int32>(EGASAbilityInputID::Confirm), static_cast<int32>(EGASAbilityInputID::Cancel));\r\n\t\tAbilitySystemComp->BindAbilityActivationToInputComponent(InputComponent, Binds);\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::Server_CombatMode_Implementation()\r\n{\r\n\tif (!IsCombatMode)\r\n\t{\r\n\t\tCombatStart(true, false, true);\r\n\t\tCombatModeEvent(true);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tCombatStart(false, true, false);\r\n\t\tCombatModeEvent(false);\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::CombatModeEvent_Implementation(bool OnCombatStart)\r\n{\r\n\r\n}\r\n\r\nvoid AFIMCharacter::Server_Equip_Implementation(FName SkeletalName_L, FName SkeletalName_R)\r\n{\r\n\tWeaponComp_L->AttachToComponent(CharacterMeshComp, FAttachmentTransformRules::SnapToTargetIncludingScale, SkeletalName_L);\r\n\tWeaponComp_R->AttachToComponent(CharacterMeshComp, FAttachmentTransformRules::SnapToTargetIncludingScale, SkeletalName_R);\r\n}\r\n\r\n\r\n/*\r\nvoid AFIMCharacter::Server_Equip_Implementation()\r\n{\r\n}*/\r\n\r\nvoid AFIMCharacter::Server_Attack_Implementation()\r\n{\r\n\tSetReplicates(true);\r\n\r\n\tif (GA_Ability.Num() > 0 && IsCombatMode == true)\r\n\t{\r\n\t\tAbilitySystemComp->TryActivateAbilityByClass(GA_Ability[0], true);\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::NormalAttack(UAnimMontage* NormalAttack_1, UAnimMontage* NormalAttack_2, UAnimMontage* NormalAttack_3, UAnimMontage* NormalAttack_4)\r\n{\r\n\tif (bIsHitted == false)\r\n\t{\r\n\t\tswitch (Attack_Num)\r\n\t\t{\r\n\t\tcase 0:\r\n\t\t\tPlayAnimMontage(NormalAttack_1, 1);\r\n\t\t\tAM_Attack = NormalAttack_1;\r\n\t\t\tAttack_Num++;\r\n\t\t\tIsAttacking = true;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 1:\r\n\t\t\tPlayAnimMontage(NormalAttack_2, 1);\r\n\t\t\tAM_Attack = NormalAttack_2;\r\n\t\t\tAttack_Num++;\r\n\t\t\tIsAttacking = true;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 2:\r\n\t\t\tPlayAnimMontage(NormalAttack_3, 1);\r\n\t\t\tAM_Attack = NormalAttack_3;\r\n\t\t\tAttack_Num++;\r\n\t\t\tIsAttacking = true;\r\n\t\t\tbreak;\r\n\r\n\t\tcase 3:\r\n\t\t\tPlayAnimMontage(NormalAttack_4, 1);\r\n\t\t\tGetCharacterMovement()->bOrientRotationToMovement = true;\r\n\t\t\tGetCharacterMovement()->bUseControllerDesiredRotation = false;\r\n\t\t\tAM_Attack = NormalAttack_4;\r\n\t\t\tAttack_Num = 0;\r\n\t\t\tIsAttacking = true;\r\n\t\t\tbreak;\r\n\r\n\t\tdefault:\r\n\t\t\tAttack_Num = 0;\r\n\t\t\tAM_Attack = nullptr;\r\n\t\t}\r\n\r\n\t\tGetWorldTimerManager().SetTimer(TH_EndAttack, this, &AFIMCharacter::EndNormalAttack, DelayAttackEnd, false);\r\n\t}\r\n\r\n}\r\n\r\nvoid AFIMCharacter::EndNormalAttack()\r\n{\r\n\tAttack_Num = 0;\r\n\tAM_Attack = nullptr;\r\n\tIsAttacking = false;\r\n}\r\n\r\nvoid AFIMCharacter::CombatStart(bool DoCombatMode, bool IsOrientRotationToMovement, bool IsUseControllerDesiredRotation)\r\n{\r\n\tIsCombatMode = DoCombatMode;\r\n\tGetCharacterMovement()->bOrientRotationToMovement = IsOrientRotationToMovement;\r\n\tGetCharacterMovement()->bUseControllerDesiredRotation = IsUseControllerDesiredRotation;\r\n\r\n\tif (IsCombatMode == true)\r\n\t{\r\n\t\tGetCharacterMovement()->MaxWalkSpeed = BlockSpeed;\r\n\t\tPlayAnimMontage(Montage_Equip, 1, NAME_None);\r\n\t\tGetWorld()->GetTimerManager().SetTimer(EquipTimeDelay, [&]()\r\n\t\t\t{\r\n\t\t\t\tServer_Equip(\"S_Equip_L\", \"S_Equip_R\");\r\n\t\t\t}, 0.2f, false);\r\n\t}\r\n\telse\r\n\t{\r\n\t\tGetCharacterMovement()->MaxWalkSpeed = WalkingSpeed;\r\n\t\tPlayAnimMontage(Montage_Unequip, 1, NAME_None);\r\n\t\tGetWorld()->GetTimerManager().SetTimer(EquipTimeDelay, [&]()\r\n\t\t\t{\r\n\t\t\t\tServer_Equip(\"S_Unequip_L\", \"S_Unequip_R\");\r\n\t\t\t}, 0.2f, false);\r\n\t}\r\n\r\n}\r\n\r\nvoid AFIMCharacter::DisableRotationInWalking()\r\n{\r\n\tif (InputX == 0 && InputZ == 0)\r\n\t{\r\n\t\tGetCharacterMovement()->bOrientRotationToMovement = true;\r\n\t\tGetCharacterMovement()->bUseControllerDesiredRotation = false;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tGetCharacterMovement()->bOrientRotationToMovement = false;\r\n\t\tGetCharacterMovement()->bUseControllerDesiredRotation = true;\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::SprintStart()\r\n{\r\n\tIsSprinting = true;\r\n\r\n\tif (IsCombatMode == false)\r\n\t{\r\n\t\tGetCharacterMovement()->MaxWalkSpeed = SprintSpeed;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tGetCharacterMovement()->MaxWalkSpeed = SprintSpeed;\r\n\t}\r\n\r\n}\r\n\r\nvoid AFIMCharacter::SprintEnd()\r\n{\r\n\tIsSprinting = false;\r\n\r\n\tif (IsCombatMode == false)\r\n\t{\r\n\t\tGetCharacterMovement()->MaxWalkSpeed = WalkingSpeed;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tGetCharacterMovement()->MaxWalkSpeed = BlockSpeed;\r\n\t}\r\n\r\n}\r\n\r\nint32 AFIMCharacter::InputValue()\r\n{\r\n\tif (InputX > 0)\r\n\t\treturn 1;\r\n\telse if (InputX < 0)\r\n\t\treturn 2;\r\n\telse if (InputZ > 0)\r\n\t\treturn 3;\r\n\telse if (InputZ < 0)\r\n\t\treturn 4;\r\n\telse\r\n\t\treturn 0;\r\n}\r\n\r\nvoid AFIMCharacter::Dashing()\r\n{\r\n\tif (IsCombatMode == true)\r\n\t{\r\n\t\tif (!bIsDashing)\r\n\t\t{\r\n\t\t\tbIsDashing = true;\r\n\t\t\tswitch (InputValue())\r\n\t\t\t{\r\n\t\t\tcase 1:\r\n\t\t\t\tDashingMovement(CMComp);\r\n\t\t\t\tPlayAnimMontage(Montage_RDodge, PlayMontageRate, NAME_None);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 2:\r\n\t\t\t\tDashingMovement(CMComp);\r\n\t\t\t\tPlayAnimMontage(Montage_LDodge, PlayMontageRate, NAME_None);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 3:\r\n\t\t\t\tDashingMovement(CMComp);\r\n\t\t\t\tPlayAnimMontage(Montage_FDodge, PlayMontageRate, NAME_None);\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 4:\r\n\t\t\t\tDashingMovement(CMComp);\r\n\t\t\t\tPlayAnimMontage(Montage_BDodge, PlayMontageRate, NAME_None);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tGetWorld()->GetTimerManager().SetTimer(TH_Dashing, this, &AFIMCharacter::DashingEnd, DashDelayTime, false);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::DashingMovement(UCharacterMovementComponent* MovementComp)\r\n{\r\n\tif (IsReverseTime == false)\r\n\t{\r\n\t\tconst FVector Dash = MovementComp->GetLastInputVector();\r\n\t\tif (GetCharacterMovement()->Velocity != FVector::ZeroVector)\r\n\t\t{\r\n\t\t\tLaunchCharacter(Dash * DashDistance, true, true);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::PlayDashingMontage()\r\n{\r\n\tif (!bIsDashing)\r\n\t{\r\n\t\tbIsDashing = true;\r\n\t\tswitch (InputValue())\r\n\t\t{\r\n\t\tcase 1:\r\n\t\t\tPlayAnimMontage(Montage_RDodge, 1, NAME_None);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 2:\r\n\t\t\tPlayAnimMontage(Montage_LDodge, 1, NAME_None);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 3:\r\n\t\t\tPlayAnimMontage(Montage_FDodge, 1, NAME_None);\r\n\t\t\tbreak;\r\n\r\n\t\tcase 4:\r\n\t\t\tPlayAnimMontage(Montage_BDodge, 1, NAME_None);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tGetWorld()->GetTimerManager().SetTimer(TH_Dashing, this, &AFIMCharacter::DashingEnd, DashDelayTime, false);\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::DashingEnd()\r\n{\r\n\tbIsDashing = false;\r\n}\r\n\r\nvoid AFIMCharacter::ConculateLastInput()\r\n{\r\n\tLastInput = CMComp->GetLastInputVector();\r\n\tFRotator CameraRotation = CameraComp->GetComponentRotation();\r\n\r\n\tif (!LastInput.IsZero() || IsAttacking)\r\n\t{\r\n\t\tIsInput = true;\r\n\r\n\t\tif (IsInput == true)\r\n\t\t{\r\n\t\t\tLastRotation.Yaw = CameraRotation.Yaw;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tIsInput = false;\r\n\t\tLastInput.Zero();\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::InterToRotation(bool IsInter)\r\n{\r\n\tif (IsInter == true)\r\n\t{\r\n\t\tSetActorRotation(FMath::RInterpTo(GetActorRotation(), LastRotation, GetWorld()->GetDeltaSeconds(), RotationSpeed));\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::BlockingStart()\r\n{\r\n\tif (IsCombatMode)\r\n\t{\r\n\t\tbIsBlock = true;\r\n\t\tGetCharacterMovement()->StopMovementImmediately();\r\n\t\tOnInvicinble();\r\n\t}\r\n\telse\r\n\t{\r\n\t\tbIsBlock = false;\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::BlockingEnd()\r\n{\r\n\tbIsBlock = false;\r\n}\r\n\r\nvoid AFIMCharacter::OnInvicinble_Implementation()\r\n{\r\n\r\n}\r\n\r\nvoid AFIMCharacter::AutoDeterminTeamIDbyControllerType()\r\n{\r\n\tif (GetController() && GetController()->IsPlayerController())\r\n\t{\r\n\t\tTeamID = 0;\r\n\t}\r\n}\r\n\r\nbool AFIMCharacter::IsOtherHostile(AFIMCharacter* Other)\r\n{\r\n\treturn TeamID != Other->GetTeamID();\r\n}\r\n\r\nuint8 AFIMCharacter::GetTeamID() const\r\n{\r\n\treturn TeamID;\r\n}\r\n\r\nvoid AFIMCharacter::Dead_Implementation()\r\n{\r\n\tif (!bIsDead)\r\n\t{\r\n\t\tAPlayerController* PC = Cast<APlayerController>(GetController());\r\n\t\tif (PC)\r\n\t\t{\r\n\t\t\tPC->DisableInput(PC);\r\n\t\t}\r\n\r\n\t\tAAIController* AIC = Cast<AAIController>(GetController());\r\n\t\tif (AIC)\r\n\t\t{\r\n\t\t\tAIC->GetBrainComponent()->StopLogic(\"Dead\");\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::TouchStarted(ETouchIndex::Type FingerIndex, FVector Location)\r\n{\r\n\tJump();\r\n}\r\n\r\nvoid AFIMCharacter::TouchStopped(ETouchIndex::Type FingerIndex, FVector Location)\r\n{\r\n\tStopJumping();\r\n}\r\n\r\nvoid AFIMCharacter::TurnAtRate(float Rate)\r\n{\r\n\t// calculate delta for this frame from the rate information\r\n\tAddControllerYawInput(Rate * TurnRateGamepad * GetWorld()->GetDeltaSeconds());\r\n}\r\n\r\nvoid AFIMCharacter::LookUpAtRate(float Rate)\r\n{\r\n\t// calculate delta for this frame from the rate information\r\n\tAddControllerPitchInput(Rate * TurnRateGamepad * GetWorld()->GetDeltaSeconds());\r\n}\r\n\r\nvoid AFIMCharacter::MoveForward(float Value)\r\n{\r\n\tif ((Controller != nullptr) && (Value != 0.0f))\r\n\t{\r\n\t\t// find out which way is forward\r\n\t\tconst FRotator Rotation = Controller->GetControlRotation();\r\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\r\n\r\n\t\t// get forward vector\r\n\t\tconst FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);\r\n\t\tAddMovementInput(Direction, Value);\r\n\t}\r\n\r\n\tif (Value > 0 || Value < 0)\r\n\t{\r\n\t\tIsMoving = true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tIsMoving = false;\r\n\t}\r\n\r\n\tInputZ = Value;\r\n}\r\n\r\nvoid AFIMCharacter::MoveRight(float Value)\r\n{\r\n\tif ((Controller != nullptr) && (Value != 0.0f))\r\n\t{\r\n\t\t// find out which way is right\r\n\t\tconst FRotator Rotation = Controller->GetControlRotation();\r\n\t\tconst FRotator YawRotation(0, Rotation.Yaw, 0);\r\n\r\n\t\t// get right vector \r\n\t\tconst FVector Direction = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);\r\n\t\t// add movement in that direction\r\n\t\tAddMovementInput(Direction, Value);\r\n\t}\r\n\r\n\tif (Value > 0 || Value < 0)\r\n\t{\r\n\t\tIsMoving = true;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tIsMoving = false;\r\n\t}\r\n\r\n\tInputX = Value;\r\n}\r\n\r\nvoid AFIMCharacter::InitializeAttributes(TSubclassOf<UGameplayAbility> AbilityToGet, int32 AbilityLevel)\r\n{\r\n\tif (AbilitySystemComp)\r\n\t{\r\n\t\tif (HasAuthority() && AbilityToGet)\r\n\t\t{\r\n\t\t\tAbilityLevel = AbilityLevelSetup;\r\n\t\t\tAbilitySystemComp->GiveAbility(FGameplayAbilitySpec(AbilityToGet, AbilityLevel, 0));\r\n\t\t}\r\n\t\tAbilitySystemComp->InitAbilityActorInfo(this, this);//holds information about who we are acting on and who controls us.\r\n\t}\r\n}\r\n\r\nclass UAbilitySystemComponent* AFIMCharacter::GetAbilitySystemComponent() const\r\n{\r\n\treturn AbilitySystemComp;\r\n}\r\n\r\nvoid AFIMCharacter::GetHealthValues(float& Health, float& MaxHealth)\r\n{\r\n\tHealth = AttributeSettings->GetHealth();\r\n\tMaxHealth = AttributeSettings->GetMaxHealth();\r\n}\r\n\r\nvoid AFIMCharacter::GethManaValues(float& Mana, float& MaxMana)\r\n{\r\n\tMana = AttributeSettings->GetMana();\r\n\tMaxMana = AttributeSettings->GetMaxMana();\r\n}\r\n\r\nvoid AFIMCharacter::GetStaminaValues(float& Stamina, float& MaxStamina)\r\n{\r\n\tStamina = AttributeSettings->GetStamina();\r\n\tMaxStamina = AttributeSettings->GetMaxStamina();\r\n}\r\n\r\nvoid AFIMCharacter::GetAttackPowerValues(float& AttackPower, float& MaxAttackPower)\r\n{\r\n\tAttackPower = AttributeSettings->GetAttackPower();\r\n\tAttackPower = AttributeSettings->GetMaxAttackPower();\r\n}\r\n\r\nvoid AFIMCharacter::OnHealthChangedNative(const FOnAttributeChangeData& Data)\r\n{\r\n\tOnHealthChanged(Data.OldValue, Data.NewValue);\r\n\tif (Data.OldValue <= 0.0f && !bIsDead)\r\n\t{\r\n\t\tDead();\r\n\t\tbIsDead = true;\r\n\t\tBP_Die();\r\n\t}\r\n}\r\n\r\nvoid AFIMCharacter::OnManaChangedNative(const FOnAttributeChangeData& Data)\r\n{\r\n\tOnManaChanged(Data.OldValue, Data.NewValue);\r\n}\r\n\r\nvoid AFIMCharacter::OnStaminaChangedNative(const FOnAttributeChangeData& Data)\r\n{\r\n\tOnStaminaChanged(Data.OldValue, Data.NewValue);\r\n}\r\n\r\nvoid AFIMCharacter::OnAttackPowerChangedNative(const FOnAttributeChangeData& Data)\r\n{\r\n\tOnAttackPowerChanged(Data.OldValue, Data.NewValue);\r\n}\r\n\r\nvoid AFIMCharacter::StartReversingTime()\r\n{\r\n\tReverseTimeDelegate.Broadcast(true);\r\n\tIsReverseTime = true;\r\n\tPlayMontageRate = -1.0f;\r\n}\r\n\r\nvoid AFIMCharacter::EndReversingTime()\r\n{\r\n\tReverseTimeDelegate.Broadcast(false);\r\n\tIsReverseTime = false;\r\n\tPlayMontageRate = 1.0f;\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FIM/Private/FIMCharacter.cpp b/Source/FIM/Private/FIMCharacter.cpp
--- a/Source/FIM/Private/FIMCharacter.cpp	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Source/FIM/Private/FIMCharacter.cpp	(date 1722680502476)
@@ -45,16 +45,16 @@
 	GetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);
 
 	//get skeletal mesh & set up weapon for it.
-// 	CharacterMeshComp = GetMesh();
+	// 	CharacterMeshComp = GetMesh();
 	CharacterMeshComp = GetMesh();
 	CharacterMeshComp->SetSimulatePhysics(true);
 	CharacterMeshComp->SetAllBodiesSimulatePhysics(true);
-	
+
 	WeaponComp_R = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Weapon_R"));
-   	WeaponComp_R->SetupAttachment(CharacterMeshComp);
+	WeaponComp_R->SetupAttachment(CharacterMeshComp);
 
 	WeaponComp_L = CreateDefaultSubobject<UStaticMeshComponent>(TEXT("Weapon_L"));
-  	WeaponComp_L->SetupAttachment(CharacterMeshComp);
+	WeaponComp_L->SetupAttachment(CharacterMeshComp);
 
 	// set our turn rate for input
 	TurnRateGamepad = 50.f;
@@ -102,7 +102,8 @@
 
 	// Create a follow camera
 	CameraComp = CreateDefaultSubobject<UCameraComponent>(TEXT("FollowCamera"));
-	CameraComp->SetupAttachment(CameraBoom, USpringArmComponent::SocketName); // Attach the camera to the end of the boom and let the boom adjust to match the controller orientation
+	CameraComp->SetupAttachment(CameraBoom, USpringArmComponent::SocketName);
+	// Attach the camera to the end of the boom and let the boom adjust to match the controller orientation
 	CameraComp->bUsePawnControlRotation = false; // Camera does not rotate relative to arm
 
 	WalkingSpeed = 200;
@@ -151,11 +152,47 @@
 	{
 		AttributeSettings = AbilitySystemComp->GetSet<USAttributeSet>();
 
-		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->GetHealthAttribute()).AddUObject(this, &AFIMCharacter::OnHealthChangedNative);
-		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->GetManaAttribute()).AddUObject(this, &AFIMCharacter::OnManaChangedNative);
-		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->GetStaminaAttribute()).AddUObject(this, &AFIMCharacter::OnStaminaChangedNative);
-		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->GetAttackPowerAttribute()).AddUObject(this, &AFIMCharacter::OnAttackPowerChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->Getn_BASIC_HPAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_BASIC_HPChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->Getn_BASIC_MPAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_BASIC_MPChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->Getn_BASIC_SPAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_BASIC_SPChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->Getn_BAISC_DPAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_BAISC_DPChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->Getn_LVAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_LVChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->Getn_EXPAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_EXPChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->Getn_BAISC_DATKAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_BAISC_DATKChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->Getn_BAISC_DDEFAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_BAISC_DDEFChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(AttributeSettings->Getn_BAISC_MOVE_SPEEDAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_BAISC_MOVE_SPEEDChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(
+			                   AttributeSettings->Getn_BAISC_ATTACK_SPEEDAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_BAISC_ATTACK_SPEEDChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(
+			                   AttributeSettings->Getn_CRIAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_CRIChangedNative);
+		AbilitySystemComp->GetGameplayAttributeValueChangeDelegate(
+			                   AttributeSettings->Getn_CRI_PROPORTIONAttribute()).
+		                   AddUObject(
+			                   this, &AFIMCharacter::Onn_CRI_PROPORTIONChangedNative);
 		AbilityLevelSetup = 1;
+		CurrentMaximonn_BASIC_HP = AttributeSettings->GetMaxn_BASIC_HP();
 	}
 
 	AutoDeterminTeamIDbyControllerType();
@@ -197,6 +234,8 @@
 	PlayerInputComponent->BindAction("Dash", IE_Pressed, this, &AFIMCharacter::Dashing);
 
 	PlayerInputComponent->BindAction("NormlaAttack", IE_Pressed, this, &AFIMCharacter::Server_Attack);
+	PlayerInputComponent->BindAction("Devour", IE_Pressed, this, &AFIMCharacter::Devour);
+	PlayerInputComponent->BindAction("PossessMonster", IE_Pressed, this, &AFIMCharacter::PossessedEvent);
 
 	PlayerInputComponent->BindAction("Blocking", IE_Pressed, this, &AFIMCharacter::BlockingStart);
 	PlayerInputComponent->BindAction("Blocking", IE_Released, this, &AFIMCharacter::BlockingEnd);
@@ -221,7 +260,9 @@
 
 	if (AbilitySystemComp && InputComponent)
 	{
-		const FGameplayAbilityInputBinds Binds("Confirm", "Cancel", "EGASAbilityInputID", static_cast<int32>(EGASAbilityInputID::Confirm), static_cast<int32>(EGASAbilityInputID::Cancel));
+		const FGameplayAbilityInputBinds Binds("Confirm", "Cancel", "EGASAbilityInputID",
+		                                       static_cast<int32>(EGASAbilityInputID::Confirm),
+		                                       static_cast<int32>(EGASAbilityInputID::Cancel));
 		AbilitySystemComp->BindAbilityActivationToInputComponent(InputComponent, Binds);
 	}
 }
@@ -242,13 +283,14 @@
 
 void AFIMCharacter::CombatModeEvent_Implementation(bool OnCombatStart)
 {
-
 }
 
 void AFIMCharacter::Server_Equip_Implementation(FName SkeletalName_L, FName SkeletalName_R)
 {
-	WeaponComp_L->AttachToComponent(CharacterMeshComp, FAttachmentTransformRules::SnapToTargetIncludingScale, SkeletalName_L);
-	WeaponComp_R->AttachToComponent(CharacterMeshComp, FAttachmentTransformRules::SnapToTargetIncludingScale, SkeletalName_R);
+	WeaponComp_L->AttachToComponent(CharacterMeshComp, FAttachmentTransformRules::SnapToTargetIncludingScale,
+	                                SkeletalName_L);
+	WeaponComp_R->AttachToComponent(CharacterMeshComp, FAttachmentTransformRules::SnapToTargetIncludingScale,
+	                                SkeletalName_R);
 }
 
 
@@ -267,51 +309,31 @@
 	}
 }
 
-void AFIMCharacter::NormalAttack(UAnimMontage* NormalAttack_1, UAnimMontage* NormalAttack_2, UAnimMontage* NormalAttack_3, UAnimMontage* NormalAttack_4)
+void AFIMCharacter::NormalAttack(const TArray<UAnimMontage*>& NormalAttacks)
 {
-	if (bIsHitted == false)
-	{
-		switch (Attack_Num)
-		{
-		case 0:
-			PlayAnimMontage(NormalAttack_1, 1);
-			AM_Attack = NormalAttack_1;
-			Attack_Num++;
-			IsAttacking = true;
-			break;
-
-		case 1:
-			PlayAnimMontage(NormalAttack_2, 1);
-			AM_Attack = NormalAttack_2;
-			Attack_Num++;
-			IsAttacking = true;
-			break;
-
-		case 2:
-			PlayAnimMontage(NormalAttack_3, 1);
-			AM_Attack = NormalAttack_3;
-			Attack_Num++;
-			IsAttacking = true;
-			break;
+    if (bIsHitted == false && NormalAttacks.Num() > 0)
+    {
+        if (Attack_Num < NormalAttacks.Num())
+        {
+            PlayAnimMontage(NormalAttacks[Attack_Num], 1);
+            AM_Attack = NormalAttacks[Attack_Num];
+            Attack_Num++;
+            IsAttacking = true;
 
-		case 3:
-			PlayAnimMontage(NormalAttack_4, 1);
-			GetCharacterMovement()->bOrientRotationToMovement = true;
-			GetCharacterMovement()->bUseControllerDesiredRotation = false;
-			AM_Attack = NormalAttack_4;
-			Attack_Num = 0;
-			IsAttacking = true;
-			break;
-
-		default:
-			Attack_Num = 0;
-			AM_Attack = nullptr;
-		}
+            // 如果這是最後一個攻擊動畫，重置 Attack_Num 並設定旋轉屬性
+            if (Attack_Num == NormalAttacks.Num())
+            {
+                GetCharacterMovement()->bOrientRotationToMovement = true;
+                GetCharacterMovement()->bUseControllerDesiredRotation = false;
+                Attack_Num = 0;
+            }
 
-		GetWorldTimerManager().SetTimer(TH_EndAttack, this, &AFIMCharacter::EndNormalAttack, DelayAttackEnd, false);
-	}
+            // 設置攻擊結束計時器
+            GetWorldTimerManager().SetTimer(TH_EndAttack, this, &AFIMCharacter::EndNormalAttack, DelayAttackEnd, false);
+        }
+    }
+}
 
-}
 
 void AFIMCharacter::EndNormalAttack()
 {
@@ -331,20 +353,19 @@
 		GetCharacterMovement()->MaxWalkSpeed = BlockSpeed;
 		PlayAnimMontage(Montage_Equip, 1, NAME_None);
 		GetWorld()->GetTimerManager().SetTimer(EquipTimeDelay, [&]()
-			{
-				Server_Equip("S_Equip_L", "S_Equip_R");
-			}, 0.2f, false);
+		{
+			Server_Equip("S_Equip_L", "S_Equip_R");
+		}, 0.2f, false);
 	}
 	else
 	{
 		GetCharacterMovement()->MaxWalkSpeed = WalkingSpeed;
 		PlayAnimMontage(Montage_Unequip, 1, NAME_None);
 		GetWorld()->GetTimerManager().SetTimer(EquipTimeDelay, [&]()
-			{
-				Server_Equip("S_Unequip_L", "S_Unequip_R");
-			}, 0.2f, false);
+		{
+			Server_Equip("S_Unequip_L", "S_Unequip_R");
+		}, 0.2f, false);
 	}
-
 }
 
 void AFIMCharacter::DisableRotationInWalking()
@@ -373,7 +394,6 @@
 	{
 		GetCharacterMovement()->MaxWalkSpeed = SprintSpeed;
 	}
-
 }
 
 void AFIMCharacter::SprintEnd()
@@ -388,7 +408,6 @@
 	{
 		GetCharacterMovement()->MaxWalkSpeed = BlockSpeed;
 	}
-
 }
 
 int32 AFIMCharacter::InputValue()
@@ -508,7 +527,8 @@
 {
 	if (IsInter == true)
 	{
-		SetActorRotation(FMath::RInterpTo(GetActorRotation(), LastRotation, GetWorld()->GetDeltaSeconds(), RotationSpeed));
+		SetActorRotation(FMath::RInterpTo(GetActorRotation(), LastRotation, GetWorld()->GetDeltaSeconds(),
+		                                  RotationSpeed));
 	}
 }
 
@@ -533,7 +553,14 @@
 
 void AFIMCharacter::OnInvicinble_Implementation()
 {
+}
 
+void AFIMCharacter::PossessedEvent_Implementation()
+{
+	/*if (OnPossess == true)
+	{
+		ProcessPossess = true;
+	}*/
 }
 
 void AFIMCharacter::AutoDeterminTeamIDbyControllerType()
@@ -654,7 +681,8 @@
 			AbilityLevel = AbilityLevelSetup;
 			AbilitySystemComp->GiveAbility(FGameplayAbilitySpec(AbilityToGet, AbilityLevel, 0));
 		}
-		AbilitySystemComp->InitAbilityActorInfo(this, this);//holds information about who we are acting on and who controls us.
+		AbilitySystemComp->InitAbilityActorInfo(this, this);
+		//holds information about who we are acting on and who controls us.
 	}
 }
 
@@ -663,54 +691,162 @@
 	return AbilitySystemComp;
 }
 
-void AFIMCharacter::GetHealthValues(float& Health, float& MaxHealth)
+void AFIMCharacter::Getn_BASIC_HPValues(float& n_BASIC_HP, float& Maxn_BASIC_HP)
+{
+	n_BASIC_HP = AttributeSettings->Getn_BASIC_HP();
+	Maxn_BASIC_HP = AttributeSettings->GetMaxn_BASIC_HP();
+}
+
+void AFIMCharacter::Gethn_BASIC_MPValues(float& n_BASIC_MP, float& Maxn_BASIC_MP)
+{
+	n_BASIC_MP = AttributeSettings->Getn_BASIC_MP();
+	Maxn_BASIC_MP = AttributeSettings->GetMaxn_BASIC_MP();
+}
+
+void AFIMCharacter::Getn_BASIC_SPValues(float& n_BASIC_SP, float& Maxn_BASIC_SP)
+{
+	n_BASIC_SP = AttributeSettings->Getn_BASIC_SP();
+	Maxn_BASIC_SP = AttributeSettings->GetMaxn_BASIC_SP();
+}
+
+void AFIMCharacter::Getn_BAISC_DPValues(float& n_BAISC_DP, float& Maxn_BAISC_DP)
 {
-	Health = AttributeSettings->GetHealth();
-	MaxHealth = AttributeSettings->GetMaxHealth();
+	n_BAISC_DP = AttributeSettings->Getn_BAISC_DP();
+	Maxn_BAISC_DP = AttributeSettings->GetMaxn_BAISC_DP();
 }
 
-void AFIMCharacter::GethManaValues(float& Mana, float& MaxMana)
+void AFIMCharacter::Getn_LVValues(float& n_LV, float& Maxn_LV)
 {
-	Mana = AttributeSettings->GetMana();
-	MaxMana = AttributeSettings->GetMaxMana();
+	n_LV = AttributeSettings->Getn_LV();
+	Maxn_LV = AttributeSettings->GetMaxn_LV();
 }
 
-void AFIMCharacter::GetStaminaValues(float& Stamina, float& MaxStamina)
+void AFIMCharacter::Getn_EXPValues(float& n_EXP, float& Maxn_EXP)
 {
-	Stamina = AttributeSettings->GetStamina();
-	MaxStamina = AttributeSettings->GetMaxStamina();
+	n_EXP = AttributeSettings->Getn_EXP();
+	Maxn_EXP = AttributeSettings->GetMaxn_EXP();
 }
 
-void AFIMCharacter::GetAttackPowerValues(float& AttackPower, float& MaxAttackPower)
+void AFIMCharacter::Getn_BAISC_DATKValues(float& n_BAISC_DATK, float& Maxn_BAISC_DATK)
 {
-	AttackPower = AttributeSettings->GetAttackPower();
-	AttackPower = AttributeSettings->GetMaxAttackPower();
+	n_BAISC_DATK = AttributeSettings->Getn_BAISC_DATK();
+	Maxn_BAISC_DATK = AttributeSettings->GetMaxn_BAISC_DATK();
 }
 
-void AFIMCharacter::OnHealthChangedNative(const FOnAttributeChangeData& Data)
+void AFIMCharacter::Getn_BAISC_DDEFValues(float& n_BAISC_DDEF, float& Maxn_BAISC_DDEF)
 {
-	OnHealthChanged(Data.OldValue, Data.NewValue);
+	n_BAISC_DDEF = AttributeSettings->Getn_BAISC_DDEF();
+	Maxn_BAISC_DDEF = AttributeSettings->GetMaxn_BAISC_DDEF();
+}
+
+void AFIMCharacter::Getn_BAISC_MOVE_SPEEDValues(float& n_BAISC_MOVE_SPEED, float& Maxn_BAISC_MOVE_SPEED)
+{
+	n_BAISC_MOVE_SPEED = AttributeSettings->Getn_BAISC_MOVE_SPEED();
+	Maxn_BAISC_MOVE_SPEED = AttributeSettings->GetMaxn_BAISC_MOVE_SPEED();
+}
+
+void AFIMCharacter::Getn_BAISC_ATTACK_SPEEDValues(float& n_BAISC_ATTACK_SPEED, float& Maxn_BAISC_ATTACK_SPEED)
+{
+	n_BAISC_ATTACK_SPEED = AttributeSettings->Getn_BAISC_ATTACK_SPEED();
+	Maxn_BAISC_ATTACK_SPEED = AttributeSettings->GetMaxn_BAISC_ATTACK_SPEED();
+}
+
+void AFIMCharacter::Getn_CRIValues(float& n_CRI, float& Maxn_CRI)
+{
+	n_CRI = AttributeSettings->Getn_CRI();
+	Maxn_CRI = AttributeSettings->GetMaxn_CRI();
+}
+
+void AFIMCharacter::Getn_CRI_PROPORTIONValues(float& n_CRI_PROPORTION, float& Maxn_CRI_PROPORTION)
+{
+	n_CRI_PROPORTION = AttributeSettings->Getn_CRI_PROPORTION();
+	Maxn_CRI_PROPORTION = AttributeSettings->GetMaxn_CRI_PROPORTION();
+}
+
+void AFIMCharacter::DevourEvent_Implementation()
+{
+}
+
+void AFIMCharacter::Onn_BASIC_HPChangedNative(const FOnAttributeChangeData& Data)
+{
+	Onn_BASIC_HPChanged(Data.OldValue, Data.NewValue);
 	if (Data.OldValue <= 0.0f && !bIsDead)
 	{
 		Dead();
 		bIsDead = true;
 		BP_Die();
 	}
+
+	if (Data.NewValue <= CurrentMaximonn_BASIC_HP * 0.5 && !IsDevour)
+	{
+		DevourEvent();
+		IsDevour = true;
+		CurrentMaximonn_BASIC_HP = Data.NewValue;
+	}
 }
 
-void AFIMCharacter::OnManaChangedNative(const FOnAttributeChangeData& Data)
+void AFIMCharacter::Devour_Implementation()
 {
-	OnManaChanged(Data.OldValue, Data.NewValue);
 }
 
-void AFIMCharacter::OnStaminaChangedNative(const FOnAttributeChangeData& Data)
+void AFIMCharacter::Onn_BASIC_MPChangedNative(const FOnAttributeChangeData& Data)
 {
-	OnStaminaChanged(Data.OldValue, Data.NewValue);
+	Onn_BASIC_MPChanged(Data.OldValue, Data.NewValue);
 }
 
-void AFIMCharacter::OnAttackPowerChangedNative(const FOnAttributeChangeData& Data)
+void AFIMCharacter::Onn_BASIC_SPChangedNative(const FOnAttributeChangeData& Data)
 {
-	OnAttackPowerChanged(Data.OldValue, Data.NewValue);
+	Onn_BASIC_SPChanged(Data.OldValue, Data.NewValue);
+}
+
+void AFIMCharacter::Onn_BAISC_DPChangedNative(const FOnAttributeChangeData& Data)
+{
+	Onn_BAISC_DPChanged(Data.OldValue, Data.NewValue);
+}
+
+void AFIMCharacter::Onn_LVChangedNative(const FOnAttributeChangeData& Data)
+{
+	Onn_LVChanged(Data.OldValue, Data.NewValue);
+}
+
+void AFIMCharacter::Onn_EXPChangedNative(const FOnAttributeChangeData& Data)
+{
+	Onn_EXPChanged(Data.OldValue, Data.NewValue);
+}
+
+void AFIMCharacter::Onn_BAISC_DATKChangedNative(const FOnAttributeChangeData& Data)
+{
+	Onn_BAISC_DATKChanged(Data.OldValue, Data.NewValue);
+}
+
+void AFIMCharacter::Onn_BAISC_DDEFChangedNative(const FOnAttributeChangeData& Data)
+{
+	Onn_BAISC_DDEFChanged(Data.OldValue, Data.NewValue);
+}
+
+void AFIMCharacter::Onn_BAISC_MOVE_SPEEDChangedNative(const FOnAttributeChangeData& Data)
+{
+	Onn_BAISC_MOVE_SPEEDChanged(Data.OldValue, Data.NewValue);
+}
+
+void AFIMCharacter::Onn_BAISC_ATTACK_SPEEDChangedNative(const FOnAttributeChangeData& Data)
+{
+	Onn_BAISC_ATTACK_SPEEDChanged(Data.OldValue, Data.NewValue);
+}
+
+void AFIMCharacter::Onn_CRIChangedNative(const FOnAttributeChangeData& Data)
+{
+	Onn_CRIChanged(Data.OldValue, Data.NewValue);
+}
+
+void AFIMCharacter::Onn_CRI_PROPORTIONChangedNative(const FOnAttributeChangeData& Data)
+{
+	Onn_CRI_PROPORTIONChanged(Data.OldValue, Data.NewValue);
+}
+
+void AFIMCharacter::BP_Die_Implementation()
+{
+	bIsDead = true;
 }
 
 void AFIMCharacter::StartReversingTime()
@@ -726,4 +862,3 @@
 	IsReverseTime = false;
 	PlayMontageRate = 1.0f;
 }
-
Index: Plugins/Developer/RiderLink/Source/RD/thirdparty/string-view-lite/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># string_view lite: A single-file header-only version of a C++17-like string_view for C++98, C++11 and later\r\n\r\n[![Language](https://img.shields.io/badge/C%2B%2B-98/11/14/17-blue.svg)](https://en.wikipedia.org/wiki/C%2B%2B#Standardization) [![License](https://img.shields.io/badge/license-BSL-blue.svg)](https://opensource.org/licenses/BSL-1.0) [![Build Status](https://travis-ci.org/martinmoene/string-view-lite.svg?branch=master)](https://travis-ci.org/martinmoene/string-view-lite) [![Build status](https://ci.appveyor.com/api/projects/status/1ha3wnxtam547m8p?svg=true)](https://ci.appveyor.com/project/martinmoene/string-view-lite) [![Version](https://badge.fury.io/gh/martinmoene%2Fstring-view-lite.svg)](https://github.com/martinmoene/string-view-lite/releases) [![download](https://img.shields.io/badge/latest-download-blue.svg)](https://github.com/martinmoene/string-view-lite/blob/master/include/nonstd/string_view.hpp) [![Conan](https://img.shields.io/badge/on-conan-blue.svg)](https://bintray.com/agauniyal/nonstd-lite/) [![Try it on wandbox](https://img.shields.io/badge/on-wandbox-blue.svg)](https://wandbox.org/permlink/w2vUu56NVdVNyOiv) [![Try it on godbolt online](https://img.shields.io/badge/on-godbolt-blue.svg)](http://bit.ly/mm-string-view-lite-godbolt)\r\n\r\n**Contents**  \r\n- [Example usage](#example-usage)\r\n- [In a nutshell](#in-a-nutshell)\r\n- [License](#license)\r\n- [Dependencies](#dependencies)\r\n- [Installation](#installation)\r\n- [Synopsis](#synopsis)\r\n- [Reported to work with](#reported-to-work-with)\r\n- [Building the tests](#building-the-tests)\r\n- [Other implementations of string_view](#other-implementations-of-string_view)\r\n- [Notes and references](#notes-and-references)\r\n- [Appendix](#appendix)\r\n\r\n\r\nExample usage\r\n-------------\r\n\r\n```C++\r\n#include \"nonstd/string_view.hpp\"\r\n#include <iostream>\r\n\r\nusing namespace std::literals;\r\nusing namespace nonstd::literals;\r\nusing namespace nonstd;\r\n    \r\nvoid write( string_view sv )\r\n{\r\n    std::cout << sv;\r\n}\r\n\r\nint main()\r\n{\r\n    write( \"hello\"     );   // C-string\r\n    write( \", \"s       );   // std::string\r\n    write( \"world!\"_sv );   // nonstd::string_view\r\n}\r\n```\r\n\r\n### Compile and run\r\n```\r\nprompt> g++ -Wall -std=c++14 -I../include/ -o 01-basic.exe 01-basic.cpp && 01-basic.exe\r\nhello, world!\r\n```\r\n\r\nIn a nutshell\r\n---------------\r\n**string-view lite** is a single-file header-only library to provide a non-owning reference to a string. The library provides a [C++17-like string_view](http://en.cppreference.com/w/cpp/string/basic_string_view) for use with C++98 and later. If available, `std::string_view` is used, unless [configured otherwise](#configuration).\r\n\r\n**Features and properties of string-view lite** are ease of installation (single header), freedom of dependencies other than the standard library. To mimic C++17-like cooperation with `std::string`, `nonstd::string_view` provides several non-standard conversion functions. These functions may be [omitted via configuration](#configuration).\r\n\r\n\r\nLicense\r\n-------\r\n*string-view lite* is distributed under the [Boost Software License](LICENSE.txt).\r\n \r\n\r\nDependencies\r\n------------\r\n*string-view lite* has no other dependencies than the [C++ standard library](http://en.cppreference.com/w/cpp/header).\r\n\r\n\r\nInstallation\r\n------------\r\n\r\n*string-view lite* is a single-file header-only library. Put `string_view.hpp` in the [include](include) folder directly into the project source tree or somewhere reachable from your project.\r\n\r\nOr, if you use the [conan package manager](https://www.conan.io/), follow these steps:\r\n\r\n1. Add *nonstd-lite* to the conan remotes:\r\n\r\n        conan remote add nonstd-lite https://api.bintray.com/conan/martinmoene/nonstd-lite\r\n\r\n2. Add a reference to *string-view-lite* to the *requires* section of your project's `conanfile.txt` file:\r\n\r\n        [requires]\r\n        string-view-lite/[~=1]@nonstd-lite/testing\r\n\r\n3. Run conan's install command:\r\n\r\n        conan install\r\n\r\n\r\nSynopsis\r\n--------\r\n\r\n**Contents**  \r\n[Documentation of `std::string_view`](#stdstring_view)  \r\n[C++20 extensions](#c20-extensions)  \r\n[Non-standard extensions](#non-standard-extensions)  \r\n[Configuration](#configuration)    \r\n\r\nDocumentation of `std::string_view`\r\n-----------------------------------\r\nDepending on the compiler and C++-standard used, `nonstd::string_view` behaves less or more like `std::string_view`. To get an idea of the capabilities of `nonstd::string_view` with your configuration, look at the output of the [tests](test/string_view.t.cpp), issuing `string-view-lite.t --pass @`. For `std::string_view`, see its [documentation at cppreference](http://en.cppreference.com/w/cpp/string/basic_string_view).  \r\n\r\nC++20 extensions\r\n----------------\r\n*string_view-lite* provides the following C++20 *extensions*.\r\n\r\n- *[[nodiscard]]* constexpr bool **empty**() const noexcept;\r\n- constexpr bool ***starts_with***( basic_string_view v ) const noexcept;  // (1)\r\n- constexpr bool ***starts_with***( CharT c ) const noexcept;  // (2)\r\n- constexpr bool ***starts_with***( CharT const * s ) const;  // (3)\r\n- constexpr bool ***ends_with***( basic_string_view v ) const noexcept;  // (1)\r\n- constexpr bool ***ends_with***( CharT c ) const noexcept;  // (2)\r\n- constexpr bool ***ends_with***( CharT const * s ) const;  // (3)\r\n\r\nNote: [[nodiscard]], constexpr and noexcept if available.\r\n     \r\nNon-standard extensions\r\n-----------------------\r\n### `string_view` literals `sv` and `_sv`\r\nclang compilers do not allow to write `auto sv = \"...\"sv` with *string-view lite* under C++11. To still provide a literal operator that can be used in that case, *string-view lite* also provides `_sv`. See section [Configuration](#configuration) for how to control the presence of these operators.\r\n\r\nThe literal operators are declared in the namespace `nonstd::literals::string_view_literals`, where both `literals` and `string_view_literals` are inline namespaces, if supported. Access to these operators can be gained with using namespace `nonstd::literals`, using namespace `nonstd::string_view_literals`, and using namespace `nonstd::literals::string_view_literals`. If inline namespaces are not supported by the compiler, only the latter form is available.\r\n\r\n### Cooperation between `std::string` and `nonstd::string_view`\r\n*string-view lite* can provide several methods and free functions to mimic the cooperation between `std::string` and  `nonstd::string_view` that exists in C++17. See the table below. Several macros allow you to control the presence of these functions, see section [Configuration](#configuration).\r\n\r\n| Kind                  | Std   | Function or method |                                       \r\n|-----------------------|-------|--------------------|\r\n| **Free functions**    |&nbsp; | macro `nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS`|\r\n| **`std::string_view`**|&nbsp; | &nbsp; |\r\n| to_string()           |>=C++17| template&lt; class CharT, class Traits, class Allocator=std::allocator&lt;CharT> ><br>std::basic_string&lt;CharT, Traits, Allocator&gt;<br>**to_string**( std::basic_string_view&lt;CharT, Traits> v, Allocator const & a=Allocator() );|\r\n| to_string_view()      |>=C++17| template&lt; class CharT, class Traits, class Allocator ><br>std::basic_string_view&lt;CharT, Traits><br>**to_string_view**( std::basic_string&lt;CharT, Traits, Allocator> const & s );|\r\n| **`nonstd::string_view`**|&nbsp; | &nbsp;  |\r\n| to_string()<br>&nbsp;<br>*non-msvc14 (vs2015)* |>=C++11| template&lt; class CharT, class Traits, class Allocator = std::allocator&lt;CharT> ><br>std::basic_string&lt;CharT, Traits, Allocator><br>**to_string**( basic_string_view&lt;CharT, Traits> v, Allocator const & a = Allocator() );|\r\n| to_string()<br>&nbsp;<br>*msvc14 (vs2015)* |<C++11|template&lt; class CharT, class Traits ><br>std::basic_string&lt;CharT, Traits><br>**to_string**( basic_string_view&lt;CharT, Traits> v );|\r\n| to_string()<br>&nbsp;<br>*msvc14 (vs2015)* |<C++11|template&lt; class CharT, class Traits, class Allocator ><br>std::basic_string&lt;CharT, Traits, Allocator><br>**to_string**( basic_string_view&lt;CharT, Traits> v, Allocator const & a );|\r\n| to_string_view()      |>=C++98| template&lt; class CharT, class Traits, class Allocator ><br>basic_string_view&lt;CharT, Traits><br>**to_string_view**( std::basic_string&lt;CharT, Traits, Allocator> const & s );|\r\n| &nbsp;                |&nbsp; | &nbsp; |\r\n| **Class methods**     |&nbsp; | macro `nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS` |\r\n| **`nonstd::basic_string_view`**|&nbsp; |&nbsp; |\r\n| Constructor           |>=C++98| template&lt; class Allocator ><br>**basic_string_view**( std::basic_string&lt;CharT, Traits, Allocator> const & s ) nssv_noexcept;|\r\n| Converting operator   |>=C++11| template&lt; class Allocator ><br>explicit **operator std::basic_string**&lt;CharT, Traits, Allocator>() const;|\r\n| to_string()           |>=C++11| template&lt; class Allocator = std::allocator&lt;CharT> ><br>std::basic_string&lt;CharT, Traits, Allocator><br>**to_string**( Allocator const & a = Allocator() ) const;|\r\n| to_string()           |<C++11 | std::basic_string&lt;CharT, Traits><br>**to_string**() const;|\r\n| to_string()           |<C++11 | template&lt; class Allocator ><br>std::basic_string&lt;CharT, Traits, Allocator><br>**to_string**( Allocator const & a ) const;|\r\n| &nbsp;                |&nbsp; | &nbsp; |\r\n| **Literal operator `sv`**|>=C++11| macro `nssv_CONFIG_STD_SV_OPERATOR` |\r\n| &nbsp;                |&nbsp; | constexpr string_view operator \"\" **sv**( const char* str, size_t len ) noexcept; |\r\n| &nbsp;                |&nbsp; | constexpr u16string_view operator \"\" **sv**( const char16_t* str, size_t len ) noexcept; |\r\n| &nbsp;                |&nbsp; | constexpr u32string_view operator \"\" **sv**( const char32_t* str, size_t len ) noexcept; |\r\n| &nbsp;                |&nbsp; | constexpr wstring_view operator \"\" **sv**( const wchar_t* str, size_t len ) noexcept; |\r\n| &nbsp;                |&nbsp; | &nbsp; |\r\n| **Literal operator `_sv`**|>=C++11| macro `nssv_CONFIG_USR_SV_OPERATOR` |\r\n| &nbsp;                |&nbsp; | constexpr string_view operator \"\" **_sv**( const char* str, size_t len ) noexcept; |\r\n| &nbsp;                |&nbsp; | constexpr u16string_view operator \"\" **_sv**( const char16_t* str, size_t len ) noexcept; |\r\n| &nbsp;                |&nbsp; | constexpr u32string_view operator \"\" **_sv**( const char32_t* str, size_t len ) noexcept; |\r\n| &nbsp;                |&nbsp; | constexpr wstring_view operator \"\" **_sv**( const wchar_t* str, size_t len ) noexcept; |\r\n\r\n\r\nConfiguration\r\n-------------\r\n\r\n### Standard selection macro\r\n\r\n\\-D<b>nssv\\_CPLUSPLUS</b>=199711L  \r\nDefine this macro to override the auto-detection of the supported C++ standard, if your compiler does not set the `__cpluplus` macro correctly.\r\n\r\n### Select `std::string_view` or `nonstd::string_view`\r\nAt default, *string-view lite* uses `std::string_view` if it is available and lets you use it via namespace `nonstd`. You can however override this default and explicitly request to use `std::string_view` as `nonstd::string_view` or use string-view lite's `nonstd::string_view` via the following macros.\r\n\r\n-D<b>nssv\\_CONFIG\\_SELECT\\_STRING_VIEW</b>=nssv_STRING_VIEW_DEFAULT  \r\nDefine this to `nssv_STRING_VIEW_STD` to select `std::string_view` as `nonstd::string_view`. Define this to `nssv_STRING_VIEW_NONSTD` to select `nonstd::string_view` as `nonstd::string_view`. Default is undefined, which has the same effect as defining to `nssv_STRING_VIEW_DEFAULT`.\r\n\r\nNote: <b>nssv_CONFIG_SELECT_STD_STRING_VIEW</b> and <b>nssv_CONFIG_SELECT_NONSTD_STRING_VIEW</b> are deprecated and have been removed.\r\n\r\n### Disable exceptions\r\n-D<b>nssv\\_CONFIG\\_NO\\_EXCEPTIONS</b>=0\r\nDefine this to 1 if you want to compile without exceptions. If not defined, the header tries and detect if exceptions have been disabled (e.g. via `-fno-exceptions`). Default is undefined.\r\n\r\n### Add or omit literal operators `sv` and `_sv`\r\n\r\n-D<b>nssv_CONFIG_STD_SV_OPERATOR</b>=1  \r\nDefine this to 1 to provide literal operator `sv` to create a `string_view` from a literal string. Default is 0. Note that literal operators without leading underscore are reserved for the C++ standard.\r\n\r\n-D<b>nssv_CONFIG_USR_SV_OPERATOR</b>=0  \r\nDefine this to 0 to omit literal operator `_sv` to create a `string_view` from a literal string. Default is 1.\r\n\r\n### Omit cooperation between `std::string`&ndash;`nonstd::string_view`\r\nAt default, *string-view lite* provides several methods and free functions to mimic the cooperation between `std::string` and  `nonstd::string_view` (or `std::string_view`) that exists in C++17. See section [Non-standard extensions](#non-standard-extensions). The following macros allow you to control the presence of these functions.\r\n \r\n-D<b>nssv_CONFIG_CONVERSION_STD_STRING</b>=1  \r\nDefine this to 1 to provide `std::string`&ndash; `nonstd::string_view` interoperability via methods of `nonstd::basic_string_view` and free functions, define it to 0 to omit all said methods and functions. Default is undefined.\r\n\r\n-D<b>nssv_CONFIG_CONVERSION_STD_STRING_CLASS_METHODS</b>=1  \r\nDefine this to 1 to provide `std::string`&ndash; `nonstd::string_view` interoperability via methods of `nonstd::basic_string_view`, define it to 0 to omit all said methods. Default is undefined.\r\n\r\n-D<b>nssv_CONFIG_CONVERSION_STD_STRING_FREE_FUNCTIONS</b>=1  \r\nDefine this to 1 to provide `std::string`&ndash; `nonstd::string_view` interoperability via free functions, define it to 0 to omit all said functions. This also controls the presence of these function if `std::string_view` is used. Default is undefined.\r\n\r\n\r\nReported to work with\r\n---------------------\r\nThe table below mentions the compiler versions *string-view lite* is reported to work with.\r\n\r\nOS        | Compiler   | Versions |\r\n---------:|:-----------|:---------|\r\nWindows   | Clang/LLVM | ?        |\r\n&nbsp;    | GCC        | 7.2.0    |\r\n&nbsp;    | Visual C++<br>(Visual Studio)| 8 (2005), 9 (2008), 10 (2010), 11 (2012),<br>12 (2013), 14 (2015), 15 (2017) |\r\nGNU/Linux | Clang/LLVM | 3.5 - 6.0  |\r\n&nbsp;    | GCC        | 4.8 - 8 |\r\nOS X      | Clang/LLVM | Xcode 6, Xcode 7, Xcode 8, Xcode 9 |\r\n\r\n\r\nBuilding the tests\r\n------------------\r\nTo build the tests you need:\r\n\r\n- [CMake](http://cmake.org), version 3.0 or later to be installed and in your PATH.\r\n- A [suitable compiler](#reported-to-work-with).\r\n\r\nThe [*lest* test framework](https://github.com/martinmoene/lest) is included in the [test folder](test).\r\n\r\nThe following steps assume that the [*string-view lite* source code](https://github.com/martinmoene/string-view-lite) has been cloned into a directory named `c:\\string-view-lite`.\r\n\r\n1. Create a directory for the build outputs for a particular architecture.\r\nHere we use c:\\string-view-lite\\build-win-x86-vc10.\r\n\r\n        cd c:\\string-view-lite\r\n        md build-win-x86-vc10\r\n        cd build-win-x86-vc10\r\n\r\n2. Configure CMake to use the compiler of your choice (run `cmake --help` for a list).\r\n\r\n        cmake -G \"Visual Studio 10 2010\" -DSTRINGVIEW_LITE_OPT_BUILD_TESTS=ON ..\r\n\r\n3. Build the test suite in the Debug configuration (alternatively use Release).    \r\n\r\n        cmake --build . --config Debug\r\n\r\n4. Run the test suite.    \r\n\r\n        ctest -V -C Debug\r\n\r\nAll tests should pass, indicating your platform is supported and you are ready to use *string-view lite*.\r\n\r\n\r\nOther implementations of string_view\r\n------------------------------------\r\n- Marshall Clow. [string_view implementation for libc++](https://github.com/mclow/string_view). GitHub.\r\n- LLVM libc++. [string_view](https://llvm.org/svn/llvm-project/libcxx/trunk/include/string_view). GitHub.\r\n- Matthew Rodusek's, @bitwizeshift. [string_view Standalone](https://github.com/bitwizeshift/string_view-standalone). GitHub.\r\n- @satoren. [string_view for C++03 C++11 C++14](https://github.com/satoren/string_view). GitHub.\r\n- Google Abseil [string_view](https://github.com/abseil/abseil-cpp/tree/master/absl/strings) (non-templated).\r\n- [Search _string view c++_ on GitHub](https://github.com/search?l=C%2B%2B&q=string+view+c%2B%2B&type=Repositories&utf8=%E2%9C%93).\r\n\r\n\r\nNotes and references\r\n--------------------\r\n*Interface and specification*\r\n- [string_view on cppreference](http://en.cppreference.com/w/cpp/string/basic_string_view).\r\n- [n4659 - C++17 Working Draft: string_view](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf#page=780).\r\n\r\n*Presentations*\r\n- Marshall Clow. [string_view - when to use it, and when not](https://cppcon2015.sched.com/event/3vch/stringview-when-to-use-it-and-when-not?iframe=yes&w=700&sidebar=yes&bg=no#). CppCon 2015. [video](https://youtu.be/H9gAaNRoon4), [slides](https://github.com/CppCon/CppCon2015/blob/master/Presentations/string_view/string_view%20-%20Marshall%20Clow%20-%20CppCon%202015.pdf).\r\n- Neil MacIntosh. [A few good types: Evolving array_view and string_view for safe C++ code](https://cppcon2015.sched.com/event/3vbQ/a-few-good-types-evolving-arrayview-and-stringview-for-safe-c-code). CppCon 2015. [video](https://youtu.be/C4Z3c4Sv52U), [slides](https://github.com/CppCon/CppCon2015/blob/master/Presentations/A%20Few%20Good%20Types/A%20Few%20Good%20Types%20-%20Neil%20MacIntosh%20-%20CppCon%202015.pdf).\r\n\r\n*Proposals*\r\n- Jeffrey Yasskin. [n3334 - Proposing array_ref<T> and string_ref](https://wg21.link/n3334). 2012.\r\n- Jeffrey Yasskin. [n3921 - string_view: a non-owning reference to a string, revision 7](http://wg21.link/n3921). **Adopted 2014-02**.\r\n- Alisdair Meredith. [n4288 - Strike string_view::clear from Library Fundamentals](http://wg21.link/n4288). **Adopted 2014-11**.\r\n- Neil MacIntosh. [p0123 - Unifying the interfaces of string_view and array_view](http://wg21.link/p0123). 2015.\r\n- Beman Dawes, Alisdair Meredith. [p0220 - Adopt Library Fundamentals V1 TS Components for C++17 (R1)](https://wg21.link/p0220r1). 2016.\r\n- Marshall Clow. [p0254 - Integrating std::string_view and std::string](http://wg21.link/p0254). **Adopted 2016-06**.\r\n- Nicolai Josuttis. [p0392 - Adapting string_view by filesystem paths](https://wg21.link/p0392r0). 2016.\r\n- Marshall Clow. [p0403 - Literal suffixes for basic_string_view](http://wg21.link/p0403). 2016.\r\n- Peter Sommerlad. [p0506 - use string_view for library function parameters instead of const string &/const char *](http://wg21.link/p0506). 2017.\r\n- Daniel Krugler. [wg2946 - LWG 2758's resolution missed further corrections](https://wg21.link/lwg2946). 2017.\r\n\r\n\r\nAppendix\r\n--------\r\n\r\n### A.1 Compile-time information\r\n\r\nThe version of *string-view lite* is available via tag `[.version]`. The following tags are available for information on the compiler and on the C++ standard library used: `[.compiler]`, `[.stdc++]`, `[.stdlanguage]` and `[.stdlibrary]`.\r\n\r\n### A.2 string-view lite test specification\r\n\r\n```\r\nstring_view: Allows to default construct an empty string_view\r\nstring_view: Allows to construct from pointer and size\r\nstring_view: Allows to construct from C-string\r\nstring_view: Allows to copy-construct from empty string_view\r\nstring_view: Allows to copy-construct from non-empty string_view\r\nstring_view: Allows to copy-assign from empty string_view\r\nstring_view: Allows to copy-assign from non-empty string_view\r\nstring_view: Allows forward iteration\r\nstring_view: Allows const forward iteration\r\nstring_view: Allows reverse iteration\r\nstring_view: Allows const reverse iteration\r\nstring_view: Allows to obtain the size of the view via size()\r\nstring_view: Allows to obtain the size of the view via length()\r\nstring_view: Allows to obtain the maximum size a view can be via max_size()\r\nstring_view: Allows to check for an empty string_view via empty()\r\nstring_view: Allows to observe an element via array indexing\r\nstring_view: Allows to observe an element via at()\r\nstring_view: Throws at observing an element via at() with an index of size() or larger\r\nstring_view: Allows to observe elements via data()\r\nstring_view: Yields nullptr (or NULL) with data() for an empty string_view\r\nstring_view: Allows to remove a prefix of n elements\r\nstring_view: Allows to remove a suffix of n elements\r\nstring_view: Allows to swap with other string_view\r\nstring_view: Allows to copy a substring of length n, starting at position pos (default: 0) via copy()\r\nstring_view: Throws if requested position of copy() exceeds string_view's size()\r\nstring_view: Allow to obtain a sub string, starting at position pos (default: 0) and of length n (default full), via substr()\r\nstring_view: Throws if requested position of substr() exceeds string_view's size()\r\nstring_view: Allows to lexically compare to another string_view via compare(), (1)\r\nstring_view: Allows to compare empty string_views as equal via compare(), (1)\r\nstring_view: Allows to compare a sub string to another string_view via compare(), (2)\r\nstring_view: Allows to compare a sub string to another string_view sub string via compare(), (3)\r\nstring_view: Allows to compare to a C-string via compare(), (4)\r\nstring_view: Allows to compare a sub string to a C-string via compare(), (5)\r\nstring_view: Allows to compare a sub string to a C-string prefix via compare(), (6)\r\nstring_view: Allows to check for a prefix string_view via starts_with(), (1)\r\nstring_view: Allows to check for a prefix character via starts_with(), (2)\r\nstring_view: Allows to check for a prefix C-string via starts_with(), (3)\r\nstring_view: Allows to check for a suffix string_view via ends_with(), (1)\r\nstring_view: Allows to check for a suffix character via ends_with(), (2)\r\nstring_view: Allows to check for a suffix C-string via ends_with(), (3)\r\nstring_view: Allows to search for a string_view substring, starting at position pos (default: 0) via find(), (1)\r\nstring_view: Allows to search for a character, starting at position pos (default: 0) via find(), (2)\r\nstring_view: Allows to search for a C-string substring, starting at position pos and of length n via find(), (3)\r\nstring_view: Allows to search for a C-string substring, starting at position pos (default: 0) via find(), (4)\r\nstring_view: Allows to search backwards for a string_view substring, starting at position pos (default: npos) via rfind(), (1)\r\nstring_view: Allows to search backwards for a character, starting at position pos (default: npos) via rfind(), (2)\r\nstring_view: Allows to search backwards for a C-string substring, starting at position pos and of length n via rfind(), (3)\r\nstring_view: Allows to search backwards for a C-string substring, starting at position pos (default: 0) via rfind(), (4)\r\nstring_view: Allows to search for the first occurrence of any of the characters specified in a string view, starting at position pos (default: 0) via find_first_of(), (1)\r\nstring_view: Allows to search for a character, starting at position pos (default: 0) via find_first_of(), (2)\r\nstring_view: Allows to search for the first occurrence of any of the characters specified in a C-string, starting at position pos and of length n via find_first_of(), (3)\r\nstring_view: Allows to search for the first occurrence of any of the characters specified in a C-string, starting at position pos via find_first_of(), (4)\r\nstring_view: Allows to search backwards for the last occurrence of any of the characters specified in a string view, starting at position pos (default: npos) via find_last_of(), (1)\r\nstring_view: Allows to search backwards for a character, starting at position pos (default: 0) via find_last_of(), (2)\r\nstring_view: Allows to search backwards for the first occurrence of any of the characters specified in a C-string, starting at position pos and of length n via find_last_of(), (3)\r\nstring_view: Allows to search backwards for the first occurrence of any of the characters specified in a C-string, starting at position pos via find_last_of(), (4)\r\nstring_view: Allows to search for the first character not specified in a string view, starting at position pos (default: 0) via find_first_not_of(), (1)\r\nstring_view: Allows to search for the first character not equal to the specified character, starting at position pos (default: 0) via find_first_not_of(), (2)\r\nstring_view: Allows to search for  the first character not equal to any of the characters specified in a C-string, starting at position pos and of length n via find_first_not_of(), (3)\r\nstring_view: Allows to search for  the first character not equal to any of the characters specified in a C-string, starting at position pos via find_first_not_of(), (4)\r\nstring_view: Allows to search backwards for the first character not specified in a string view, starting at position pos (default: npos) via find_last_not_of(), (1)\r\nstring_view: Allows to search backwards for the first character not equal to the specified character, starting at position pos (default: npos) via find_last_not_of(), (2)\r\nstring_view: Allows to search backwards for  the first character not equal to any of the characters specified in a C-string, starting at position pos and of length n via find_last_not_of(), (3)\r\nstring_view: Allows to search backwards for  the first character not equal to any of the characters specified in a C-string, starting at position pos via find_last_not_of(), (4)\r\nstring_view: Allows to create a string_view, wstring_view, u16string_view, u32string_view via literal \"sv\"\r\nstring_view: Allows to create a string_view via literal \"sv\", using namespace nonstd::literals::string_view_literals\r\nstring_view: Allows to create a string_view via literal \"sv\", using namespace nonstd::string_view_literals\r\nstring_view: Allows to create a string_view via literal \"sv\", using namespace nonstd::literals\r\nstring_view: Allows to create a string_view, wstring_view, u16string_view, u32string_view via literal \"_sv\"\r\nstring_view: Allows to create a string_view via literal \"_sv\", using namespace nonstd::literals::string_view_literals\r\nstring_view: Allows to create a string_view via literal \"_sv\", using namespace nonstd::string_view_literals\r\nstring_view: Allows to create a string_view via literal \"_sv\", using namespace nonstd::literals\r\nstring_view: Allows to compare a string_view with another string_view\r\nstring_view: Allows to compare empty string_view-s as equal\r\noperator<<: Allows printing a string_view to an output stream\r\nstd::hash<>: Hash value of string_view equals hash value of corresponding string object\r\nstd::hash<>: Hash value of wstring_view equals hash value of corresponding string object\r\nstd::hash<>: Hash value of u16string_view equals hash value of corresponding string object\r\nstd::hash<>: Hash value of u32string_view equals hash value of corresponding string object\r\nstring_view: construct from std::string [extension]\r\nstring_view: convert to std::string via explicit operator [extension]\r\nstring_view: convert to std::string via to_string() [extension]\r\nto_string(): convert to std::string via to_string() [extension]\r\nto_string_view(): convert from std::string via to_string_view() [extension]\r\n```\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RD/thirdparty/string-view-lite/README.md b/Plugins/Developer/RiderLink/Source/RD/thirdparty/string-view-lite/README.md
--- a/Plugins/Developer/RiderLink/Source/RD/thirdparty/string-view-lite/README.md	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RD/thirdparty/string-view-lite/README.md	(date 1720720014654)
@@ -68,7 +68,7 @@
 
 *string-view lite* is a single-file header-only library. Put `string_view.hpp` in the [include](include) folder directly into the project source tree or somewhere reachable from your project.
 
-Or, if you use the [conan package manager](https://www.conan.io/), follow these steps:
+Or, if you use the [conan package n_BASIC_MPger](https://www.conan.io/), follow these steps:
 
 1. Add *nonstd-lite* to the conan remotes:
 
Index: Plugins/Developer/RiderLink/Source/RD/thirdparty/CTPL/LICENSE
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Apache License\r\n                           Version 2.0, January 2004\r\n                        http://www.apache.org/licenses/\r\n\r\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\r\n\r\n   1. Definitions.\r\n\r\n      \"License\" shall mean the terms and conditions for use, reproduction,\r\n      and distribution as defined by Sections 1 through 9 of this document.\r\n\r\n      \"Licensor\" shall mean the copyright owner or entity authorized by\r\n      the copyright owner that is granting the License.\r\n\r\n      \"Legal Entity\" shall mean the union of the acting entity and all\r\n      other entities that control, are controlled by, or are under common\r\n      control with that entity. For the purposes of this definition,\r\n      \"control\" means (i) the power, direct or indirect, to cause the\r\n      direction or management of such entity, whether by contract or\r\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\r\n      outstanding shares, or (iii) beneficial ownership of such entity.\r\n\r\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\r\n      exercising permissions granted by this License.\r\n\r\n      \"Source\" form shall mean the preferred form for making modifications,\r\n      including but not limited to software source code, documentation\r\n      source, and configuration files.\r\n\r\n      \"Object\" form shall mean any form resulting from mechanical\r\n      transformation or translation of a Source form, including but\r\n      not limited to compiled object code, generated documentation,\r\n      and conversions to other media types.\r\n\r\n      \"Work\" shall mean the work of authorship, whether in Source or\r\n      Object form, made available under the License, as indicated by a\r\n      copyright notice that is included in or attached to the work\r\n      (an example is provided in the Appendix below).\r\n\r\n      \"Derivative Works\" shall mean any work, whether in Source or Object\r\n      form, that is based on (or derived from) the Work and for which the\r\n      editorial revisions, annotations, elaborations, or other modifications\r\n      represent, as a whole, an original work of authorship. For the purposes\r\n      of this License, Derivative Works shall not include works that remain\r\n      separable from, or merely link (or bind by name) to the interfaces of,\r\n      the Work and Derivative Works thereof.\r\n\r\n      \"Contribution\" shall mean any work of authorship, including\r\n      the original version of the Work and any modifications or additions\r\n      to that Work or Derivative Works thereof, that is intentionally\r\n      submitted to Licensor for inclusion in the Work by the copyright owner\r\n      or by an individual or Legal Entity authorized to submit on behalf of\r\n      the copyright owner. For the purposes of this definition, \"submitted\"\r\n      means any form of electronic, verbal, or written communication sent\r\n      to the Licensor or its representatives, including but not limited to\r\n      communication on electronic mailing lists, source code control systems,\r\n      and issue tracking systems that are managed by, or on behalf of, the\r\n      Licensor for the purpose of discussing and improving the Work, but\r\n      excluding communication that is conspicuously marked or otherwise\r\n      designated in writing by the copyright owner as \"Not a Contribution.\"\r\n\r\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\r\n      on behalf of whom a Contribution has been received by Licensor and\r\n      subsequently incorporated within the Work.\r\n\r\n   2. Grant of Copyright License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      copyright license to reproduce, prepare Derivative Works of,\r\n      publicly display, publicly perform, sublicense, and distribute the\r\n      Work and such Derivative Works in Source or Object form.\r\n\r\n   3. Grant of Patent License. Subject to the terms and conditions of\r\n      this License, each Contributor hereby grants to You a perpetual,\r\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\r\n      (except as stated in this section) patent license to make, have made,\r\n      use, offer to sell, sell, import, and otherwise transfer the Work,\r\n      where such license applies only to those patent claims licensable\r\n      by such Contributor that are necessarily infringed by their\r\n      Contribution(s) alone or by combination of their Contribution(s)\r\n      with the Work to which such Contribution(s) was submitted. If You\r\n      institute patent litigation against any entity (including a\r\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\r\n      or a Contribution incorporated within the Work constitutes direct\r\n      or contributory patent infringement, then any patent licenses\r\n      granted to You under this License for that Work shall terminate\r\n      as of the date such litigation is filed.\r\n\r\n   4. Redistribution. You may reproduce and distribute copies of the\r\n      Work or Derivative Works thereof in any medium, with or without\r\n      modifications, and in Source or Object form, provided that You\r\n      meet the following conditions:\r\n\r\n      (a) You must give any other recipients of the Work or\r\n          Derivative Works a copy of this License; and\r\n\r\n      (b) You must cause any modified files to carry prominent notices\r\n          stating that You changed the files; and\r\n\r\n      (c) You must retain, in the Source form of any Derivative Works\r\n          that You distribute, all copyright, patent, trademark, and\r\n          attribution notices from the Source form of the Work,\r\n          excluding those notices that do not pertain to any part of\r\n          the Derivative Works; and\r\n\r\n      (d) If the Work includes a \"NOTICE\" text file as part of its\r\n          distribution, then any Derivative Works that You distribute must\r\n          include a readable copy of the attribution notices contained\r\n          within such NOTICE file, excluding those notices that do not\r\n          pertain to any part of the Derivative Works, in at least one\r\n          of the following places: within a NOTICE text file distributed\r\n          as part of the Derivative Works; within the Source form or\r\n          documentation, if provided along with the Derivative Works; or,\r\n          within a display generated by the Derivative Works, if and\r\n          wherever such third-party notices normally appear. The contents\r\n          of the NOTICE file are for informational purposes only and\r\n          do not modify the License. You may add Your own attribution\r\n          notices within Derivative Works that You distribute, alongside\r\n          or as an addendum to the NOTICE text from the Work, provided\r\n          that such additional attribution notices cannot be construed\r\n          as modifying the License.\r\n\r\n      You may add Your own copyright statement to Your modifications and\r\n      may provide additional or different license terms and conditions\r\n      for use, reproduction, or distribution of Your modifications, or\r\n      for any such Derivative Works as a whole, provided Your use,\r\n      reproduction, and distribution of the Work otherwise complies with\r\n      the conditions stated in this License.\r\n\r\n   5. Submission of Contributions. Unless You explicitly state otherwise,\r\n      any Contribution intentionally submitted for inclusion in the Work\r\n      by You to the Licensor shall be under the terms and conditions of\r\n      this License, without any additional terms or conditions.\r\n      Notwithstanding the above, nothing herein shall supersede or modify\r\n      the terms of any separate license agreement you may have executed\r\n      with Licensor regarding such Contributions.\r\n\r\n   6. Trademarks. This License does not grant permission to use the trade\r\n      names, trademarks, service marks, or product names of the Licensor,\r\n      except as required for reasonable and customary use in describing the\r\n      origin of the Work and reproducing the content of the NOTICE file.\r\n\r\n   7. Disclaimer of Warranty. Unless required by applicable law or\r\n      agreed to in writing, Licensor provides the Work (and each\r\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\r\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\r\n      implied, including, without limitation, any warranties or conditions\r\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\r\n      PARTICULAR PURPOSE. You are solely responsible for determining the\r\n      appropriateness of using or redistributing the Work and assume any\r\n      risks associated with Your exercise of permissions under this License.\r\n\r\n   8. Limitation of Liability. In no event and under no legal theory,\r\n      whether in tort (including negligence), contract, or otherwise,\r\n      unless required by applicable law (such as deliberate and grossly\r\n      negligent acts) or agreed to in writing, shall any Contributor be\r\n      liable to You for damages, including any direct, indirect, special,\r\n      incidental, or consequential damages of any character arising as a\r\n      result of this License or out of the use or inability to use the\r\n      Work (including but not limited to damages for loss of goodwill,\r\n      work stoppage, computer failure or malfunction, or any and all\r\n      other commercial damages or losses), even if such Contributor\r\n      has been advised of the possibility of such damages.\r\n\r\n   9. Accepting Warranty or Additional Liability. While redistributing\r\n      the Work or Derivative Works thereof, You may choose to offer,\r\n      and charge a fee for, acceptance of support, warranty, indemnity,\r\n      or other liability obligations and/or rights consistent with this\r\n      License. However, in accepting such obligations, You may act only\r\n      on Your own behalf and on Your sole responsibility, not on behalf\r\n      of any other Contributor, and only if You agree to indemnify,\r\n      defend, and hold each Contributor harmless for any liability\r\n      incurred by, or claims asserted against, such Contributor by reason\r\n      of your accepting any such warranty or additional liability.\r\n\r\n   END OF TERMS AND CONDITIONS\r\n\r\n\r\n   Copyright (C) 2014 by Vitaliy Vitsentiy\r\n\r\n   Licensed under the Apache License, Version 2.0 (the \"License\");\r\n   you may not use this file except in compliance with the License.\r\n   You may obtain a copy of the License at\r\n\r\n       http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n   Unless required by applicable law or agreed to in writing, software\r\n   distributed under the License is distributed on an \"AS IS\" BASIS,\r\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n   See the License for the specific language governing permissions and\r\n   limitations under the License.\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RD/thirdparty/CTPL/LICENSE b/Plugins/Developer/RiderLink/Source/RD/thirdparty/CTPL/LICENSE
--- a/Plugins/Developer/RiderLink/Source/RD/thirdparty/CTPL/LICENSE	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RD/thirdparty/CTPL/LICENSE	(date 1720720014304)
@@ -16,7 +16,7 @@
       other entities that control, are controlled by, or are under common
       control with that entity. For the purposes of this definition,
       "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
+      direction or n_BASIC_MPgement of such entity, whether by contract or
       otherwise, or (ii) ownership of fifty percent (50%) or more of the
       outstanding shares, or (iii) beneficial ownership of such entity.
 
@@ -54,7 +54,7 @@
       means any form of electronic, verbal, or written communication sent
       to the Licensor or its representatives, including but not limited to
       communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
+      and issue tracking systems that are n_BASIC_MPged by, or on behalf of, the
       Licensor for the purpose of discussing and improving the Work, but
       excluding communication that is conspicuously marked or otherwise
       designated in writing by the copyright owner as "Not a Contribution."
Index: Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*---------------------------------------------------------------------------*/\r\n/*                                                                           */\r\n/* CSimpleSocket.cpp - CSimpleSocket Implementation                          */\r\n/*                                                                           */\r\n/* Author : Mark Carrier (mark@carrierlabs.com)                              */\r\n/*                                                                           */\r\n/*---------------------------------------------------------------------------*/\r\n/* Copyright (c) 2007-2009 CarrierLabs, LLC.  All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in\r\n *    the documentation and/or other materials provided with the\r\n *    distribution.\r\n *\r\n * 3. The name of the author may not be used to endorse or promote products\r\n *    derived from this software without specific prior written permission.\r\n *\r\n * 4. The name \"CarrierLabs\" must not be used to\r\n *    endorse or promote products derived from this software without\r\n *    prior written permission. For written permission, please contact\r\n *    mark@carrierlabs.com.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY MARK CARRIER ``AS IS'' AND ANY\r\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MARK CARRIER OR\r\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\r\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\r\n * OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *----------------------------------------------------------------------------*/\r\n#include \"SimpleSocket.h\"\r\n\r\nCSimpleSocket::CSimpleSocket(CSocketType nType) :\r\n    m_socket(INVALID_SOCKET),\r\n    m_socketErrno(CSimpleSocket::SocketInvalidSocket),\r\n    m_pBuffer(NULL), m_nBufferSize(0), m_nSocketDomain(AF_INET),\r\n    m_nSocketType(SocketTypeInvalid), m_nBytesReceived(-1),\r\n    m_nBytesSent(-1), m_nFlags(0),\r\n    m_bIsBlocking(true)\r\n{\r\n    SetConnectTimeout(1, 0);\r\n    memset(&m_stRecvTimeout, 0, sizeof(struct timeval));\r\n    memset(&m_stSendTimeout, 0, sizeof(struct timeval));\r\n    memset(&m_stLinger, 0, sizeof(struct linger));\r\n\r\n    switch(nType)\r\n    {\r\n        //----------------------------------------------------------------------\r\n        // Declare socket type stream - TCP\r\n        //----------------------------------------------------------------------\r\n    case CSimpleSocket::SocketTypeTcp:\r\n    {\r\n        m_nSocketDomain = AF_INET;\r\n        m_nSocketType = CSimpleSocket::SocketTypeTcp;\r\n        break;\r\n    }\r\n    case CSimpleSocket::SocketTypeTcp6:\r\n    {\r\n        m_nSocketDomain = AF_INET6;\r\n        m_nSocketType = CSimpleSocket::SocketTypeTcp6;\r\n        break;\r\n    }\r\n    //----------------------------------------------------------------------\r\n    // Declare socket type datagram - UDP\r\n    //----------------------------------------------------------------------\r\n    case CSimpleSocket::SocketTypeUdp:\r\n    {\r\n        m_nSocketDomain = AF_INET;\r\n        m_nSocketType = CSimpleSocket::SocketTypeUdp;\r\n        break;\r\n    }\r\n    case CSimpleSocket::SocketTypeUdp6:\r\n    {\r\n        m_nSocketDomain = AF_INET6;\r\n        m_nSocketType = CSimpleSocket::SocketTypeUdp6;\r\n        break;\r\n    }\r\n    //----------------------------------------------------------------------\r\n    // Declare socket type raw Ethernet - Ethernet\r\n    //----------------------------------------------------------------------\r\n    case CSimpleSocket::SocketTypeRaw:\r\n    {\r\n#if defined(__linux__) && !defined(_DARWIN)\r\n        m_nSocketDomain = AF_PACKET;\r\n        m_nSocketType = CSimpleSocket::SocketTypeRaw;\r\n#endif\r\n#ifdef _WIN32\r\n        m_nSocketType = CSimpleSocket::SocketTypeInvalid;\r\n#endif\r\n        break;\r\n    }\r\n    default:\r\n        m_nSocketType = CSimpleSocket::SocketTypeInvalid;\r\n        break;\r\n    }\r\n}\r\n\r\nCSimpleSocket::CSimpleSocket(CSimpleSocket &socket)\r\n{\r\n    m_pBuffer = new uint8_t[socket.m_nBufferSize];\r\n    m_nBufferSize = socket.m_nBufferSize;\r\n    memcpy(m_pBuffer, socket.m_pBuffer, socket.m_nBufferSize);\r\n}\r\n\r\nCSimpleSocket *CSimpleSocket::operator=(CSimpleSocket &socket)\r\n{\r\n    if (m_nBufferSize != socket.m_nBufferSize)\r\n    {\r\n        delete m_pBuffer;\r\n        m_pBuffer = new uint8_t[socket.m_nBufferSize];\r\n        m_nBufferSize = socket.m_nBufferSize;\r\n        memcpy(m_pBuffer, socket.m_pBuffer, socket.m_nBufferSize);\r\n    }\r\n\r\n    return this;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// Initialize() - Initialize socket class\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::Initialize()\r\n{\r\n    errno = CSimpleSocket::SocketSuccess;\r\n\r\n#ifdef _WIN32\r\n    //-------------------------------------------------------------------------\r\n    // Data structure containing general Windows Sockets Info\r\n    //-------------------------------------------------------------------------\r\n    memset(&m_hWSAData, 0, sizeof(m_hWSAData));\r\n    WSAStartup(MAKEWORD(2, 0), &m_hWSAData);\r\n#endif\r\n\r\n    //-------------------------------------------------------------------------\r\n    // Create the basic Socket Handle\r\n    //-------------------------------------------------------------------------\r\n    m_timer.Initialize();\r\n    m_timer.SetStartTime();\r\n    m_socket = socket(m_nSocketDomain, m_nSocketType, 0);\r\n    m_timer.SetEndTime();\r\n\r\n    TranslateSocketError();\r\n\r\n    return (IsSocketValid());\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// BindInterface()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::BindInterface(const char *pInterface)\r\n{\r\n    bool           bRetVal = false;\r\n    struct in_addr stInterfaceAddr;\r\n\r\n    if (GetMulticast() == true)\r\n    {\r\n        if (pInterface)\r\n        {\r\n            stInterfaceAddr.s_addr= inet_addr(pInterface);\r\n            if (SETSOCKOPT(m_socket, IPPROTO_IP, IP_MULTICAST_IF, &stInterfaceAddr, sizeof(stInterfaceAddr)) == SocketSuccess)\r\n            {\r\n                bRetVal = true;\r\n            }\r\n        }\r\n    }\r\n    else\r\n    {\r\n        SetSocketError(CSimpleSocket::SocketProtocolError);\r\n    }\r\n\r\n    return bRetVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// SetMulticast()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::SetMulticast(bool bEnable, uint8_t multicastTTL)\r\n{\r\n    bool bRetVal = false;\r\n\r\n    if (GetSocketType() == CSimpleSocket::SocketTypeUdp)\r\n    {\r\n        m_bIsMulticast = bEnable;\r\n        if (SETSOCKOPT(m_socket, IPPROTO_IP, IP_MULTICAST_TTL, (void *)&multicastTTL, sizeof(multicastTTL)) == SocketError)\r\n        {\r\n            TranslateSocketError();\r\n            bRetVal = false;\r\n        }\r\n        else\r\n        {\r\n            bRetVal = true;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        m_socketErrno = CSimpleSocket::SocketProtocolError;\r\n    }\r\n\r\n    return bRetVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// SetSocketDscp()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::SetSocketDscp(int32_t nDscp)\r\n{\r\n    bool  bRetVal = true;\r\n    int32_t nTempVal = nDscp;\r\n\r\n    nTempVal <<= 4;\r\n    nTempVal /= 4;\r\n\r\n    if (IsSocketValid())\r\n    {\r\n        if (SETSOCKOPT(m_socket, IPPROTO_IP, IP_TOS, &nTempVal, sizeof(nTempVal)) == SocketError)\r\n        {\r\n            TranslateSocketError();\r\n            bRetVal = false;\r\n        }\r\n    }\r\n\r\n    return bRetVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// GetSocketDscp()\r\n//\r\n//------------------------------------------------------------------------------\r\nint32_t CSimpleSocket::GetSocketDscp(void)\r\n{\r\n    int32_t      nTempVal = 0;\r\n    socklen_t  nLen = 0;\r\n\r\n    if (IsSocketValid())\r\n    {\r\n        if (GETSOCKOPT(m_socket, IPPROTO_IP, IP_TOS, &nTempVal, &nLen) == SocketError)\r\n        {\r\n            TranslateSocketError();\r\n        }\r\n\r\n        nTempVal *= 4;\r\n        nTempVal >>= 4;\r\n    }\r\n\r\n    return nTempVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// GetWindowSize()\r\n//\r\n//------------------------------------------------------------------------------\r\nuint32_t CSimpleSocket::GetWindowSize(uint32_t nOptionName)\r\n{\r\n    uint32_t nTcpWinSize = 0;\r\n\r\n    //-------------------------------------------------------------------------\r\n    // no socket given, return system default allocate our own new socket\r\n    //-------------------------------------------------------------------------\r\n    if (m_socket != static_cast<SOCKET>(CSimpleSocket::SocketError))\r\n    {\r\n        socklen_t nLen = sizeof(nTcpWinSize);\r\n\r\n        //---------------------------------------------------------------------\r\n        // query for buffer size\r\n        //---------------------------------------------------------------------\r\n        GETSOCKOPT(m_socket, SOL_SOCKET, nOptionName, &nTcpWinSize, &nLen);\r\n        TranslateSocketError();\r\n    }\r\n    else\r\n    {\r\n        SetSocketError(CSimpleSocket::SocketInvalidSocket);\r\n    }\r\n\r\n    return nTcpWinSize;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// SetWindowSize()\r\n//\r\n//------------------------------------------------------------------------------\r\nuint32_t CSimpleSocket::SetWindowSize(uint32_t nOptionName, uint32_t nWindowSize)\r\n{\r\n    //-------------------------------------------------------------------------\r\n    // no socket given, return system default allocate our own new socket\r\n    //-------------------------------------------------------------------------\r\n    if (m_socket != static_cast<SOCKET>(CSimpleSocket::SocketError))\r\n    {\r\n        SETSOCKOPT(m_socket, SOL_SOCKET, nOptionName, &nWindowSize, sizeof(nWindowSize));\r\n        TranslateSocketError();\r\n    }\r\n    else\r\n    {\r\n        SetSocketError(CSimpleSocket::SocketInvalidSocket);\r\n    }\r\n\r\n    return nWindowSize;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// DisableNagleAlgorithm()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::DisableNagleAlgoritm()\r\n{\r\n    bool  bRetVal = false;\r\n    int32_t nTcpNoDelay = 1;\r\n\r\n    //----------------------------------------------------------------------\r\n    // Set TCP NoDelay flag to true\r\n    //----------------------------------------------------------------------\r\n    if (SETSOCKOPT(m_socket, IPPROTO_TCP, TCP_NODELAY, &nTcpNoDelay, sizeof(int32_t)) == 0)\r\n    {\r\n        bRetVal = true;\r\n    }\r\n\r\n    TranslateSocketError();\r\n\r\n    return bRetVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// EnableNagleAlgorithm()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::EnableNagleAlgoritm()\r\n{\r\n    bool  bRetVal = false;\r\n    int32_t nTcpNoDelay = 0;\r\n\r\n    //----------------------------------------------------------------------\r\n    // Set TCP NoDelay flag to false\r\n    //----------------------------------------------------------------------\r\n    if (SETSOCKOPT(m_socket, IPPROTO_TCP, TCP_NODELAY, &nTcpNoDelay, sizeof(int32_t)) == 0)\r\n    {\r\n        bRetVal = true;\r\n    }\r\n\r\n    TranslateSocketError();\r\n\r\n    return bRetVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// Send() - Send data on a valid socket\r\n//\r\n//------------------------------------------------------------------------------\r\nint32_t CSimpleSocket::Send(const uint8_t *pBuf, size_t bytesToSend)\r\n{\r\n    SetSocketError(SocketSuccess);\r\n    m_nBytesSent = 0;\r\n\r\n    switch(m_nSocketType)\r\n    {\r\n    case CSimpleSocket::SocketTypeTcp:\r\n    {\r\n        if (IsSocketValid())\r\n        {\r\n            if ((bytesToSend > 0) && (pBuf != NULL))\r\n            {\r\n                m_timer.Initialize();\r\n                m_timer.SetStartTime();\r\n\r\n                //---------------------------------------------------------\r\n                // Check error condition and attempt to resend if call\r\n                // was interrupted by a signal.\r\n                //---------------------------------------------------------\r\n                do\r\n                {\r\n                    m_nBytesSent = SEND(m_socket, pBuf, bytesToSend, 0);\r\n                    TranslateSocketError();\r\n                } while (GetSocketError() == CSimpleSocket::SocketInterrupted);\r\n\r\n                m_timer.SetEndTime();\r\n            }\r\n        }\r\n        break;\r\n    }\r\n    case CSimpleSocket::SocketTypeUdp:\r\n    {\r\n        if (IsSocketValid())\r\n        {\r\n            if ((bytesToSend > 0) && (pBuf != NULL))\r\n            {\r\n                m_timer.Initialize();\r\n                m_timer.SetStartTime();\r\n\r\n                //---------------------------------------------------------\r\n                // Check error condition and attempt to resend if call\r\n                // was interrupted by a signal.\r\n                //---------------------------------------------------------\r\n                //                    if (GetMulticast())\r\n                //                    {\r\n                //                        do\r\n                //                        {\r\n                //                            m_nBytesSent = SENDTO(m_socket, pBuf, bytesToSend, 0, (const sockaddr *)&m_stMulticastGroup,\r\n                //                                                  sizeof(m_stMulticastGroup));\r\n                //                            TranslateSocketError();\r\n                //                        } while (GetSocketError() == CSimpleSocket::SocketInterrupted);\r\n                //                    }\r\n                //                    else\r\n                {\r\n                    do\r\n                    {\r\n                        m_nBytesSent = SENDTO(m_socket, pBuf, bytesToSend, 0, (const sockaddr *)&m_stServerSockaddr, sizeof(m_stServerSockaddr));\r\n                        TranslateSocketError();\r\n                    } while (GetSocketError() == CSimpleSocket::SocketInterrupted);\r\n                }\r\n\r\n                m_timer.SetEndTime();\r\n            }\r\n        }\r\n        break;\r\n    }\r\n    default:\r\n        break;\r\n    }\r\n\r\n    return m_nBytesSent;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// Close() - Close socket and free up any memory allocated for the socket\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::Close(void)\r\n{\r\n    bool bRetVal = false;\r\n\r\n    //--------------------------------------------------------------------------\r\n    // delete internal buffer\r\n    //--------------------------------------------------------------------------\r\n    if (m_pBuffer != NULL)\r\n    {\r\n        delete [] m_pBuffer;\r\n        m_pBuffer = NULL;\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // if socket handle is currently valid, close and then invalidate\r\n    //--------------------------------------------------------------------------\r\n    if (IsSocketValid())\r\n    {\r\n\t\tShutdown(Both);\r\n        if (CLOSE(m_socket) != CSimpleSocket::SocketError)\r\n\t\t{\r\n\t\t\tm_socket = INVALID_SOCKET;\r\n\t\t\tbRetVal = true;\r\n\t\t}\r\n    }\r\n\r\n    TranslateSocketError();\r\n\r\n    return bRetVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// Shtudown()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::Shutdown(CShutdownMode nShutdown)\r\n{\r\n    CSocketError nRetVal = SocketEunknown;\r\n\r\n    nRetVal = (CSocketError)shutdown(m_socket, nShutdown);\r\n    TranslateSocketError();\r\n\r\n    return nRetVal == CSimpleSocket::SocketSuccess;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// Flush()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::Flush()\r\n{\r\n    int32_t nTcpNoDelay = 1;\r\n    int32_t nCurFlags = 0;\r\n    uint8_t tmpbuf = 0;\r\n    bool  bRetVal = false;\r\n\r\n    //--------------------------------------------------------------------------\r\n    // Get the current setting of the TCP_NODELAY flag.\r\n    //--------------------------------------------------------------------------\r\n    if (GETSOCKOPT(m_socket, IPPROTO_TCP, TCP_NODELAY, &nCurFlags, sizeof(int32_t)) == 0)\r\n    {\r\n        //----------------------------------------------------------------------\r\n        // Set TCP NoDelay flag\r\n        //----------------------------------------------------------------------\r\n        if (SETSOCKOPT(m_socket, IPPROTO_TCP, TCP_NODELAY, &nTcpNoDelay, sizeof(int32_t)) == 0)\r\n        {\r\n            //------------------------------------------------------------------\r\n            // Send empty byte stream to flush the TCP send buffer\r\n            //------------------------------------------------------------------\r\n            if (Send(&tmpbuf, 0) != CSimpleSocket::SocketError)\r\n            {\r\n                bRetVal = true;\r\n            }\r\n\r\n            TranslateSocketError();\r\n        }\r\n\r\n        //----------------------------------------------------------------------\r\n        // Reset the TCP_NODELAY flag to original state.\r\n        //----------------------------------------------------------------------\r\n        SETSOCKOPT(m_socket, IPPROTO_TCP, TCP_NODELAY, &nCurFlags, sizeof(int32_t));\r\n    }\r\n\r\n    return bRetVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// Writev -\r\n//\r\n//------------------------------------------------------------------------------\r\nint32_t CSimpleSocket::Writev(const struct iovec *pVector, size_t nCount)\r\n{\r\n    int32_t nBytes     = 0;\r\n    int32_t nBytesSent = 0;\r\n    int32_t i          = 0;\r\n\r\n    //--------------------------------------------------------------------------\r\n    // Send each buffer as a separate send, windows does not support this\r\n    // function call.\r\n    //--------------------------------------------------------------------------\r\n    for (i = 0; i < (int32_t)nCount; i++)\r\n    {\r\n        if ((nBytes = Send((uint8_t *)pVector[i].iov_base, pVector[i].iov_len)) == CSimpleSocket::SocketError)\r\n        {\r\n            break;\r\n        }\r\n\r\n        nBytesSent += nBytes;\r\n    }\r\n\r\n    if (i > 0)\r\n    {\r\n        Flush();\r\n    }\r\n\r\n    return nBytesSent;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// Send() - Send data on a valid socket via a vector of buffers.\r\n//\r\n//------------------------------------------------------------------------------\r\nint32_t CSimpleSocket::Send(const struct iovec *sendVector, int32_t nNumItems)\r\n{\r\n    SetSocketError(SocketSuccess);\r\n    m_nBytesSent = 0;\r\n\r\n    if ((m_nBytesSent = WRITEV(m_socket, sendVector, nNumItems)) == CSimpleSocket::SocketError)\r\n    {\r\n        TranslateSocketError();\r\n    }\r\n\r\n    return m_nBytesSent;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// SetReceiveTimeout()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::SetReceiveTimeout(int32_t nRecvTimeoutSec, int32_t nRecvTimeoutUsec)\r\n{\r\n    bool bRetVal = true;\r\n\r\n    memset(&m_stRecvTimeout, 0, sizeof(struct timeval));\r\n\r\n    m_stRecvTimeout.tv_sec = nRecvTimeoutSec;\r\n    m_stRecvTimeout.tv_usec = nRecvTimeoutUsec;\r\n\r\n    //--------------------------------------------------------------------------\r\n    // Sanity check to make sure the options are supported!\r\n    //--------------------------------------------------------------------------\r\n    if (SETSOCKOPT(m_socket, SOL_SOCKET, SO_RCVTIMEO, &m_stRecvTimeout,\r\n                   sizeof(struct timeval)) == CSimpleSocket::SocketError)\r\n    {\r\n        bRetVal = false;\r\n        TranslateSocketError();\r\n    }\r\n\r\n    return bRetVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// SetSendTimeout()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::SetSendTimeout(int32_t nSendTimeoutSec, int32_t nSendTimeoutUsec)\r\n{\r\n    bool bRetVal = true;\r\n\r\n    memset(&m_stSendTimeout, 0, sizeof(struct timeval));\r\n    m_stSendTimeout.tv_sec = nSendTimeoutSec;\r\n    m_stSendTimeout.tv_usec = nSendTimeoutUsec;\r\n\r\n    //--------------------------------------------------------------------------\r\n    // Sanity check to make sure the options are supported!\r\n    //--------------------------------------------------------------------------\r\n    if (SETSOCKOPT(m_socket, SOL_SOCKET, SO_SNDTIMEO, &m_stSendTimeout,\r\n                   sizeof(struct timeval)) == CSimpleSocket::SocketError)\r\n    {\r\n        bRetVal = false;\r\n        TranslateSocketError();\r\n    }\r\n\r\n    return bRetVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// SetOptionReuseAddr()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::SetOptionReuseAddr()\r\n{\r\n    bool  bRetVal = false;\r\n    int32_t nReuse  = IPTOS_LOWDELAY;\r\n\r\n    if (SETSOCKOPT(m_socket, SOL_SOCKET, SO_REUSEADDR, (char*)&nReuse, sizeof(int32_t)) == 0)\r\n    {\r\n        bRetVal = true;\r\n    }\r\n\r\n    TranslateSocketError();\r\n\r\n    return bRetVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// SetOptionLinger()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::SetOptionLinger(bool bEnable, uint16_t nTime)\r\n{\r\n    bool bRetVal = false;\r\n\r\n    m_stLinger.l_onoff = (bEnable == true) ? 1: 0;\r\n    m_stLinger.l_linger = nTime;\r\n\r\n    if (SETSOCKOPT(m_socket, SOL_SOCKET, SO_LINGER, &m_stLinger, sizeof(m_stLinger)) == 0)\r\n    {\r\n        bRetVal = true;\r\n    }\r\n\r\n    TranslateSocketError();\r\n\r\n    return bRetVal;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// Receive() - Attempts to receive a block of data on an established\r\n//             connection.    Data is received in an internal buffer managed\r\n//             by the class.  This buffer is only valid until the next call\r\n//             to Receive(), a call to Close(), or until the object goes out\r\n//             of scope.\r\n//\r\n//------------------------------------------------------------------------------\r\nint32_t CSimpleSocket::Receive(int32_t nMaxBytes, uint8_t * pBuffer )\r\n{\r\n    m_nBytesReceived = 0;\r\n\r\n    //--------------------------------------------------------------------------\r\n    // If the socket is invalid then return false.\r\n    //--------------------------------------------------------------------------\r\n    if (IsSocketValid() == false)\r\n    {\r\n        return m_nBytesReceived;\r\n    }\r\n\r\n    uint8_t * pWorkBuffer = pBuffer;\r\n    if ( pBuffer == NULL )\r\n    {\r\n        //--------------------------------------------------------------------------\r\n        // Free existing buffer and allocate a new buffer the size of\r\n        // nMaxBytes.\r\n        //--------------------------------------------------------------------------\r\n        if ((m_pBuffer != NULL) && (nMaxBytes != m_nBufferSize))\r\n        {\r\n            delete [] m_pBuffer;\r\n            m_pBuffer = NULL;\r\n        }\r\n\r\n        //--------------------------------------------------------------------------\r\n        // Allocate a new internal buffer to receive data.\r\n        //--------------------------------------------------------------------------\r\n        if (m_pBuffer == NULL)\r\n        {\r\n            m_nBufferSize = nMaxBytes;\r\n            m_pBuffer = new uint8_t[nMaxBytes];\r\n        }\r\n\r\n        pWorkBuffer = m_pBuffer;\r\n    }\r\n\r\n    SetSocketError(SocketSuccess);\r\n\r\n    m_timer.Initialize();\r\n    m_timer.SetStartTime();\r\n\r\n    switch (m_nSocketType)\r\n    {\r\n        //----------------------------------------------------------------------\r\n        // If zero bytes are received, then return.  If SocketERROR is\r\n        // received, free buffer and return CSocket::SocketError (-1) to caller.\r\n        //----------------------------------------------------------------------\r\n    case CSimpleSocket::SocketTypeTcp:\r\n    {\r\n        do\r\n        {\r\n            m_nBytesReceived = RECV(m_socket, (pWorkBuffer + m_nBytesReceived),\r\n                                    nMaxBytes, m_nFlags);\r\n            TranslateSocketError();\r\n        } while ((GetSocketError() == CSimpleSocket::SocketInterrupted));\r\n\r\n        break;\r\n    }\r\n    case CSimpleSocket::SocketTypeUdp:\r\n    {\r\n        uint32_t srcSize;\r\n\r\n        srcSize = sizeof(struct sockaddr_in);\r\n\r\n        if (GetMulticast() == true)\r\n        {\r\n            do\r\n            {\r\n                m_nBytesReceived = RECVFROM(m_socket, pWorkBuffer, nMaxBytes, 0,\r\n                                            &m_stMulticastGroup, &srcSize);\r\n                TranslateSocketError();\r\n            } while (GetSocketError() == CSimpleSocket::SocketInterrupted);\r\n        }\r\n        else\r\n        {\r\n            do\r\n            {\r\n                m_nBytesReceived = RECVFROM(m_socket, pWorkBuffer, nMaxBytes, 0,\r\n                                            &m_stClientSockaddr, &srcSize);\r\n                TranslateSocketError();\r\n            } while (GetSocketError() == CSimpleSocket::SocketInterrupted);\r\n        }\r\n\r\n        break;\r\n    }\r\n    default:\r\n        break;\r\n    }\r\n\r\n    m_timer.SetEndTime();\r\n    TranslateSocketError();\r\n\r\n    //--------------------------------------------------------------------------\r\n    // If we encounter an error translate the error code and return.  One\r\n    // possible error code could be EAGAIN (EWOULDBLOCK) if the socket is\r\n    // non-blocking.  This does not mean there is an error, but no data is\r\n    // yet available on the socket.\r\n    //--------------------------------------------------------------------------\r\n    if (m_nBytesReceived == CSimpleSocket::SocketError)\r\n    {\r\n        if (m_pBuffer != NULL)\r\n        {\r\n            delete [] m_pBuffer;\r\n            m_pBuffer = NULL;\r\n        }\r\n    }\r\n\r\n    return m_nBytesReceived;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// SetNonblocking()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::SetNonblocking(void)\r\n{\r\n    int32_t  nCurFlags;\r\n\r\n#ifdef _WIN32\r\n    nCurFlags = 1;\r\n\r\n    if (ioctlsocket(m_socket, FIONBIO, (ULONG *)&nCurFlags) != 0)\r\n    {\r\n        TranslateSocketError();\r\n        return false;\r\n    }\r\n#else\r\n    if ((nCurFlags = fcntl(m_socket, F_GETFL)) < 0)\r\n    {\r\n        TranslateSocketError();\r\n        return false;\r\n    }\r\n\r\n    nCurFlags |= O_NONBLOCK;\r\n\r\n    if (fcntl(m_socket, F_SETFL, nCurFlags) != 0)\r\n    {\r\n        TranslateSocketError();\r\n        return false;\r\n    }\r\n#endif\r\n\r\n    m_bIsBlocking = false;\r\n\r\n    return true;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// SetBlocking()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::SetBlocking(void)\r\n{\r\n    int32_t nCurFlags;\r\n\r\n#ifdef _WIN32\r\n    nCurFlags = 0;\r\n\r\n    if (ioctlsocket(m_socket, FIONBIO, (ULONG *)&nCurFlags) != 0)\r\n    {\r\n        return false;\r\n    }\r\n#else\r\n    if ((nCurFlags = fcntl(m_socket, F_GETFL)) < 0)\r\n    {\r\n        TranslateSocketError();\r\n        return false;\r\n    }\r\n\r\n    nCurFlags &= (~O_NONBLOCK);\r\n\r\n    if (fcntl(m_socket, F_SETFL, nCurFlags) != 0)\r\n    {\r\n        TranslateSocketError();\r\n        return false;\r\n    }\r\n#endif\r\n    m_bIsBlocking = true;\r\n\r\n    return true;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// SendFile() - stands-in for system provided sendfile\r\n//\r\n//------------------------------------------------------------------------------\r\nint32_t CSimpleSocket::SendFile(int32_t nOutFd, int32_t nInFd, off_t *pOffset, int32_t nCount)\r\n{\r\n    int32_t  nOutCount = CSimpleSocket::SocketError;\r\n\r\n    static char szData[SOCKET_SENDFILE_BLOCKSIZE];\r\n    int32_t       nInCount = 0;\r\n\r\n    if (lseek(nInFd, *pOffset, SEEK_SET) == -1)\r\n    {\r\n        return -1;\r\n    }\r\n\r\n    while (nOutCount < nCount)\r\n    {\r\n        nInCount = (nCount - nOutCount) < SOCKET_SENDFILE_BLOCKSIZE ? (nCount - nOutCount) : SOCKET_SENDFILE_BLOCKSIZE;\r\n\r\n        if ((read(nInFd, szData, nInCount)) != (int32_t)nInCount)\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        if ((SEND(nOutFd, szData, nInCount, 0)) != (int32_t)nInCount)\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        nOutCount += nInCount;\r\n    }\r\n\r\n    *pOffset += nOutCount;\r\n\r\n    TranslateSocketError();\r\n\r\n    return nOutCount;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// TranslateSocketError() -\r\n//\r\n//------------------------------------------------------------------------------\r\nvoid CSimpleSocket::TranslateSocketError(void)\r\n{\r\n#if defined(__linux__) || defined(_DARWIN)\r\n    switch (errno)\r\n    {\r\n    case EXIT_SUCCESS:\r\n        SetSocketError(CSimpleSocket::SocketSuccess);\r\n        break;\r\n    case ENOTCONN:\r\n        SetSocketError(CSimpleSocket::SocketNotconnected);\r\n        break;\r\n    case ENOTSOCK:\r\n    case EBADF:\r\n    case EACCES:\r\n    case EAFNOSUPPORT:\r\n    case EMFILE:\r\n    case ENFILE:\r\n    case ENOBUFS:\r\n    case ENOMEM:\r\n    case EPROTONOSUPPORT:\r\n    case EPIPE:\r\n        SetSocketError(CSimpleSocket::SocketInvalidSocket);\r\n        break;\r\n    case ECONNREFUSED :\r\n        SetSocketError(CSimpleSocket::SocketConnectionRefused);\r\n        break;\r\n    case ETIMEDOUT:\r\n        SetSocketError(CSimpleSocket::SocketTimedout);\r\n        break;\r\n    case EINPROGRESS:\r\n        SetSocketError(CSimpleSocket::SocketEinprogress);\r\n        break;\r\n    case EWOULDBLOCK:\r\n        //        case EAGAIN:\r\n        SetSocketError(CSimpleSocket::SocketEwouldblock);\r\n        break;\r\n    case EINTR:\r\n        SetSocketError(CSimpleSocket::SocketInterrupted);\r\n        break;\r\n    case ECONNABORTED:\r\n        SetSocketError(CSimpleSocket::SocketConnectionAborted);\r\n        break;\r\n    case EINVAL:\r\n    case EPROTO:\r\n        SetSocketError(CSimpleSocket::SocketProtocolError);\r\n        break;\r\n    case EPERM:\r\n        SetSocketError(CSimpleSocket::SocketFirewallError);\r\n        break;\r\n    case EFAULT:\r\n        SetSocketError(CSimpleSocket::SocketInvalidSocketBuffer);\r\n        break;\r\n    case ECONNRESET:\r\n    case ENOPROTOOPT:\r\n        SetSocketError(CSimpleSocket::SocketConnectionReset);\r\n        break;\r\n    default:\r\n        SetSocketError(CSimpleSocket::SocketEunknown);\r\n        break;\r\n    }\r\n#endif\r\n#ifdef _WIN32\r\n    int32_t nError = WSAGetLastError();\r\n    switch (nError)\r\n    {\r\n    case EXIT_SUCCESS:\r\n        SetSocketError(CSimpleSocket::SocketSuccess);\r\n        break;\r\n    case WSAEBADF:\r\n    case WSAENOTCONN:\r\n        SetSocketError(CSimpleSocket::SocketNotconnected);\r\n        break;\r\n    case WSAEINTR:\r\n        SetSocketError(CSimpleSocket::SocketInterrupted);\r\n        break;\r\n    case WSAEACCES:\r\n    case WSAEAFNOSUPPORT:\r\n    case WSAEINVAL:\r\n    case WSAEMFILE:\r\n    case WSAENOBUFS:\r\n    case WSAEPROTONOSUPPORT:\r\n        SetSocketError(CSimpleSocket::SocketInvalidSocket);\r\n        break;\r\n    case WSAECONNREFUSED :\r\n        SetSocketError(CSimpleSocket::SocketConnectionRefused);\r\n        break;\r\n    case WSAETIMEDOUT:\r\n        SetSocketError(CSimpleSocket::SocketTimedout);\r\n        break;\r\n    case WSAEINPROGRESS:\r\n        SetSocketError(CSimpleSocket::SocketEinprogress);\r\n        break;\r\n    case WSAECONNABORTED:\r\n        SetSocketError(CSimpleSocket::SocketConnectionAborted);\r\n        break;\r\n    case WSAEWOULDBLOCK:\r\n        SetSocketError(CSimpleSocket::SocketEwouldblock);\r\n        break;\r\n    case WSAENOTSOCK:\r\n        SetSocketError(CSimpleSocket::SocketInvalidSocket);\r\n        break;\r\n    case WSAECONNRESET:\r\n        SetSocketError(CSimpleSocket::SocketConnectionReset);\r\n        break;\r\n    case WSANO_DATA:\r\n        SetSocketError(CSimpleSocket::SocketInvalidAddress);\r\n        break;\r\n    case WSAEADDRINUSE:\r\n        SetSocketError(CSimpleSocket::SocketAddressInUse);\r\n        break;\r\n    case WSAEFAULT:\r\n        SetSocketError(CSimpleSocket::SocketInvalidPointer);\r\n        break;\r\n    default:\r\n        SetSocketError(CSimpleSocket::SocketEunknown);\r\n        break;\r\n    }\r\n#endif\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// DescribeError()\r\n//\r\n//------------------------------------------------------------------------------\r\n\r\nconst char *CSimpleSocket::DescribeError(CSocketError err)\r\n{\r\n    switch (err) {\r\n        case CSimpleSocket::SocketError:\r\n            return \"Generic socket error translates to error below.\";\r\n        case CSimpleSocket::SocketSuccess:\r\n            return \"No socket error.\";\r\n        case CSimpleSocket::SocketInvalidSocket:\r\n            return \"Invalid socket handle.\";\r\n        case CSimpleSocket::SocketInvalidAddress:\r\n            return \"Invalid destination address specified.\";\r\n        case CSimpleSocket::SocketInvalidPort:\r\n            return \"Invalid destination port specified.\";\r\n        case CSimpleSocket::SocketConnectionRefused:\r\n            return \"No server is listening at remote address.\";\r\n        case CSimpleSocket::SocketTimedout:\r\n            return \"Timed out while attempting operation.\";\r\n        case CSimpleSocket::SocketEwouldblock:\r\n            return \"Operation would block if socket were blocking.\";\r\n        case CSimpleSocket::SocketNotconnected:\r\n            return \"Currently not connected.\";\r\n        case CSimpleSocket::SocketEinprogress:\r\n            return \"Socket is non-blocking and the connection cannot be completed immediately\";\r\n        case CSimpleSocket::SocketInterrupted:\r\n            return \"Call was interrupted by a signal that was caught before a valid connection arrived.\";\r\n        case CSimpleSocket::SocketConnectionAborted:\r\n            return \"The connection has been aborted.\";\r\n        case CSimpleSocket::SocketProtocolError:\r\n            return \"Invalid protocol for operation.\";\r\n        case CSimpleSocket::SocketFirewallError:\r\n            return \"Firewall rules forbid connection.\";\r\n        case CSimpleSocket::SocketInvalidSocketBuffer:\r\n            return \"The receive buffer point outside the process's address space.\";\r\n        case CSimpleSocket::SocketConnectionReset:\r\n            return \"Connection was forcibly closed by the remote host.\";\r\n        case CSimpleSocket::SocketAddressInUse:\r\n            return \"Address already in use.\";\r\n        case CSimpleSocket::SocketInvalidPointer:\r\n            return \"Pointer type supplied as argument is invalid.\";\r\n        case CSimpleSocket::SocketEunknown:\r\n            return \"Unknown error\";\r\n        default:\r\n            return \"No such CSimpleSocket error\";\r\n    }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//\r\n// Select()\r\n//\r\n//------------------------------------------------------------------------------\r\nbool CSimpleSocket::Select(int32_t nTimeoutSec, int32_t nTimeoutUSec)\r\n{\r\n    bool            bRetVal = false;\r\n    struct timeval *pTimeout = NULL;\r\n    struct timeval  timeout;\r\n    int32_t           nNumDescriptors = -1;\r\n    int32_t           nError = 0;\r\n\r\n    FD_ZERO(&m_errorFds);\r\n    FD_ZERO(&m_readFds);\r\n    FD_ZERO(&m_writeFds);\r\n    FD_SET(m_socket, &m_errorFds);\r\n    FD_SET(m_socket, &m_readFds);\r\n    FD_SET(m_socket, &m_writeFds);\r\n\r\n    //---------------------------------------------------------------------\r\n    // If timeout has been specified then set value, otherwise set timeout\r\n    // to NULL which will block until a descriptor is ready for read/write\r\n    // or an error has occurred.\r\n    //---------------------------------------------------------------------\r\n    if ((nTimeoutSec > 0) || (nTimeoutUSec > 0))\r\n    {\r\n        timeout.tv_sec = nTimeoutSec;\r\n        timeout.tv_usec = nTimeoutUSec;\r\n        pTimeout = &timeout;\r\n    }\r\n\r\n    nNumDescriptors = SELECT(m_socket+1, &m_readFds, &m_writeFds, &m_errorFds, pTimeout);\r\n//    nNumDescriptors = SELECT(m_socket+1, &m_readFds, NULL, NULL, pTimeout);\r\n\r\n    //----------------------------------------------------------------------\r\n    // Handle timeout\r\n    //----------------------------------------------------------------------\r\n    if (nNumDescriptors == 0)\r\n    {\r\n        SetSocketError(CSimpleSocket::SocketTimedout);\r\n    }\r\n    //----------------------------------------------------------------------\r\n    // If a file descriptor (read/write) is set then check the\r\n    // socket error (SO_ERROR) to see if there is a pending error.\r\n    //----------------------------------------------------------------------\r\n    else if ((FD_ISSET(m_socket, &m_readFds)) || (FD_ISSET(m_socket, &m_writeFds)))\r\n    {\r\n        int32_t nLen = sizeof(nError);\r\n\r\n        if (GETSOCKOPT(m_socket, SOL_SOCKET, SO_ERROR, &nError, &nLen) == 0)\r\n        {\r\n            errno = nError;\r\n\r\n            if (nError == 0)\r\n            {\r\n                bRetVal = true;\r\n            }\r\n        }\r\n\r\n        TranslateSocketError();\r\n    }\r\n\r\n    return bRetVal;\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.cpp b/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.cpp
--- a/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.cpp	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.cpp	(date 1720720014692)
@@ -705,7 +705,7 @@
 //------------------------------------------------------------------------------
 //
 // Receive() - Attempts to receive a block of data on an established
-//             connection.    Data is received in an internal buffer managed
+//             connection.    Data is received in an internal buffer n_BASIC_MPged
 //             by the class.  This buffer is only valid until the next call
 //             to Receive(), a call to Close(), or until the object goes out
 //             of scope.
Index: Config/DefaultEngine.ini
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[/Script/EngineSettings.GameMapsSettings]\r\nGameDefaultMap=/Game/ThirdPerson/Maps/ThirdPersonMap.ThirdPersonMap\r\nEditorStartupMap=/Game/ThirdPerson/Maps/ThirdPersonMap.ThirdPersonMap\r\nGlobalDefaultGameMode=\"/Script/FIM.FIMGameMode\"\r\nGameInstanceClass=/Script/Engine.GameInstance\r\n\r\n[/Script/IOSRuntimeSettings.IOSRuntimeSettings]\r\nMinimumiOSVersion=IOS_14\r\n\r\n[/Script/Engine.RendererSettings]\r\nr.Shadow.Virtual.Enable=1\r\nr.Mobile.EnableNoPrecomputedLightingCSMShader=1\r\n\r\n\r\nr.GenerateMeshDistanceFields=True\r\n\r\nr.DynamicGlobalIlluminationMethod=1\r\n\r\nr.ReflectionMethod=1\r\n\r\n[/Script/HardwareTargeting.HardwareTargetingSettings]\r\nTargetedHardwareClass=Desktop\r\nAppliedTargetedHardwareClass=Desktop\r\nDefaultGraphicsPerformance=Maximum\r\nAppliedDefaultGraphicsPerformance=Maximum\r\n\r\n[/Script/WindowsTargetPlatform.WindowsTargetSettings]\r\nDefaultGraphicsRHI=DefaultGraphicsRHI_DX12\r\n-D3D12TargetedShaderFormats=PCD3D_SM5\r\n+D3D12TargetedShaderFormats=PCD3D_SM5\r\n+D3D12TargetedShaderFormats=PCD3D_SM6\r\n-D3D11TargetedShaderFormats=PCD3D_SM5\r\n+D3D11TargetedShaderFormats=PCD3D_SM5\r\nCompiler=Default\r\nAudioSampleRate=48000\r\nAudioCallbackBufferFrameSize=1024\r\nAudioNumBuffersToEnqueue=1\r\nAudioMaxChannels=0\r\nAudioNumSourceWorkers=4\r\nSpatializationPlugin=\r\nSourceDataOverridePlugin=\r\nReverbPlugin=\r\nOcclusionPlugin=\r\nCompressionOverrides=(bOverrideCompressionTimes=False,DurationThreshold=5.000000,MaxNumRandomBranches=0,SoundCueQualityIndex=0)\r\nCacheSizeKB=65536\r\nMaxChunkSizeOverrideKB=0\r\nbResampleForDevice=False\r\nMaxSampleRate=48000.000000\r\nHighSampleRate=32000.000000\r\nMedSampleRate=24000.000000\r\nLowSampleRate=12000.000000\r\nMinSampleRate=8000.000000\r\nCompressionQualityModifier=1.000000\r\nAutoStreamingThreshold=0.000000\r\nSoundCueCookQualityIndex=-1\r\n\r\n[/Script/Engine.Engine]\r\n+ActiveGameNameRedirects=(OldGameName=\"TP_ThirdPerson\",NewGameName=\"/Script/FIM\")\r\n+ActiveGameNameRedirects=(OldGameName=\"/Script/TP_ThirdPerson\",NewGameName=\"/Script/FIM\")\r\n+ActiveClassRedirects=(OldClassName=\"TP_ThirdPersonGameMode\",NewClassName=\"FIMGameMode\")\r\n+ActiveClassRedirects=(OldClassName=\"TP_ThirdPersonCharacter\",NewClassName=\"FIMCharacter\")\r\n\r\n[/Script/AndroidFileServerEditor.AndroidFileServerRuntimeSettings]\r\nbEnablePlugin=True\r\nbAllowNetworkConnection=True\r\nSecurityToken=AF93BD9E45D4391C367770A0B3810935\r\nbIncludeInShipping=False\r\nbAllowExternalStartInShipping=False\r\nbCompileAFSProject=False\r\nbUseCompression=False\r\nbLogFiles=False\r\nbReportStats=False\r\nConnectionType=USBOnly\r\nbUseManualIPAddress=False\r\nManualIPAddress=\r\n\r\n[PacketSimulationSettings]\r\n\r\nPktLag=0\r\n\r\nPktLagVariance=0\r\n\r\nPktLoss=0\r\n\r\nPktOrder=0\r\n\r\nPktDup=0\r\n\r\n[/Script/Engine.GameEngine]\r\n\r\n+NetDriverDefinitions=(DefName=\"DemoNetDriver\",DriverClassName=\"/Script/Engine.DemoNetDriver\",DriverClassNameFallback=\"/Script/Engine.DemoNetDriver\")\r\n\r\nThis step will enable and load the DemoNetDriver for you, which is the actual recorder.\r\n\r\n[/Script/Engine.CollisionProfile]\r\n-Profiles=(Name=\"NoCollision\",CollisionEnabled=NoCollision,ObjectTypeName=\"WorldStatic\",CustomResponses=((Channel=\"Visibility\",Response=ECR_Ignore),(Channel=\"Camera\",Response=ECR_Ignore)),HelpMessage=\"No collision\",bCanModify=False)\r\n-Profiles=(Name=\"BlockAll\",CollisionEnabled=QueryAndPhysics,ObjectTypeName=\"WorldStatic\",CustomResponses=,HelpMessage=\"WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. \",bCanModify=False)\r\n-Profiles=(Name=\"OverlapAll\",CollisionEnabled=QueryOnly,ObjectTypeName=\"WorldStatic\",CustomResponses=((Channel=\"WorldStatic\",Response=ECR_Overlap),(Channel=\"Pawn\",Response=ECR_Overlap),(Channel=\"Visibility\",Response=ECR_Overlap),(Channel=\"WorldDynamic\",Response=ECR_Overlap),(Channel=\"Camera\",Response=ECR_Overlap),(Channel=\"PhysicsBody\",Response=ECR_Overlap),(Channel=\"Vehicle\",Response=ECR_Overlap),(Channel=\"Destructible\",Response=ECR_Overlap)),HelpMessage=\"WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. \",bCanModify=False)\r\n-Profiles=(Name=\"BlockAllDynamic\",CollisionEnabled=QueryAndPhysics,ObjectTypeName=\"WorldDynamic\",CustomResponses=,HelpMessage=\"WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. \",bCanModify=False)\r\n-Profiles=(Name=\"OverlapAllDynamic\",CollisionEnabled=QueryOnly,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"WorldStatic\",Response=ECR_Overlap),(Channel=\"Pawn\",Response=ECR_Overlap),(Channel=\"Visibility\",Response=ECR_Overlap),(Channel=\"WorldDynamic\",Response=ECR_Overlap),(Channel=\"Camera\",Response=ECR_Overlap),(Channel=\"PhysicsBody\",Response=ECR_Overlap),(Channel=\"Vehicle\",Response=ECR_Overlap),(Channel=\"Destructible\",Response=ECR_Overlap)),HelpMessage=\"WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. \",bCanModify=False)\r\n-Profiles=(Name=\"IgnoreOnlyPawn\",CollisionEnabled=QueryOnly,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"Pawn\",Response=ECR_Ignore),(Channel=\"Vehicle\",Response=ECR_Ignore)),HelpMessage=\"WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.\",bCanModify=False)\r\n-Profiles=(Name=\"OverlapOnlyPawn\",CollisionEnabled=QueryOnly,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"Pawn\",Response=ECR_Overlap),(Channel=\"Vehicle\",Response=ECR_Overlap),(Channel=\"Camera\",Response=ECR_Ignore)),HelpMessage=\"WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. \",bCanModify=False)\r\n-Profiles=(Name=\"Pawn\",CollisionEnabled=QueryAndPhysics,ObjectTypeName=\"Pawn\",CustomResponses=((Channel=\"Visibility\",Response=ECR_Ignore)),HelpMessage=\"Pawn object. Can be used for capsule of any playerable character or AI. \",bCanModify=False)\r\n-Profiles=(Name=\"Spectator\",CollisionEnabled=QueryOnly,ObjectTypeName=\"Pawn\",CustomResponses=((Channel=\"WorldStatic\",Response=ECR_Block),(Channel=\"Pawn\",Response=ECR_Ignore),(Channel=\"Visibility\",Response=ECR_Ignore),(Channel=\"WorldDynamic\",Response=ECR_Ignore),(Channel=\"Camera\",Response=ECR_Ignore),(Channel=\"PhysicsBody\",Response=ECR_Ignore),(Channel=\"Vehicle\",Response=ECR_Ignore),(Channel=\"Destructible\",Response=ECR_Ignore)),HelpMessage=\"Pawn object that ignores all other actors except WorldStatic.\",bCanModify=False)\r\n-Profiles=(Name=\"CharacterMesh\",CollisionEnabled=QueryOnly,ObjectTypeName=\"Pawn\",CustomResponses=((Channel=\"Pawn\",Response=ECR_Ignore),(Channel=\"Vehicle\",Response=ECR_Ignore),(Channel=\"Visibility\",Response=ECR_Ignore)),HelpMessage=\"Pawn object that is used for Character Mesh. All other channels will be set to default.\",bCanModify=False)\r\n-Profiles=(Name=\"PhysicsActor\",CollisionEnabled=QueryAndPhysics,ObjectTypeName=\"PhysicsBody\",CustomResponses=,HelpMessage=\"Simulating actors\",bCanModify=False)\r\n-Profiles=(Name=\"Destructible\",CollisionEnabled=QueryAndPhysics,ObjectTypeName=\"Destructible\",CustomResponses=,HelpMessage=\"Destructible actors\",bCanModify=False)\r\n-Profiles=(Name=\"InvisibleWall\",CollisionEnabled=QueryAndPhysics,ObjectTypeName=\"WorldStatic\",CustomResponses=((Channel=\"Visibility\",Response=ECR_Ignore)),HelpMessage=\"WorldStatic object that is invisible.\",bCanModify=False)\r\n-Profiles=(Name=\"InvisibleWallDynamic\",CollisionEnabled=QueryAndPhysics,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"Visibility\",Response=ECR_Ignore)),HelpMessage=\"WorldDynamic object that is invisible.\",bCanModify=False)\r\n-Profiles=(Name=\"Trigger\",CollisionEnabled=QueryOnly,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"WorldStatic\",Response=ECR_Overlap),(Channel=\"Pawn\",Response=ECR_Overlap),(Channel=\"Visibility\",Response=ECR_Ignore),(Channel=\"WorldDynamic\",Response=ECR_Overlap),(Channel=\"Camera\",Response=ECR_Overlap),(Channel=\"PhysicsBody\",Response=ECR_Overlap),(Channel=\"Vehicle\",Response=ECR_Overlap),(Channel=\"Destructible\",Response=ECR_Overlap)),HelpMessage=\"WorldDynamic object that is used for trigger. All other channels will be set to default.\",bCanModify=False)\r\n-Profiles=(Name=\"Ragdoll\",CollisionEnabled=QueryAndPhysics,ObjectTypeName=\"PhysicsBody\",CustomResponses=((Channel=\"Pawn\",Response=ECR_Ignore),(Channel=\"Visibility\",Response=ECR_Ignore)),HelpMessage=\"Simulating Skeletal Mesh Component. All other channels will be set to default.\",bCanModify=False)\r\n-Profiles=(Name=\"Vehicle\",CollisionEnabled=QueryAndPhysics,ObjectTypeName=\"Vehicle\",CustomResponses=,HelpMessage=\"Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.\",bCanModify=False)\r\n-Profiles=(Name=\"UI\",CollisionEnabled=QueryOnly,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"WorldStatic\",Response=ECR_Overlap),(Channel=\"Pawn\",Response=ECR_Overlap),(Channel=\"Visibility\",Response=ECR_Block),(Channel=\"WorldDynamic\",Response=ECR_Overlap),(Channel=\"Camera\",Response=ECR_Overlap),(Channel=\"PhysicsBody\",Response=ECR_Overlap),(Channel=\"Vehicle\",Response=ECR_Overlap),(Channel=\"Destructible\",Response=ECR_Overlap)),HelpMessage=\"WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. \",bCanModify=False)\r\n+Profiles=(Name=\"NoCollision\",CollisionEnabled=NoCollision,bCanModify=False,ObjectTypeName=\"WorldStatic\",CustomResponses=((Channel=\"Visibility\",Response=ECR_Ignore),(Channel=\"Camera\",Response=ECR_Ignore)),HelpMessage=\"No collision\")\r\n+Profiles=(Name=\"BlockAll\",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName=\"WorldStatic\",CustomResponses=,HelpMessage=\"WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. \")\r\n+Profiles=(Name=\"OverlapAll\",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName=\"WorldStatic\",CustomResponses=((Channel=\"WorldStatic\",Response=ECR_Overlap),(Channel=\"Pawn\",Response=ECR_Overlap),(Channel=\"Visibility\",Response=ECR_Overlap),(Channel=\"WorldDynamic\",Response=ECR_Overlap),(Channel=\"Camera\",Response=ECR_Overlap),(Channel=\"PhysicsBody\",Response=ECR_Overlap),(Channel=\"Vehicle\",Response=ECR_Overlap),(Channel=\"Destructible\",Response=ECR_Overlap)),HelpMessage=\"WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. \")\r\n+Profiles=(Name=\"BlockAllDynamic\",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName=\"WorldDynamic\",CustomResponses=,HelpMessage=\"WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. \")\r\n+Profiles=(Name=\"OverlapAllDynamic\",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"WorldStatic\",Response=ECR_Overlap),(Channel=\"Pawn\",Response=ECR_Overlap),(Channel=\"Visibility\",Response=ECR_Overlap),(Channel=\"WorldDynamic\",Response=ECR_Overlap),(Channel=\"Camera\",Response=ECR_Overlap),(Channel=\"PhysicsBody\",Response=ECR_Overlap),(Channel=\"Vehicle\",Response=ECR_Overlap),(Channel=\"Destructible\",Response=ECR_Overlap)),HelpMessage=\"WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. \")\r\n+Profiles=(Name=\"IgnoreOnlyPawn\",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"Pawn\",Response=ECR_Ignore),(Channel=\"Vehicle\",Response=ECR_Ignore)),HelpMessage=\"WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.\")\r\n+Profiles=(Name=\"OverlapOnlyPawn\",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"Pawn\",Response=ECR_Overlap),(Channel=\"Vehicle\",Response=ECR_Overlap),(Channel=\"Camera\",Response=ECR_Ignore)),HelpMessage=\"WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. \")\r\n+Profiles=(Name=\"Pawn\",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName=\"Pawn\",CustomResponses=((Channel=\"Visibility\",Response=ECR_Ignore)),HelpMessage=\"Pawn object. Can be used for capsule of any playerable character or AI. \")\r\n+Profiles=(Name=\"Spectator\",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName=\"Pawn\",CustomResponses=((Channel=\"WorldStatic\"),(Channel=\"Pawn\",Response=ECR_Ignore),(Channel=\"Visibility\",Response=ECR_Ignore),(Channel=\"WorldDynamic\",Response=ECR_Ignore),(Channel=\"Camera\",Response=ECR_Ignore),(Channel=\"PhysicsBody\",Response=ECR_Ignore),(Channel=\"Vehicle\",Response=ECR_Ignore),(Channel=\"Destructible\",Response=ECR_Ignore)),HelpMessage=\"Pawn object that ignores all other actors except WorldStatic.\")\r\n+Profiles=(Name=\"CharacterMesh\",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName=\"Pawn\",CustomResponses=((Channel=\"Pawn\",Response=ECR_Ignore),(Channel=\"Vehicle\",Response=ECR_Ignore),(Channel=\"Visibility\",Response=ECR_Ignore)),HelpMessage=\"Pawn object that is used for Character Mesh. All other channels will be set to default.\")\r\n+Profiles=(Name=\"PhysicsActor\",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName=\"PhysicsBody\",CustomResponses=,HelpMessage=\"Simulating actors\")\r\n+Profiles=(Name=\"Destructible\",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName=\"Destructible\",CustomResponses=,HelpMessage=\"Destructible actors\")\r\n+Profiles=(Name=\"InvisibleWall\",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName=\"WorldStatic\",CustomResponses=((Channel=\"Visibility\",Response=ECR_Ignore)),HelpMessage=\"WorldStatic object that is invisible.\")\r\n+Profiles=(Name=\"InvisibleWallDynamic\",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"Visibility\",Response=ECR_Ignore)),HelpMessage=\"WorldDynamic object that is invisible.\")\r\n+Profiles=(Name=\"Trigger\",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"WorldStatic\",Response=ECR_Overlap),(Channel=\"Pawn\",Response=ECR_Overlap),(Channel=\"Visibility\",Response=ECR_Ignore),(Channel=\"WorldDynamic\",Response=ECR_Overlap),(Channel=\"Camera\",Response=ECR_Overlap),(Channel=\"PhysicsBody\",Response=ECR_Overlap),(Channel=\"Vehicle\",Response=ECR_Overlap),(Channel=\"Destructible\",Response=ECR_Overlap)),HelpMessage=\"WorldDynamic object that is used for trigger. All other channels will be set to default.\")\r\n+Profiles=(Name=\"Ragdoll\",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName=\"PhysicsBody\",CustomResponses=((Channel=\"Pawn\",Response=ECR_Ignore),(Channel=\"Visibility\",Response=ECR_Ignore)),HelpMessage=\"Simulating Skeletal Mesh Component. All other channels will be set to default.\")\r\n+Profiles=(Name=\"Vehicle\",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName=\"Vehicle\",CustomResponses=,HelpMessage=\"Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.\")\r\n+Profiles=(Name=\"UI\",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName=\"WorldDynamic\",CustomResponses=((Channel=\"WorldStatic\",Response=ECR_Overlap),(Channel=\"Pawn\",Response=ECR_Overlap),(Channel=\"Visibility\"),(Channel=\"WorldDynamic\",Response=ECR_Overlap),(Channel=\"Camera\",Response=ECR_Overlap),(Channel=\"PhysicsBody\",Response=ECR_Overlap),(Channel=\"Vehicle\",Response=ECR_Overlap),(Channel=\"Destructible\",Response=ECR_Overlap)),HelpMessage=\"WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. \")\r\n+DefaultChannelResponses=(Channel=ECC_GameTraceChannel1,DefaultResponse=ECR_Block,bTraceType=False,bStaticObject=False,Name=\"Interacable\")\r\n-ProfileRedirects=(OldName=\"BlockingVolume\",NewName=\"InvisibleWall\")\r\n-ProfileRedirects=(OldName=\"InterpActor\",NewName=\"IgnoreOnlyPawn\")\r\n-ProfileRedirects=(OldName=\"StaticMeshComponent\",NewName=\"BlockAllDynamic\")\r\n-ProfileRedirects=(OldName=\"SkeletalMeshActor\",NewName=\"PhysicsActor\")\r\n-ProfileRedirects=(OldName=\"InvisibleActor\",NewName=\"InvisibleWallDynamic\")\r\n+ProfileRedirects=(OldName=\"BlockingVolume\",NewName=\"InvisibleWall\")\r\n+ProfileRedirects=(OldName=\"InterpActor\",NewName=\"IgnoreOnlyPawn\")\r\n+ProfileRedirects=(OldName=\"StaticMeshComponent\",NewName=\"BlockAllDynamic\")\r\n+ProfileRedirects=(OldName=\"SkeletalMeshActor\",NewName=\"PhysicsActor\")\r\n+ProfileRedirects=(OldName=\"InvisibleActor\",NewName=\"InvisibleWallDynamic\")\r\n-CollisionChannelRedirects=(OldName=\"Static\",NewName=\"WorldStatic\")\r\n-CollisionChannelRedirects=(OldName=\"Dynamic\",NewName=\"WorldDynamic\")\r\n-CollisionChannelRedirects=(OldName=\"VehicleMovement\",NewName=\"Vehicle\")\r\n-CollisionChannelRedirects=(OldName=\"PawnMovement\",NewName=\"Pawn\")\r\n+CollisionChannelRedirects=(OldName=\"Static\",NewName=\"WorldStatic\")\r\n+CollisionChannelRedirects=(OldName=\"Dynamic\",NewName=\"WorldDynamic\")\r\n+CollisionChannelRedirects=(OldName=\"VehicleMovement\",NewName=\"Vehicle\")\r\n+CollisionChannelRedirects=(OldName=\"PawnMovement\",NewName=\"Pawn\")\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Config/DefaultEngine.ini b/Config/DefaultEngine.ini
--- a/Config/DefaultEngine.ini	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Config/DefaultEngine.ini	(date 1720720075367)
@@ -149,3 +149,9 @@
 +CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
 +CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")
 
+
+[CoreRedirects]
++PropertyRedirects=(OldName="/Script/FIM.SAttributeSet.AttackPower",NewName="/Script/FIM.SAttributeSet.n_BAISC_DP")
++PropertyRedirects=(OldName="/Script/FIM.SAttributeSet.Level",NewName="/Script/FIM.SAttributeSet.LV")
++PropertyRedirects=(OldName="/Script/FIM.SAttributeSet.MaxLevel",NewName="/Script/FIM.SAttributeSet.MaxPlayerLevel")
++PropertyRedirects=(OldName="/Script/FIM.SAttributeSet.PlayerLevel",NewName="/Script/FIM.SAttributeSet.LV")
\ No newline at end of file
Index: Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*---------------------------------------------------------------------------*/\r\n/*                                                                           */\r\n/* SimpleSocket.h - Simple Socket base class decleration.                    */\r\n/*                                                                           */\r\n/* Author : Mark Carrier (mark@carrierlabs.com)                              */\r\n/*                                                                           */\r\n/*---------------------------------------------------------------------------*/\r\n/* Copyright (c) 2007-2009 CarrierLabs, LLC.  All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions\r\n * are met:\r\n *\r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n *\r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in\r\n *    the documentation and/or other materials provided with the\r\n *    distribution.\r\n *\r\n * 3. The name of the author may not be used to endorse or promote products\r\n *    derived from this software without specific prior written permission.\r\n *\r\n * 4. The name \"CarrierLabs\" must not be used to\r\n *    endorse or promote products derived from this software without\r\n *    prior written permission. For written permission, please contact\r\n *    mark@carrierlabs.com.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY MARK CARRIER ``AS IS'' AND ANY\r\n * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL MARK CARRIER OR\r\n * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\r\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\r\n * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED\r\n * OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *----------------------------------------------------------------------------*/\r\n#ifndef __SOCKET_H__\r\n#define __SOCKET_H__\r\n\r\n#include <sys/stat.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <stdarg.h>\r\n#include <errno.h>\r\n\r\n#if defined(__linux__) || defined (_DARWIN)\r\n#include <sys/socket.h>\r\n#include <netinet/in.h>\r\n#include <arpa/inet.h>\r\n#include <netinet/tcp.h>\r\n#include <netinet/ip.h>\r\n#include <netdb.h>\r\n#endif\r\n#ifdef __linux__\r\n#include <linux/if_packet.h>\r\n#include <linux/if_ether.h>\r\n#include <linux/if.h>\r\n#include <sys/sendfile.h>\r\n#endif\r\n#ifdef _DARWIN\r\n#include <net/if.h>\r\n#endif\r\n#if defined(__linux__) || defined (_DARWIN)\r\n#include <sys/time.h>\r\n#include <sys/uio.h>\r\n#include <unistd.h>\r\n#include <fcntl.h>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#pragma warning( push )\r\n#pragma warning( disable:4668 )\r\n\t#include <io.h>\r\n\t#include <winsock2.h>\r\n\t#include <Ws2tcpip.h>\r\n#pragma warning( pop )\r\n\r\n#define IPTOS_LOWDELAY  0x10\r\n\r\n#endif\r\n#include \"Host.h\"\r\n#include \"StatTimer.h\"\r\n\r\n//-----------------------------------------------------------------------------\r\n// General class macro definitions and typedefs\r\n//-----------------------------------------------------------------------------\r\n#ifndef INVALID_SOCKET\r\n#define INVALID_SOCKET    ~(0)\r\n#endif\r\n\r\n#define SOCKET_SENDFILE_BLOCKSIZE 8192\r\n\r\n/// Provides a platform independent class to for socket development.\r\n/// This class is designed to abstract socket communication development in a\r\n/// platform independent manner.\r\n/// - Socket types\r\n///  -# CActiveSocket Class\r\n///  -# CPassiveSocket Class\r\nclass CSimpleSocket {\r\npublic:\r\n    /// Defines the three possible states for shuting down a socket.\r\n    typedef enum\r\n    {\r\n        Receives = SHUT_RD, ///< Shutdown passive socket.\r\n        Sends = SHUT_WR,    ///< Shutdown active socket.\r\n        Both = SHUT_RDWR    ///< Shutdown both active and passive sockets.\r\n    } CShutdownMode;\r\n\r\n    /// Defines the socket types defined by CSimpleSocket class.\r\n    typedef enum\r\n    {\r\n        SocketTypeInvalid,   ///< Invalid socket type.\r\n        SocketTypeTcp,       ///< Defines socket as TCP socket.\r\n        SocketTypeUdp,       ///< Defines socket as UDP socket.\r\n        SocketTypeTcp6,      ///< Defines socket as IPv6 TCP socket.\r\n        SocketTypeUdp6,      ///< Defines socket as IPv6 UDP socket.\r\n        SocketTypeRaw        ///< Provides raw network protocol access.\r\n    } CSocketType;\r\n\r\n    /// Defines all error codes handled by the CSimpleSocket class.\r\n    typedef enum\r\n    {\r\n        SocketError = -1,          ///< Generic socket error translates to error below.\r\n        SocketSuccess = 0,         ///< No socket error.\r\n        SocketInvalidSocket,       ///< Invalid socket handle.\r\n        SocketInvalidAddress,      ///< Invalid destination address specified.\r\n        SocketInvalidPort,         ///< Invalid destination port specified.\r\n        SocketConnectionRefused,   ///< No server is listening at remote address.\r\n        SocketTimedout,            ///< Timed out while attempting operation.\r\n        SocketEwouldblock,         ///< Operation would block if socket were blocking.\r\n        SocketNotconnected,        ///< Currently not connected.\r\n        SocketEinprogress,         ///< Socket is non-blocking and the connection cannot be completed immediately\r\n        SocketInterrupted,         ///< Call was interrupted by a signal that was caught before a valid connection arrived.\r\n        SocketConnectionAborted,   ///< The connection has been aborted.\r\n        SocketProtocolError,       ///< Invalid protocol for operation.\r\n        SocketFirewallError,       ///< Firewall rules forbid connection.\r\n        SocketInvalidSocketBuffer, ///< The receive buffer point outside the process's address space.\r\n        SocketConnectionReset,     ///< Connection was forcibly closed by the remote host.\r\n        SocketAddressInUse,        ///< Address already in use.\r\n        SocketInvalidPointer,      ///< Pointer type supplied as argument is invalid.\r\n        SocketEunknown             ///< Unknown error please report to mark@carrierlabs.com\r\n    } CSocketError;\r\n\r\npublic:\r\n    CSimpleSocket(CSocketType type = SocketTypeTcp);\r\n    CSimpleSocket(CSimpleSocket &socket);\r\n\r\n    CSimpleSocket(CSimpleSocket &&socket) noexcept = default;\r\n    CSimpleSocket& operator=(CSimpleSocket &&socket) noexcept = default;\r\n\r\n    virtual ~CSimpleSocket()\r\n    {\r\n        if (m_pBuffer != NULL)\r\n        {\r\n            delete [] m_pBuffer;\r\n            m_pBuffer = NULL;\r\n        }\r\n    };\r\n\r\n    /// Initialize instance of CSocket.  This method MUST be called before an\r\n    /// object can be used. Errors : CSocket::SocketProtocolError,\r\n    /// CSocket::SocketInvalidSocket,\r\n    /// @return true if properly initialized.\r\n    virtual bool Initialize(void);\r\n\r\n    /// Close socket\r\n    /// @return true if successfully closed otherwise returns false.\r\n    virtual bool Close(void);\r\n\r\n    /// Shutdown shut down socket send and receive operations\r\n    ///    CShutdownMode::Receives - Disables further receive operations.\r\n    ///    CShutdownMode::Sends    - Disables further send operations.\r\n    ///    CShutdownBoth::         - Disables further send and receive operations.\r\n    /// @param nShutdown specifies the type of shutdown.\r\n    /// @return true if successfully shutdown otherwise returns false.\r\n    virtual bool Shutdown(CShutdownMode nShutdown);\r\n\r\n    /// Examine the socket descriptor sets currently owned by the instance of\r\n    /// the socket class (the readfds, writefds, and errorfds parameters) to\r\n    /// see whether some of their descriptors are ready for reading, are ready\r\n    /// for writing, or have an exceptional condition pending, respectively.\r\n    /// Block until an event happens on the specified file descriptors.\r\n    /// @return true if socket has data ready, or false if not ready or timed out.\r\n    virtual bool Select(void) {\r\n        return Select(0,0);\r\n    };\r\n\r\n    /// Examine the socket descriptor sets currently owned by the instance of\r\n    /// the socket class (the readfds, writefds, and errorfds parameters) to\r\n    /// see whether some of their descriptors are ready for reading, are ready\r\n    /// for writing, or have an exceptional condition pending, respectively.\r\n    /// @param nTimeoutSec timeout in seconds for select.\r\n    /// @param nTimeoutUSec timeout in micro seconds for select.\r\n    /// @return true if socket has data ready, or false if not ready or timed out.\r\n    virtual bool Select(int32_t nTimeoutSec, int32_t nTimeoutUSec);\r\n\r\n    /// Does the current instance of the socket object contain a valid socket\r\n    /// descriptor.\r\n    ///  @return true if the socket object contains a valid socket descriptor.\r\n    virtual bool IsSocketValid(void) {\r\n        return (m_socket != static_cast<SOCKET>(SocketError));\r\n    };\r\n\r\n    /// Provides a standard error code for cross platform development by\r\n    /// mapping the operating system error to an error defined by the CSocket\r\n    /// class.\r\n    void TranslateSocketError(void);\r\n\r\n    /// Returns a human-readable description of the given error code\r\n    /// or the last error code of a socket\r\n    static const char *DescribeError(CSocketError err);\r\n    inline const char *DescribeError() {\r\n        return DescribeError(m_socketErrno);\r\n    };\r\n\r\n    /// Attempts to receive a block of data on an established connection.\r\n    /// @param nMaxBytes maximum number of bytes to receive.\r\n    /// @param pBuffer, memory where to receive the data,\r\n    ///        NULL receives to internal buffer returned with GetData()\r\n    ///        Non-NULL receives directly there, but GetData() will return WRONG ptr!\r\n    /// @return number of bytes actually received.\r\n    /// @return of zero means the connection has been shutdown on the other side.\r\n    /// @return of -1 means that an error has occurred.\r\n    virtual int32_t Receive(int32_t nMaxBytes = 1, uint8_t * pBuffer = 0);\r\n\r\n    /// Attempts to send a block of data on an established connection.\r\n    /// @param pBuf block of data to be sent.\r\n    /// @param bytesToSend size of data block to be sent.\r\n    /// @return number of bytes actually sent.\r\n    /// @return of zero means the connection has been shutdown on the other side.\r\n    /// @return of -1 means that an error has occurred.\r\n    virtual int32_t Send(const uint8_t *pBuf, size_t bytesToSend);\r\n\r\n    /// Attempts to send at most nNumItem blocks described by sendVector\r\n    /// to the socket descriptor associated with the socket object.\r\n    /// @param sendVector pointer to an array of iovec structures\r\n    /// @param nNumItems number of items in the vector to process\r\n    /// <br>\\b NOTE: Buffers are processed in the order specified.\r\n    /// @return number of bytes actually sent, return of zero means the\r\n    /// connection has been shutdown on the other side, and a return of -1\r\n    /// means that an error has occurred.\r\n    virtual int32_t Send(const struct iovec *sendVector, int32_t nNumItems);\r\n\r\n    /// Copies data between one file descriptor and another.\r\n    /// On some systems this copying is done within the kernel, and thus is\r\n    /// more efficient than the combination of CSimpleSocket::Send and\r\n    /// CSimpleSocket::Receive, which would require transferring data to and\r\n    /// from user space.\r\n    /// <br>\\b Note: This is available on all implementations, but the kernel\r\n    /// implementation is only available on Unix type systems.\r\n    /// @param nOutFd descriptor opened for writing.\r\n    /// @param nInFd descriptor opened for reading.\r\n    /// @param pOffset from which to start reading data from input file.\r\n    /// @param nCount number of bytes to copy between file descriptors.\r\n    /// @return number of bytes written to the out socket descriptor.\r\n    virtual int32_t SendFile(int32_t nOutFd, int32_t nInFd, off_t *pOffset, int32_t nCount);\r\n\r\n    /// Returns blocking/non-blocking state of socket.\r\n    /// @return true if the socket is non-blocking, else return false.\r\n    bool IsNonblocking(void) {\r\n        return (m_bIsBlocking == false);\r\n    };\r\n\r\n    /// Set the socket to blocking.\r\n    /// @return true if successful set to blocking, else return false;\r\n    bool SetBlocking(void);\r\n\r\n    /// Set the socket as non-blocking.\r\n    /// @return true if successful set to non-blocking, else return false;\r\n    bool SetNonblocking(void);\r\n\r\n    /// Get a pointer to internal receive buffer.  The user MUST not free this\r\n    /// pointer when finished.  This memory is managed internally by the CSocket\r\n    /// class.\r\n    /// @return pointer to data if valid, else returns NULL.\r\n    uint8_t *GetData(void)  {\r\n        return m_pBuffer;\r\n    };\r\n\r\n    /// Returns the number of bytes received on the last call to\r\n    /// CSocket::Receive().\r\n    /// @return number of bytes received.\r\n    int32_t GetBytesReceived(void) {\r\n        return m_nBytesReceived;\r\n    };\r\n\r\n    /// Returns the number of bytes sent on the last call to\r\n    /// CSocket::Send().\r\n    /// @return number of bytes sent.\r\n    int32_t GetBytesSent(void) {\r\n        return m_nBytesSent;\r\n    };\r\n\r\n    /// Controls the actions taken when CSimpleSocket::Close is executed on a\r\n    /// socket object that has unsent data.  The default value for this option\r\n    /// is \\b off.\r\n    /// - Following are the three possible scenarios.\r\n    ///  -# \\b bEnable is false, CSimpleSocket::Close returns immediately, but\r\n    ///  any unset data is transmitted (after CSimpleSocket::Close returns)\r\n    ///  -# \\b bEnable is true and \\b nTime is zero, CSimpleSocket::Close return\r\n    /// immediately and any unsent data is discarded.\r\n    ///  -# \\b bEnable is true and \\b nTime is nonzero, CSimpleSocket::Close does\r\n    ///  not return until all unsent data is transmitted (or the connection is\r\n    ///  Closed by the remote system).\r\n    /// <br><p>\r\n    /// @param bEnable true to enable option false to disable option.\r\n    /// @param nTime time in seconds to linger.\r\n    /// @return true if option successfully set\r\n    bool SetOptionLinger(bool bEnable, uint16_t nTime);\r\n\r\n    /// Tells the kernel that even if this port is busy (in the TIME_WAIT state),\r\n    /// go ahead and reuse it anyway.  If it is busy, but with another state,\r\n    /// you will still get an address already in use error.\r\n    /// @return true if option successfully set\r\n    bool SetOptionReuseAddr();\r\n\r\n    /// Gets the timeout value that specifies the maximum number of seconds a\r\n    /// call to CSimpleSocket::Open waits until it completes.\r\n    /// @return the length of time in seconds\r\n    int32_t GetConnectTimeoutSec(void) {\r\n        return  m_stConnectTimeout.tv_sec;\r\n    };\r\n\r\n    /// Gets the timeout value that specifies the maximum number of microseconds\r\n    /// a call to CSimpleSocket::Open waits until it completes.\r\n    /// @return the length of time in microseconds\r\n    int32_t GetConnectTimeoutUSec(void) {\r\n        return  m_stConnectTimeout.tv_usec;\r\n    };\r\n\r\n    /// Sets the timeout value that specifies the maximum amount of time a call\r\n    /// to CSimpleSocket::Receive waits until it completes. Use the method\r\n    /// CSimpleSocket::SetReceiveTimeout to specify the number of seconds to wait.\r\n    /// If a call to CSimpleSocket::Receive has blocked for the specified length of\r\n    /// time without receiving additional data, it returns with a partial count\r\n    /// or CSimpleSocket::GetSocketError set to CSimpleSocket::SocketEwouldblock if no data\r\n    /// were received.\r\n    /// @param nConnectTimeoutSec of timeout in seconds.\r\n    /// @param nConnectTimeoutUsec of timeout in microseconds.\r\n    /// @return true if socket connection timeout was successfully set.\r\n    void SetConnectTimeout(int32_t nConnectTimeoutSec, int32_t nConnectTimeoutUsec = 0)\r\n    {\r\n        m_stConnectTimeout.tv_sec = nConnectTimeoutSec;\r\n        m_stConnectTimeout.tv_usec = nConnectTimeoutUsec;\r\n    };\r\n\r\n    /// Gets the timeout value that specifies the maximum number of seconds a\r\n    /// a call to CSimpleSocket::Receive waits until it completes.\r\n    /// @return the length of time in seconds\r\n    int32_t GetReceiveTimeoutSec(void) {\r\n        return  m_stRecvTimeout.tv_sec;\r\n    };\r\n\r\n    /// Gets the timeout value that specifies the maximum number of microseconds\r\n    /// a call to CSimpleSocket::Receive waits until it completes.\r\n    /// @return the length of time in microseconds\r\n    int32_t GetReceiveTimeoutUSec(void) {\r\n        return  m_stRecvTimeout.tv_usec;\r\n    };\r\n\r\n    /// Sets the timeout value that specifies the maximum amount of time a call\r\n    /// to CSimpleSocket::Receive waits until it completes. Use the method\r\n    /// CSimpleSocket::SetReceiveTimeout to specify the number of seconds to wait.\r\n    /// If a call to CSimpleSocket::Receive has blocked for the specified length of\r\n    /// time without receiving additional data, it returns with a partial count\r\n    /// or CSimpleSocket::GetSocketError set to CSimpleSocket::SocketEwouldblock if no data\r\n    /// were received.\r\n    ///  @param nRecvTimeoutSec of timeout in seconds.\r\n    ///  @param nRecvTimeoutUsec of timeout in microseconds.\r\n    ///  @return true if socket timeout was successfully set.\r\n    bool SetReceiveTimeout(int32_t nRecvTimeoutSec, int32_t nRecvTimeoutUsec = 0);\r\n\r\n    /// Enable/disable multicast for a socket.  This options is only valid for\r\n    /// socket descriptors of type CSimpleSocket::SocketTypeUdp.\r\n    /// @return true if multicast was enabled or false if socket type is not\r\n    /// CSimpleSocket::SocketTypeUdp and the error will be set to\r\n    /// CSimpleSocket::SocketProtocolError\r\n    bool SetMulticast(bool bEnable, uint8_t multicastTTL = 1);\r\n\r\n    /// Return true if socket is multicast or false is socket is unicast\r\n    /// @return true if multicast is enabled\r\n    bool GetMulticast() {\r\n        return m_bIsMulticast;\r\n    };\r\n\r\n    /// Bind socket to a specific interface when using multicast.\r\n    /// @return true if successfully bound to interface\r\n    bool BindInterface(const char *pInterface);\r\n\r\n    /// Gets the timeout value that specifies the maximum number of seconds a\r\n    /// a call to CSimpleSocket::Send waits until it completes.\r\n    /// @return the length of time in seconds\r\n    int32_t GetSendTimeoutSec(void) {\r\n        return  m_stSendTimeout.tv_sec;\r\n    };\r\n\r\n    /// Gets the timeout value that specifies the maximum number of microseconds\r\n    /// a call to CSimpleSocket::Send waits until it completes.\r\n    /// @return the length of time in microseconds\r\n    int32_t GetSendTimeoutUSec(void) {\r\n        return  m_stSendTimeout.tv_usec;\r\n    };\r\n\r\n    /// Gets the timeout value that specifies the maximum amount of time a call\r\n    /// to CSimpleSocket::Send waits until it completes.\r\n    /// @return the length of time in seconds\r\n    bool SetSendTimeout(int32_t nSendTimeoutSec, int32_t nSendTimeoutUsec = 0);\r\n\r\n    /// Returns the last error that occured for the instace of the CSimpleSocket\r\n    /// instance.  This method should be called immediately to retrieve the\r\n    /// error code for the failing mehtod call.\r\n    ///  @return last error that occured.\r\n    CSocketError GetSocketError(void) {\r\n        return m_socketErrno;\r\n    };\r\n\r\n    /// Get the total time the of the last operation in milliseconds.\r\n    ///  @return number of milliseconds of last operation.\r\n    uint32_t GetTotalTimeMs() {\r\n        return m_timer.GetMilliSeconds();\r\n    };\r\n\r\n    /// Get the total time the of the last operation in microseconds.\r\n    ///  @return number of microseconds or last operation.\r\n    uint32_t GetTotalTimeUsec() {\r\n        return m_timer.GetMicroSeconds();\r\n    };\r\n\r\n    /// Return Differentiated Services Code Point (DSCP) value currently set on the socket object.\r\n    /// @return DSCP for current socket object.\r\n    /// <br><br> \\b NOTE: Windows special notes http://support.microsoft.com/kb/248611.\r\n    int GetSocketDscp(void);\r\n\r\n    /// Set Differentiated Services Code Point (DSCP) for socket object.\r\n    ///  @param nDscp value of TOS setting which will be converted to DSCP\r\n    ///  @return true if DSCP value was properly set\r\n    /// <br><br> \\b NOTE: Windows special notes http://support.microsoft.com/kb/248611.\r\n    bool SetSocketDscp(int nDscp);\r\n\r\n    /// Return socket descriptor\r\n    ///  @return socket descriptor which is a signed 32 bit integer.\r\n    SOCKET GetSocketDescriptor() {\r\n        return m_socket;\r\n    };\r\n\r\n    /// Return socket descriptor\r\n    ///  @return socket descriptor which is a signed 32 bit integer.\r\n    CSocketType GetSocketType() {\r\n        return m_nSocketType;\r\n    };\r\n\r\n    /// Returns clients Internet host address as a string in standard numbers-and-dots notation.\r\n    ///  @return NULL if invalid\r\n    const char *GetClientAddr() {\r\n        return inet_ntoa(m_stClientSockaddr.sin_addr);\r\n    };\r\n\r\n    /// Returns the port number on which the client is connected.\r\n    ///  @return client port number.\r\n    uint16_t GetClientPort() {\r\n        return m_stClientSockaddr.sin_port;\r\n    };\r\n\r\n    /// Returns server Internet host address as a string in standard numbers-and-dots notation.\r\n    ///  @return NULL if invalid\r\n    const char *GetServerAddr() {\r\n        return inet_ntoa(m_stServerSockaddr.sin_addr);\r\n    };\r\n\r\n    /// Returns the port number on which the server is connected.\r\n    ///  @return server port number.\r\n    uint16_t GetServerPort() {\r\n        return ntohs(m_stServerSockaddr.sin_port);\r\n    };\r\n\r\n    /// Get the TCP receive buffer window size for the current socket object.\r\n    /// <br><br>\\b NOTE: Linux will set the receive buffer to twice the value passed.\r\n    ///  @return zero on failure else the number of bytes of the TCP receive buffer window size if successful.\r\n    uint32_t GetReceiveWindowSize() {\r\n        return GetWindowSize(SO_RCVBUF);\r\n    };\r\n\r\n    /// Get the TCP send buffer window size for the current socket object.\r\n    /// <br><br>\\b NOTE: Linux will set the send buffer to twice the value passed.\r\n    ///  @return zero on failure else the number of bytes of the TCP receive buffer window size if successful.\r\n    uint32_t GetSendWindowSize() {\r\n        return GetWindowSize(SO_SNDBUF);\r\n    };\r\n\r\n    /// Set the TCP receive buffer window size for the current socket object.\r\n    /// <br><br>\\b NOTE: Linux will set the receive buffer to twice the value passed.\r\n    ///  @return zero on failure else the number of bytes of the TCP send buffer window size if successful.\r\n    uint32_t SetReceiveWindowSize(uint32_t nWindowSize) {\r\n        return SetWindowSize(SO_RCVBUF, nWindowSize);\r\n    };\r\n\r\n    /// Set the TCP send buffer window size for the current socket object.\r\n    /// <br><br>\\b NOTE: Linux will set the send buffer to twice the value passed.\r\n    ///  @return zero on failure else the number of bytes of the TCP send buffer window size if successful.\r\n    uint32_t SetSendWindowSize(uint32_t nWindowSize) {\r\n        return SetWindowSize(SO_SNDBUF, nWindowSize);\r\n    };\r\n\r\n    /// Disable the Nagle algorithm (Set TCP_NODELAY to true)\r\n    /// @return false if failed to set socket option otherwise return true;\r\n    bool DisableNagleAlgoritm();\r\n\r\n    /// Enable the Nagle algorithm (Set TCP_NODELAY to false)\r\n    /// @return false if failed to set socket option otherwise return true;\r\n    bool EnableNagleAlgoritm();\r\n\r\n\r\n    /// Flush the socket descriptor owned by the object.\r\n    /// @return true data was successfully sent, else return false;\r\n    bool Flush();\r\n\r\nprotected:\r\n    /// Set internal socket error to that specified error\r\n    ///  @param error type of error\r\n    void SetSocketError(CSimpleSocket::CSocketError error) {\r\n        m_socketErrno = error;\r\n    };\r\n\r\n    /// Set object socket handle to that specified as parameter\r\n    ///  @param socket value of socket descriptor\r\n    void SetSocketHandle(SOCKET socket) {\r\n        m_socket = socket;\r\n    };\r\n\r\nprivate:\r\n    /// Generic function used to get the send/receive window size\r\n    ///  @return zero on failure else the number of bytes of the TCP window size if successful.\r\n    uint32_t GetWindowSize(uint32_t nOptionName);\r\n\r\n    /// Generic function used to set the send/receive window size\r\n    ///  @return zero on failure else the number of bytes of the TCP window size if successful.\r\n    uint32_t SetWindowSize(uint32_t nOptionName, uint32_t nWindowSize);\r\n\r\n\r\n    /// Attempts to send at most nNumItem blocks described by sendVector\r\n    /// to the socket descriptor associated with the socket object.\r\n    /// @param sendVector pointer to an array of iovec structures\r\n    /// @param nNumItems number of items in the vector to process\r\n    /// <br>\\b Note: This implementation is for systems that don't natively\r\n    /// support this functionality.\r\n    /// @return number of bytes actually sent, return of zero means the\r\n    /// connection has been shutdown on the other side, and a return of -1\r\n    /// means that an error has occurred.\r\n    int32_t Writev(const struct iovec *pVector, size_t nCount);\r\n\r\n    CSimpleSocket *operator=(CSimpleSocket &socket);\r\n\r\nprotected:\r\n    SOCKET               m_socket;            /// socket handle\r\n    CSocketError         m_socketErrno;       /// number of last error\r\n    uint8_t               *m_pBuffer;           /// internal send/receive buffer\r\n    int32_t                m_nBufferSize;       /// size of internal send/receive buffer\r\n    int32_t                m_nSocketDomain;     /// socket type PF_INET, PF_INET6\r\n    CSocketType          m_nSocketType;       /// socket type - UDP, TCP or RAW\r\n    int32_t                m_nBytesReceived;    /// number of bytes received\r\n    int32_t                m_nBytesSent;        /// number of bytes sent\r\n    uint32_t               m_nFlags;            /// socket flags\r\n    bool                 m_bIsBlocking;       /// is socket blocking\r\n    bool                 m_bIsMulticast;      /// is the UDP socket multicast;\r\n    struct timeval       m_stConnectTimeout;  /// connection timeout\r\n    struct timeval       m_stRecvTimeout;     /// receive timeout\r\n    struct timeval       m_stSendTimeout;     /// send timeout\r\n    struct sockaddr_in   m_stServerSockaddr;  /// server address\r\n    struct sockaddr_in   m_stClientSockaddr;  /// client address\r\n    struct sockaddr_in   m_stMulticastGroup;  /// multicast group to bind to\r\n    struct linger        m_stLinger;          /// linger flag\r\n    CStatTimer           m_timer;             /// internal statistics.\r\n#ifdef _WIN32\r\n    WSADATA              m_hWSAData;          /// Windows\r\n#endif\r\n    fd_set               m_writeFds;          /// write file descriptor set\r\n    fd_set               m_readFds;           /// read file descriptor set\r\n    fd_set               m_errorFds;          /// error file descriptor set\r\n};\r\n\r\n\r\n#endif /*  __SOCKET_H__  */\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.h b/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.h
--- a/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.h	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.h	(date 1720720014127)
@@ -276,7 +276,7 @@
     bool SetNonblocking(void);
 
     /// Get a pointer to internal receive buffer.  The user MUST not free this
-    /// pointer when finished.  This memory is managed internally by the CSocket
+    /// pointer when finished.  This memory is n_BASIC_MPged internally by the CSocket
     /// class.
     /// @return pointer to data if valid, else returns NULL.
     uint8_t *GetData(void)  {
Index: Plugins/Developer/RiderLink/Source/RiderLink/Private/ProtocolFactory.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ProtocolFactory.h\"\r\n\r\n#include \"scheduler/base/IScheduler.h\"\r\n#include \"wire/SocketWire.h\"\r\n\r\n#include \"Runtime/Launch/Resources/Version.h\"\r\n\r\n#if ENGINE_MAJOR_VERSION >= 5\r\n#include \"HAL/PlatformFileManager.h\"\r\n#else\r\n#include \"HAL/PlatformFilemanager.h\"\r\n#endif\r\n#include \"Misc/App.h\"\r\n#include \"Misc/FileHelper.h\"\r\n#include \"Misc/Paths.h\"\r\n\r\n#if PLATFORM_WINDOWS\r\n// ReSharper disable once CppUnusedIncludeDirective\r\n#include \"Windows/AllowWindowsPlatformTypes.h\"\r\n#include \"Windows/PreWindowsApi.h\"\r\n\r\n#include \"Windows/WindowsPlatformMisc.h\"\r\n\r\n#include \"Windows/PostWindowsApi.h\"\r\n// ReSharper disable once CppUnusedIncludeDirective\r\n#include \"Windows/HideWindowsPlatformTypes.h\"\r\n#endif\r\n\r\n#include \"spdlog/sinks/daily_file_sink.h\"\r\n\r\nstatic FString GetLocalAppdataFolder()\r\n{\r\n    const FString EnvironmentVarName =\r\n#if PLATFORM_WINDOWS\r\nTEXT(\"LOCALAPPDATA\");\r\n#else\r\n    TEXT(\"HOME\");\r\n#endif\r\n#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 20\r\n    TCHAR CAppDataLocalPath[4096];\r\n    FPlatformMisc::GetEnvironmentVariable(*EnvironmentVarName, CAppDataLocalPath, ARRAY_COUNT(CAppDataLocalPath));\r\n    return CAppDataLocalPath;\r\n#else\r\n    return FPlatformMisc::GetEnvironmentVariable(*EnvironmentVarName);\r\n#endif\r\n}\r\n\r\nstatic FString GetMiscFilesFolder()\r\n{    \r\n    FString FAppDataLocalPath = GetLocalAppdataFolder();\r\n    FPaths::NormalizeFilename(FAppDataLocalPath);\r\n    return FPaths::Combine(*FAppDataLocalPath,\r\n#if PLATFORM_WINDOWS\r\n        TEXT(\"Jetbrains\"), TEXT(\"Rider\"), TEXT(\"Unreal\")\r\n#elif PLATFORM_MAC\r\n        TEXT(\"Library\"), TEXT(\"Logs\"), TEXT(\"Unreal Engine\")\r\n#else\r\n        TEXT(\".config\"), TEXT(\"unrealEngine\")\r\n#endif\r\n    );\r\n}\r\n\r\nstatic FString GetPathToPortsFolder()\r\n{\r\n    const FString MiscFilesFolder = GetMiscFilesFolder();\r\n    return FPaths::Combine(*MiscFilesFolder, TEXT(\"Ports\"));\r\n}\r\n\r\nstatic FString GetLogFile(const FString& projectName)\r\n{\r\n    const FString MiscFilesFolder = GetMiscFilesFolder();\r\n    return FPaths::Combine(*MiscFilesFolder, TEXT(\"Logs\"), projectName + TEXT(\".uproject\"));\r\n}\r\n\r\nProtocolFactory::ProtocolFactory(const FString& ProjectName): ProjectName(ProjectName)\r\n{\r\n    InitRdLogging();\r\n}\r\n\r\nvoid ProtocolFactory::InitRdLogging()\r\n{\r\n    spdlog::set_level(spdlog::level::err);\r\n#if defined(ENABLE_LOG_FILE) && ENABLE_LOG_FILE == 1\r\n    const FString LogFile = GetLogFile(ProjectName);\r\n    const FString Msg = TEXT(\"[RiderLink] Path to log file: \") + LogFile;\r\n    auto FileLogger = std::make_shared<spdlog::sinks::daily_file_sink_mt>(*LogFile, 23, 59);\r\n    FileLogger->set_level(spdlog::level::trace);\r\n    spdlog::apply_all([FileLogger](std::shared_ptr<spdlog::logger> Logger)\r\n    {\r\n        Logger->sinks().push_back(FileLogger);\r\n    });\r\n#endif\r\n}\r\n\r\nstd::shared_ptr<rd::SocketWire::Server> ProtocolFactory::CreateWire(rd::IScheduler* Scheduler, rd::Lifetime SocketLifetime)\r\n{\r\n    return std::make_shared<rd::SocketWire::Server>(SocketLifetime, Scheduler, 0,\r\n                                                         TCHAR_TO_UTF8(*FString::Printf(TEXT(\"UnrealEditorServer-%s\"),\r\n                                                             *ProjectName)));\r\n}\r\n\r\n\r\nTUniquePtr<rd::Protocol> ProtocolFactory::CreateProtocol(rd::IScheduler* Scheduler, rd::Lifetime SocketLifetime, std::shared_ptr<rd::SocketWire::Server> wire)\r\n{\r\n    auto protocol = MakeUnique<rd::Protocol>(rd::Identities::SERVER, Scheduler, wire, SocketLifetime);\r\n\r\n    auto& PlatformFile = FPlatformFileManager::Get().GetPlatformFile();\r\n    const FString PortFullDirectoryPath = GetPathToPortsFolder();\r\n    if (PlatformFile.CreateDirectoryTree(*PortFullDirectoryPath) && !IsRunningCommandlet())\r\n    {\r\n        const FString ProjectFileName = ProjectName + TEXT(\".uproject\");\r\n        const FString TmpPortFile = TEXT(\"~\") + ProjectFileName;\r\n        const FString TmpPortFileFullPath = FPaths::Combine(*PortFullDirectoryPath, *TmpPortFile);\r\n        FFileHelper::SaveStringToFile(FString::FromInt(wire->port), *TmpPortFileFullPath);\r\n        const FString PortFileFullPath = FPaths::Combine(*PortFullDirectoryPath, *ProjectFileName);\r\n        IFileManager::Get().Move(*PortFileFullPath, *TmpPortFileFullPath, true, true);\r\n    }\r\n    return protocol;\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RiderLink/Private/ProtocolFactory.cpp b/Plugins/Developer/RiderLink/Source/RiderLink/Private/ProtocolFactory.cpp
--- a/Plugins/Developer/RiderLink/Source/RiderLink/Private/ProtocolFactory.cpp	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RiderLink/Private/ProtocolFactory.cpp	(date 1720351857291)
@@ -8,7 +8,7 @@
 #if ENGINE_MAJOR_VERSION >= 5
 #include "HAL/PlatformFileManager.h"
 #else
-#include "HAL/PlatformFilemanager.h"
+#include "HAL/PlatformFileManager.h"
 #endif
 #include "Misc/App.h"
 #include "Misc/FileHelper.h"
Index: Source/FIM/Public/SAttributeSet.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n#pragma once\r\n\r\n#include \"CoreMinimal.h\"\r\n#include \"AttributeSet.h\"\r\n#include \"AbilitySystemComponent.h\"\r\n#include \"SAttributeSet.generated.h\"\r\n\r\n//Uses macros from AttributeSet.h\r\n#define ATTRIBUTE_ACCESSORS(ClassName, PropertyName) \\\r\n GAMEPLAYATTRIBUTE_PROPERTY_GETTER(ClassName, PropertyName) \\\r\n GAMEPLAYATTRIBUTE_VALUE_GETTER(PropertyName) \\\r\n GAMEPLAYATTRIBUTE_VALUE_SETTER(PropertyName) \\\r\n GAMEPLAYATTRIBUTE_VALUE_INITTER(PropertyName)\r\n\r\n/**\r\n Basic setting for player attributes.\r\n */\r\nUCLASS()\r\nclass FIM_API USAttributeSet : public UAttributeSet\r\n{\r\n\tGENERATED_BODY()\r\n\r\npublic:\r\n\r\n\tUSAttributeSet();\r\n\r\n\tvoid PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data) override;\r\n\r\n\tvirtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;\r\n\r\n\t//Health\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Attributes\"/*, ReplicatedUsing = OnRep_Health*/)\r\n\t\tFGameplayAttributeData Health;\r\n\tATTRIBUTE_ACCESSORS(USAttributeSet, Health);\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Attributes\"/*, ReplicatedUsing = OnRep_Health*/)\r\n\t\tFGameplayAttributeData MaxHealth;\r\n\tATTRIBUTE_ACCESSORS(USAttributeSet, MaxHealth);\r\n\r\n\tUFUNCTION()\r\n\t\tvirtual void OnRep_Health(const FGameplayAttributeData& OldHealth);\r\n\r\n\t//Mana\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Attributes\"/*, ReplicatedUsing = OnRep_Mana*/)\r\n\t\tFGameplayAttributeData Mana;\r\n\tATTRIBUTE_ACCESSORS(USAttributeSet, Mana);\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Attributes\"/*, ReplicatedUsing = OnRep_Mana*/)\r\n\t\tFGameplayAttributeData MaxMana;\r\n\tATTRIBUTE_ACCESSORS(USAttributeSet, MaxMana);\r\n\r\n\tUFUNCTION()\r\n\t\tvirtual void OnRep_Mana(const FGameplayAttributeData& OldMana);\r\n\r\n\t//Stamina\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Attributes\"/*, ReplicatedUsing = OnRep_Stamina*/)\r\n\t\tFGameplayAttributeData Stamina;\r\n\tATTRIBUTE_ACCESSORS(USAttributeSet, Stamina);\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Attributes\"/*, ReplicatedUsing = OnRep_Stamina*/)\r\n\t\tFGameplayAttributeData MaxStamina;\r\n\tATTRIBUTE_ACCESSORS(USAttributeSet, MaxStamina);\r\n\r\n\tUFUNCTION()\r\n\t\tvirtual void OnRep_Stamina(const FGameplayAttributeData& OldStamina);\r\n\r\n\t//Attack Power\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Attributes\", ReplicatedUsing = OnRep_AttackPower)\r\n\t\tFGameplayAttributeData AttackPower;\r\n\tATTRIBUTE_ACCESSORS(USAttributeSet, AttackPower);\r\n\r\n\tUPROPERTY(EditAnywhere, BlueprintReadOnly, Category = \"Attributes\", ReplicatedUsing = OnRep_AttackPower)\r\n\t\tFGameplayAttributeData MaxAttackPower;\r\n\tATTRIBUTE_ACCESSORS(USAttributeSet, MaxAttackPower);\r\n\r\n\tUFUNCTION()\r\n\t\tvirtual void OnRep_AttackPower(const FGameplayAttributeData& OldAttackPower);\r\n\r\n};\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FIM/Public/SAttributeSet.h b/Source/FIM/Public/SAttributeSet.h
--- a/Source/FIM/Public/SAttributeSet.h	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Source/FIM/Public/SAttributeSet.h	(date 1721055877613)
@@ -23,59 +23,153 @@
 	GENERATED_BODY()
 
 public:
-
 	USAttributeSet();
 
 	void PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data) override;
 
 	virtual void GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const override;
 
-	//Health
-	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_Health*/)
-		FGameplayAttributeData Health;
-	ATTRIBUTE_ACCESSORS(USAttributeSet, Health);
+	//n_BASIC_HP
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_n_BASIC_HP*/)
+	FGameplayAttributeData n_BASIC_HP;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_BASIC_HP);
+
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_n_BASIC_HP*/)
+	FGameplayAttributeData Maxn_BASIC_HP;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_BASIC_HP);
+
+	UFUNCTION()
+	virtual void OnRep_n_BASIC_HP(const FGameplayAttributeData& Oldn_BASIC_HP);
+
+	//n_BASIC_MP
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_n_BASIC_MP*/)
+	FGameplayAttributeData n_BASIC_MP;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_BASIC_MP);
+
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_n_BASIC_MP*/)
+	FGameplayAttributeData Maxn_BASIC_MP;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_BASIC_MP);
 
-	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_Health*/)
-		FGameplayAttributeData MaxHealth;
-	ATTRIBUTE_ACCESSORS(USAttributeSet, MaxHealth);
+	UFUNCTION()
+	virtual void OnRep_n_BASIC_MP(const FGameplayAttributeData& Oldn_BASIC_MP);
+
+	//n_BASIC_SP
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_n_BASIC_SP*/)
+	FGameplayAttributeData n_BASIC_SP;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_BASIC_SP);
+
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_n_BASIC_SP*/)
+	FGameplayAttributeData Maxn_BASIC_SP;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_BASIC_SP);
+
+	UFUNCTION()
+	virtual void OnRep_n_BASIC_SP(const FGameplayAttributeData& Oldn_BASIC_SP);
+
+	//n_BAISC_DP
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_BAISC_DP)
+	FGameplayAttributeData n_BAISC_DP;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_BAISC_DP);
+
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_BAISC_DP)
+	FGameplayAttributeData Maxn_BAISC_DP;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_BAISC_DP);
+
+	UFUNCTION()
+	virtual void OnRep_n_BAISC_DP(const FGameplayAttributeData& Oldn_BAISC_DP);
+
+	//n_LV
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_LV)
+	FGameplayAttributeData n_LV;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_LV);
+
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_LV)
+	FGameplayAttributeData Maxn_LV;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_LV);
+
+	UFUNCTION()
+	virtual void OnRep_n_LV(const FGameplayAttributeData& Oldn_LV);
+
+	//n_EXP
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_EXP)
+	FGameplayAttributeData n_EXP;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_EXP);
+
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_EXP)
+	FGameplayAttributeData Maxn_EXP;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_EXP);
+
+	UFUNCTION()
+	virtual void OnRep_n_EXP(const FGameplayAttributeData& Oldn_EXP);
+
+	//n_BAISC_DATK
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_BAISC_DATK)
+	FGameplayAttributeData n_BAISC_DATK;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_BAISC_DATK);
+
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_BAISC_DATK)
+	FGameplayAttributeData Maxn_BAISC_DATK;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_BAISC_DATK);
+
+	UFUNCTION()
+	virtual void OnRep_n_BAISC_DATK(const FGameplayAttributeData& Oldn_BAISC_DATK);
+	
+	//n_BAISC_DDEF
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_BAISC_DDEF)
+	FGameplayAttributeData n_BAISC_DDEF;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_BAISC_DDEF);
+
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_BAISC_DDEF)
+	FGameplayAttributeData Maxn_BAISC_DDEF;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_BAISC_DDEF);
 
 	UFUNCTION()
-		virtual void OnRep_Health(const FGameplayAttributeData& OldHealth);
+	virtual void OnRep_n_BAISC_DDEF(const FGameplayAttributeData& Oldn_BAISC_DDEF);
 
-	//Mana
-	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_Mana*/)
-		FGameplayAttributeData Mana;
-	ATTRIBUTE_ACCESSORS(USAttributeSet, Mana);
+	//n_BAISC_MOVE_SPEED
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_BAISC_MOVE_SPEED)
+	FGameplayAttributeData n_BAISC_MOVE_SPEED;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_BAISC_MOVE_SPEED);
 
-	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_Mana*/)
-		FGameplayAttributeData MaxMana;
-	ATTRIBUTE_ACCESSORS(USAttributeSet, MaxMana);
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_BAISC_MOVE_SPEED)
+	FGameplayAttributeData Maxn_BAISC_MOVE_SPEED;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_BAISC_MOVE_SPEED);
 
 	UFUNCTION()
-		virtual void OnRep_Mana(const FGameplayAttributeData& OldMana);
+	virtual void OnRep_n_BAISC_MOVE_SPEED(const FGameplayAttributeData& Oldn_BAISC_MOVE_SPEED);
 
-	//Stamina
-	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_Stamina*/)
-		FGameplayAttributeData Stamina;
-	ATTRIBUTE_ACCESSORS(USAttributeSet, Stamina);
+	//n_BAISC_ATTACK_SPEED
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_BAISC_ATTACK_SPEED)
+	FGameplayAttributeData n_BAISC_ATTACK_SPEED;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_BAISC_ATTACK_SPEED);
 
-	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes"/*, ReplicatedUsing = OnRep_Stamina*/)
-		FGameplayAttributeData MaxStamina;
-	ATTRIBUTE_ACCESSORS(USAttributeSet, MaxStamina);
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_BAISC_ATTACK_SPEED)
+	FGameplayAttributeData Maxn_BAISC_ATTACK_SPEED;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_BAISC_ATTACK_SPEED);
 
 	UFUNCTION()
-		virtual void OnRep_Stamina(const FGameplayAttributeData& OldStamina);
+	virtual void OnRep_n_BAISC_ATTACK_SPEED(const FGameplayAttributeData& Oldn_BAISC_ATTACK_SPEED);
 
-	//Attack Power
-	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_AttackPower)
-		FGameplayAttributeData AttackPower;
-	ATTRIBUTE_ACCESSORS(USAttributeSet, AttackPower);
+	//n_CRI
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_CRI)
+	FGameplayAttributeData n_CRI;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_CRI);
 
-	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_AttackPower)
-		FGameplayAttributeData MaxAttackPower;
-	ATTRIBUTE_ACCESSORS(USAttributeSet, MaxAttackPower);
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_CRI)
+	FGameplayAttributeData Maxn_CRI;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_CRI);
 
 	UFUNCTION()
-		virtual void OnRep_AttackPower(const FGameplayAttributeData& OldAttackPower);
+	virtual void OnRep_n_CRI(const FGameplayAttributeData& Oldn_CRI);
+
+	//n_CRI_PROPORTION
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_CRI_PROPORTION)
+	FGameplayAttributeData n_CRI_PROPORTION;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, n_CRI_PROPORTION);
 
+	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = "Attributes", ReplicatedUsing = OnRep_n_CRI_PROPORTION)
+	FGameplayAttributeData Maxn_CRI_PROPORTION;
+	ATTRIBUTE_ACCESSORS(USAttributeSet, Maxn_CRI_PROPORTION);
+
+	UFUNCTION()
+	virtual void OnRep_n_CRI_PROPORTION(const FGameplayAttributeData& Oldn_CRI_PROPORTION);
 };
Index: Plugins/Developer/RiderLink/Source/RiderGameControl/Private/RiderGameControl.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"RiderGameControl.hpp\"\r\n\r\n\r\n#include \"IRiderLink.hpp\"\r\n\r\n#include \"Model/Library/UE4Library/PlayState.Pregenerated.h\"\r\n#include \"Model/Library/UE4Library/RequestFailed.Pregenerated.h\"\r\n#include \"Model/Library/UE4Library/RequestSucceed.Pregenerated.h\"\r\n#include \"RdEditorModel/RdEditorModel.Pregenerated.h\"\r\n\r\n#include \"Async/Async.h\"\r\n#include \"Editor/UnrealEdEngine.h\"\r\n#include \"Framework/Application/SlateApplication.h\"\r\n#include \"Kismet2/DebuggerCommands.h\"\r\n#include \"LevelEditor.h\"\r\n#include \"LevelEditorActions.h\"\r\n#include \"Misc/FeedbackContext.h\"\r\n#include \"Modules/ModuleManager.h\"\r\n#include \"Settings/LevelEditorPlaySettings.h\"\r\n#include \"Editor.h\"\r\n\r\n#include \"Runtime/Launch/Resources/Version.h\"\r\n#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 23\r\n#include \"ILevelViewport.h\"\r\n#include \"LevelEditorViewport.h\"\r\n#else\r\n#include \"IAssetViewport.h\"\r\n#include \"EditorViewportClient.h\"\r\n#endif\r\n\r\n#define LOCTEXT_NAMESPACE \"RiderGameControl\"\r\n\r\nDEFINE_LOG_CATEGORY(FLogRiderGameControlModule);\r\n\r\nIMPLEMENT_MODULE(FRiderGameControlModule, RiderGameControl);\r\n\r\nextern UNREALED_API class UUnrealEdEngine* GUnrealEd;\r\n\r\nstatic int NumberOfPlayers(int Mode) { return (Mode & 3) + 1; }\r\n\r\nstatic bool SpawnAtPlayerStart(int Mode) { return (Mode & 4) != 0; }\r\n\r\nstatic bool DedicatedServer(int Mode) { return (Mode & 8) != 0; }\r\n\r\nenum class Compile\r\n{\r\n    Yes,\r\n    No\r\n};\r\n\r\nstatic Compile CompileBeforeRun(int Mode) { return (Mode & 128) != 0 ? Compile::Yes : Compile::No; }\r\n\r\nstatic EPlayModeType PlayModeFromInt(int ModeNumber)\r\n{\r\n    switch (ModeNumber)\r\n    {\r\n    default: break;\r\n    case 1: return PlayMode_InMobilePreview;\r\n    case 2: return PlayMode_InEditorFloating;\r\n    case 3: return PlayMode_InVR;\r\n    case 4: return PlayMode_InNewProcess;\r\n    case 5: return PlayMode_Simulate;\r\n    case 6: return PlayMode_InVulkanPreview;\r\n    }\r\n    return PlayMode_InViewPort;\r\n}\r\n\r\nstatic int PlayModeToInt(EPlayModeType modeType)\r\n{\r\n    switch (modeType)\r\n    {\r\n    default: break;\r\n    case PlayMode_InTargetedMobilePreview:\r\n    case PlayMode_InMobilePreview:\r\n        return 1;\r\n    case PlayMode_InEditorFloating: return 2;\r\n    case PlayMode_InVR: return 3;\r\n    case PlayMode_InNewProcess: return 4;\r\n    case PlayMode_Simulate: return 5;\r\n    case PlayMode_InVulkanPreview: return 6;\r\n    }\r\n    return 0;\r\n}\r\n\r\nFSlateApplication* SlateApplication = nullptr;\r\n\r\nstruct FPlaySettings\r\n{\r\n    EPlayModeType PlayMode;\r\n    int32 NumberOfClients;\r\n    bool bNetDedicated;\r\n    bool bSpawnAtPlayerStart;\r\n\r\n    static FPlaySettings UnpackFromMode(int32_t mode)\r\n    {\r\n        FPlaySettings settings = {\r\n            PlayModeFromInt((mode & (16 + 32 + 64)) >> 4),\r\n            NumberOfPlayers(mode),\r\n            DedicatedServer(mode),\r\n            SpawnAtPlayerStart(mode),\r\n        };\r\n        return settings;\r\n    }\r\n\r\n    static int32_t PackToMode(const FPlaySettings& settings)\r\n    {\r\n        return (settings.NumberOfClients - 1) +\r\n            (settings.bSpawnAtPlayerStart ? (1 << 2) : 0) +\r\n            (settings.bNetDedicated ? (1 << 3) : 0) +\r\n            (PlayModeToInt(settings.PlayMode) << 4);\r\n    }\r\n};\r\n\r\n\r\nstatic FPlaySettings RetrieveSettings(const ULevelEditorPlaySettings* PlayInSettings)\r\n{\r\n    check(PlayInSettings);\r\n\r\n    FPlaySettings settings;\r\n    settings.PlayMode = PlayInSettings->LastExecutedPlayModeType;\r\n    PlayInSettings->GetPlayNumberOfClients(settings.NumberOfClients);\r\n#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 24\r\n    PlayInSettings->GetPlayNetDedicated(settings.bNetDedicated);\r\n#else\r\n    settings.bNetDedicated = PlayInSettings->bLaunchSeparateServer;\r\n#endif\r\n    settings.bSpawnAtPlayerStart = PlayInSettings->LastExecutedPlayModeLocation == PlayLocation_DefaultPlayerStart;\r\n\r\n    return settings;\r\n}\r\n\r\nstatic void UpdateSettings(ULevelEditorPlaySettings* PlayInSettings, const FPlaySettings& settings)\r\n{\r\n    check(PlayInSettings);\r\n    \r\n    PlayInSettings->SetPlayNumberOfClients(settings.NumberOfClients);\r\n#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 24\r\n    PlayInSettings->SetPlayNetDedicated(settings.bNetDedicated);\r\n#else\r\n    PlayInSettings->bLaunchSeparateServer = settings.bNetDedicated;\r\n#endif\r\n    PlayInSettings->LastExecutedPlayModeLocation =\r\n        settings.bSpawnAtPlayerStart\r\n            ? PlayLocation_DefaultPlayerStart\r\n            : PlayLocation_CurrentCameraLocation;\r\n    PlayInSettings->LastExecutedPlayModeType = settings.PlayMode;\r\n\r\n    PlayInSettings->PostEditChange();\r\n    PlayInSettings->SaveConfig();\r\n}\r\n\r\n\r\nstruct FCachedCommandInfo\r\n{\r\n    FName CommandName;\r\n    TSharedPtr<FUICommandInfo> Command;\r\n};\r\n\r\nclass FRiderGameControlActionsCache\r\n{\r\npublic:\r\n    FRiderGameControlActionsCache();\r\n    ~FRiderGameControlActionsCache();\r\n\r\nprivate:\r\n    void UpdatePlayWorldCommandsCache();\r\n\r\npublic:\r\n    FCachedCommandInfo PlayModeCommands[PlayMode_Count] = {\r\n        {TEXT(\"PlayInViewport\")},\r\n        {TEXT(\"PlayInEditorFloating\")},\r\n        {TEXT(\"PlayInMobilePreview\")},\r\n        {FName()},\r\n        {TEXT(\"PlayInVulkanPreview\")},\r\n        {TEXT(\"PlayInNewProcess\")},\r\n        {TEXT(\"PlayInVR\")},\r\n        {TEXT(\"Simulate\")},\r\n    };\r\n    FCachedCommandInfo ResumePlaySession = {TEXT(\"ResumePlaySession\")};\r\n    FCachedCommandInfo PausePlaySession = {TEXT(\"PausePlaySession\")};\r\n    FCachedCommandInfo StopPlaySession = {TEXT(\"StopPlaySession\")};\r\n    FCachedCommandInfo SingleFrameAdvance = {TEXT(\"SingleFrameAdvance\")};\r\n\r\nprivate:\r\n    FDelegateHandle CommandsChangedHandle;\r\n};\r\n\r\nFRiderGameControlActionsCache::FRiderGameControlActionsCache()\r\n{\r\n    const FName PlayWorldContextName = FName(\"PlayWorld\");\r\n\r\n    TSharedPtr<FBindingContext> PlayWorldContext = FInputBindingManager::Get().GetContextByName(PlayWorldContextName);\r\n    if (PlayWorldContext.IsValid())\r\n    {\r\n        UpdatePlayWorldCommandsCache();\r\n    }\r\n\r\n    CommandsChangedHandle = FBindingContext::CommandsChanged.AddLambda(\r\n        [this, PlayWorldContextName](const FBindingContext& Ctx)\r\n        {\r\n            if (Ctx.GetContextName() == PlayWorldContextName)\r\n            {\r\n                UpdatePlayWorldCommandsCache();\r\n            }\r\n        }\r\n    );\r\n}\r\n\r\nFRiderGameControlActionsCache::~FRiderGameControlActionsCache()\r\n{\r\n    FBindingContext::CommandsChanged.Remove(CommandsChangedHandle);\r\n}\r\n\r\nvoid FRiderGameControlActionsCache::UpdatePlayWorldCommandsCache()\r\n{\r\n    FInputBindingManager& BindingManager = FInputBindingManager::Get();\r\n    auto CacheCommand = [&] (FCachedCommandInfo &Cmd, const FName &ContextName)\r\n    {\r\n        Cmd.Command = BindingManager.FindCommandInContext(ContextName, Cmd.CommandName);\r\n    };\r\n\r\n    const FName PlayWorldContextName = FName(\"PlayWorld\");\r\n    for (FCachedCommandInfo& PlayModeCommand : PlayModeCommands)\r\n    {\r\n        if (PlayModeCommands->CommandName.IsNone()) continue;\r\n        CacheCommand(PlayModeCommand, PlayWorldContextName);\r\n    }\r\n    CacheCommand(ResumePlaySession, PlayWorldContextName);\r\n    CacheCommand(PausePlaySession, PlayWorldContextName);\r\n    CacheCommand(StopPlaySession, PlayWorldContextName);\r\n    CacheCommand(SingleFrameAdvance, PlayWorldContextName);\r\n}\r\n\r\n\r\nclass FRiderGameControl\r\n{\r\npublic:\r\n    FRiderGameControl(rd::Lifetime Lifetime, JetBrains::EditorPlugin::RdEditorModel const &Model, FRiderGameControlActionsCache& ActionsCache);\r\n    ~FRiderGameControl();\r\nprivate:\r\n    void RequestPlayWorldCommand(const FCachedCommandInfo& CommandInfo, int RequestID);\r\n\r\n    void SendRequestSucceed(int RequestID);\r\n    void SendRequestFailed(int RequestID, JetBrains::EditorPlugin::NotificationType Type, const FString& Message);\r\n\r\n    void ScheduleModelAction(TFunction<void(JetBrains::EditorPlugin::RdEditorModel const&)> Action);\r\n\r\nprivate:\r\n    FRiderGameControlActionsCache& Actions;\r\n    JetBrains::EditorPlugin::RdEditorModel const &Model;\r\n\r\n    int32_t playMode;\r\n\r\n    FDelegateHandle BeginPIEHandle;\r\n    FDelegateHandle EndPIEHandle;\r\n    FDelegateHandle PausePIEHandle;\r\n    FDelegateHandle ResumePIEHandle;\r\n    FDelegateHandle SingleStepPIEHandle;\r\n    FDelegateHandle OnObjectPropertyChangedHandle;\r\n};\r\n\r\n\r\nvoid FRiderGameControl::SendRequestSucceed(int RequestID)\r\n{\r\n    using namespace JetBrains::EditorPlugin;\r\n    ScheduleModelAction([=](RdEditorModel const& EditorModel)\r\n    {\r\n        EditorModel.get_notificationReplyFromEditor().fire(RequestSucceed(RequestID));\r\n    });\r\n}\r\n\r\nvoid FRiderGameControl::SendRequestFailed(int RequestID, JetBrains::EditorPlugin::NotificationType Type,\r\n                                          const FString& Message)\r\n{\r\n    using namespace JetBrains::EditorPlugin;\r\n    ScheduleModelAction([=](RdEditorModel const& EditorModel)\r\n    {\r\n        EditorModel.get_notificationReplyFromEditor().fire(RequestFailed(Type, Message, RequestID));\r\n    });\r\n}\r\n\r\nvoid FRiderGameControl::RequestPlayWorldCommand(const FCachedCommandInfo& CommandInfo, int RequestID)\r\n{\r\n    using namespace JetBrains::EditorPlugin;\r\n    if (!CommandInfo.Command.IsValid())\r\n    {\r\n        const FString Message = FString::Format(TEXT(\"Command '{0}' was not executed.\\nCommand was not registered in Unreal Engine\"),\r\n                                                {CommandInfo.CommandName.ToString()});\r\n        SendRequestFailed(RequestID, NotificationType::Error, Message);\r\n        return;\r\n    }\r\n    AsyncTask(ENamedThreads::GameThread, [this, RequestID, CommandInfo]()\r\n    {\r\n        if (FPlayWorldCommands::GlobalPlayWorldActions->TryExecuteAction(CommandInfo.Command.ToSharedRef()))\r\n        {\r\n            SendRequestSucceed(RequestID);\r\n        }\r\n        else\r\n        {\r\n            const FString Message = FString::Format(TEXT(\"Command '{0}' was not executed.\\nRejected by Unreal Engine\"),\r\n                                                    {CommandInfo.CommandName.ToString()});\r\n            SendRequestFailed(RequestID, NotificationType::Message, Message);\r\n        }\r\n    });\r\n}\r\n\r\nvoid FRiderGameControl::ScheduleModelAction(TFunction<void(JetBrains::EditorPlugin::RdEditorModel const&)> Action)\r\n{\r\n    IRiderLinkModule& RiderLinkModule = IRiderLinkModule::Get();\r\n    RiderLinkModule.QueueAction([Action, this]()\r\n    {\r\n        Action(Model);\r\n    });\r\n}\r\n\r\nFRiderGameControl::FRiderGameControl(rd::Lifetime Lifetime, JetBrains::EditorPlugin::RdEditorModel const &Model, FRiderGameControlActionsCache& ActionsCache) :\r\n    Actions(ActionsCache), Model(Model)\r\n{\r\n    using namespace JetBrains::EditorPlugin;\r\n    \r\n    // Subscribe to Editor events\r\n    Lifetime->bracket(\r\n        [this]()\r\n        {\r\n            BeginPIEHandle = FEditorDelegates::BeginPIE.AddLambda([this](const bool)\r\n            {\r\n                ScheduleModelAction([](RdEditorModel const& model)\r\n                {\r\n                    model.get_playStateFromEditor().fire(PlayState::Play);\r\n                });\r\n            });\r\n            EndPIEHandle = FEditorDelegates::EndPIE.AddLambda([this](const bool)\r\n            {\r\n                ScheduleModelAction([](RdEditorModel const& model)\r\n                {\r\n                    model.get_playStateFromEditor().fire(PlayState::Idle);\r\n                });\r\n            });\r\n            PausePIEHandle = FEditorDelegates::PausePIE.AddLambda([this](const bool)\r\n            {\r\n                ScheduleModelAction([](RdEditorModel const& model)\r\n                {\r\n                    model.get_playStateFromEditor().fire(PlayState::Pause);\r\n                });\r\n            });\r\n            ResumePIEHandle = FEditorDelegates::ResumePIE.AddLambda([this](const bool)\r\n            {\r\n                ScheduleModelAction([](RdEditorModel const& model)\r\n                {\r\n                    model.get_playStateFromEditor().fire(PlayState::Play);\r\n                });\r\n            });\r\n            SingleStepPIEHandle = FEditorDelegates::SingleStepPIE.AddLambda([this](const bool)\r\n            {\r\n                ScheduleModelAction([](RdEditorModel const& model)\r\n                {\r\n                    model.get_playStateFromEditor().fire(PlayState::Play);\r\n                    model.get_playStateFromEditor().fire(PlayState::Pause);\r\n                });\r\n            });\r\n\r\n            OnObjectPropertyChangedHandle = FCoreUObjectDelegates::OnObjectPropertyChanged.AddLambda(\r\n                [this](UObject* obj, FPropertyChangedEvent& ev)\r\n                {\r\n                    ULevelEditorPlaySettings* PlayInSettings = GetMutableDefault<ULevelEditorPlaySettings>();\r\n                    if (!PlayInSettings || obj != PlayInSettings) return;\r\n\r\n                    const FPlaySettings Settings = RetrieveSettings(PlayInSettings);\r\n                    int PlayModeNew = FPlaySettings::PackToMode(Settings);\r\n                    if (PlayModeNew == playMode) return;\r\n\r\n                    playMode = PlayModeNew;\r\n                    ScheduleModelAction([PlayModeNew](RdEditorModel const& Model)\r\n                    {\r\n                        Model.get_playModeFromEditor().fire(PlayModeNew);\r\n                    });\r\n                }\r\n            );\r\n        },\r\n        [this]()\r\n        {\r\n            FCoreUObjectDelegates::OnObjectPropertyChanged.Remove(OnObjectPropertyChangedHandle);\r\n            FEditorDelegates::SingleStepPIE.Remove(SingleStepPIEHandle);\r\n            FEditorDelegates::ResumePIE.Remove(ResumePIEHandle);\r\n            FEditorDelegates::PausePIE.Remove(PausePIEHandle);\r\n            FEditorDelegates::EndPIE.Remove(EndPIEHandle);\r\n            FEditorDelegates::BeginPIE.Remove(BeginPIEHandle);\r\n        }\r\n    );\r\n\r\n    // Subscribe to model\r\n    ScheduleModelAction([Lifetime, this](RdEditorModel const& Model)\r\n    {\r\n        Model.get_requestPlayFromRider()\r\n             .advise(Lifetime, [this](int requestID)\r\n                     {\r\n                         const ULevelEditorPlaySettings* PlayInSettings\r\n                             = GetDefault<ULevelEditorPlaySettings>();\r\n                         check(PlayInSettings);\r\n                         const EPlayModeType PlayMode = PlayInSettings->LastExecutedPlayModeType;\r\n\r\n                         RequestPlayWorldCommand(Actions.PlayModeCommands[PlayMode], requestID);\r\n                     }\r\n             );\r\n        Model.get_requestPauseFromRider()\r\n             .advise(Lifetime, [this](int requestID)\r\n                     {\r\n                         RequestPlayWorldCommand(Actions.PausePlaySession, requestID);\r\n                     }\r\n             );\r\n        Model.get_requestResumeFromRider()\r\n             .advise(Lifetime, [this](int requestID)\r\n                     {\r\n                         RequestPlayWorldCommand(Actions.ResumePlaySession, requestID);\r\n                     }\r\n             );\r\n        Model.get_requestStopFromRider()\r\n             .advise(Lifetime, [this](int requestID)\r\n                     {\r\n                         RequestPlayWorldCommand(Actions.StopPlaySession, requestID);\r\n                     }\r\n             );\r\n        Model.get_requestFrameSkipFromRider()\r\n             .advise(Lifetime, [this](int requestID)\r\n                     {\r\n                         RequestPlayWorldCommand(Actions.SingleFrameAdvance, requestID);\r\n                     }\r\n             );\r\n\r\n        Model.get_playModeFromRider()\r\n             .advise(Lifetime, [this](int32_t mode)\r\n                     {\r\n                         ULevelEditorPlaySettings* PlayInSettings\r\n                             = GetMutableDefault<ULevelEditorPlaySettings>();\r\n                         check(PlayInSettings);\r\n                         const FPlaySettings NewSettings = FPlaySettings::UnpackFromMode(mode);\r\n                         UpdateSettings(PlayInSettings, NewSettings);\r\n                     }\r\n             );\r\n    });\r\n\r\n    // Initial sync.\r\n    const ULevelEditorPlaySettings* PlayInSettings = GetDefault<ULevelEditorPlaySettings>();\r\n    check(PlayInSettings);\r\n    const FPlaySettings Settings = RetrieveSettings(PlayInSettings);\r\n    playMode = FPlaySettings::PackToMode(Settings);\r\n\r\n    ScheduleModelAction([lambdaPlayMode=playMode](RdEditorModel const &Model)\r\n    {\r\n        Model.get_playModeFromEditor().fire(lambdaPlayMode);\r\n    });\r\n\r\n    // After all initialization finished/scheduled - mark that module was initialized\r\n    Lifetime->bracket(\r\n        [this]()\r\n        {\r\n            ScheduleModelAction([](RdEditorModel const& Model)\r\n            {\r\n                Model.get_isGameControlModuleInitialized().set(true);\r\n            });\r\n        },\r\n        [this]()\r\n        {\r\n            ScheduleModelAction([](RdEditorModel const& Model)\r\n            {\r\n                Model.get_isGameControlModuleInitialized().set(false);\r\n            });\r\n        }\r\n    );\r\n}\r\n\r\nFRiderGameControl::~FRiderGameControl()\r\n{\r\n}\r\n\r\n\r\nvoid FRiderGameControlModule::StartupModule()\r\n{\r\n    using namespace JetBrains::EditorPlugin;\r\n    \r\n    UE_LOG(FLogRiderGameControlModule, Verbose, TEXT(\"STARTUP START\"));\r\n\r\n    // Actions cache is not related to connection and its lifetimes\r\n    ActionsCache = MakeUnique<FRiderGameControlActionsCache>();\r\n\r\n    IRiderLinkModule& RiderLinkModule = IRiderLinkModule::Get();\r\n    ModuleLifetimeDefinition = RiderLinkModule.CreateNestedLifetimeDefinition();\r\n    rd::Lifetime ModuleLifetime = ModuleLifetimeDefinition.lifetime;\r\n\r\n    RiderLinkModule.ViewModel(\r\n        ModuleLifetime,\r\n        [&](rd::Lifetime ModelLifetime, RdEditorModel const& Model)\r\n        {\r\n            ModelLifetime->add_action([&]() { GameControl.Reset(); });\r\n            GameControl = MakeUnique<FRiderGameControl>(ModelLifetime, Model, *ActionsCache);\r\n        }\r\n    );\r\n\r\n    UE_LOG(FLogRiderGameControlModule, Verbose, TEXT(\"STARTUP FINISH\"));\r\n}\r\n\r\nvoid FRiderGameControlModule::ShutdownModule()\r\n{\r\n    UE_LOG(FLogRiderGameControlModule, Verbose, TEXT(\"SHUTDOWN START\"));\r\n    ModuleLifetimeDefinition.terminate();\r\n    ActionsCache.Reset();\r\n    UE_LOG(FLogRiderGameControlModule, Verbose, TEXT(\"SHUTDOWN FINISH\"));\r\n}\r\n\r\n#undef LOCTEXT_NAMESPACE
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RiderGameControl/Private/RiderGameControl.cpp b/Plugins/Developer/RiderLink/Source/RiderGameControl/Private/RiderGameControl.cpp
--- a/Plugins/Developer/RiderLink/Source/RiderGameControl/Private/RiderGameControl.cpp	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RiderGameControl/Private/RiderGameControl.cpp	(date 1720720014571)
@@ -213,10 +213,10 @@
 
 void FRiderGameControlActionsCache::UpdatePlayWorldCommandsCache()
 {
-    FInputBindingManager& BindingManager = FInputBindingManager::Get();
+    FInputBindingManager& Bindingn_BASIC_MPger = FInputBindingManager::Get();
     auto CacheCommand = [&] (FCachedCommandInfo &Cmd, const FName &ContextName)
     {
-        Cmd.Command = BindingManager.FindCommandInContext(ContextName, Cmd.CommandName);
+        Cmd.Command = Bindingn_BASIC_MPger.FindCommandInContext(ContextName, Cmd.CommandName);
     };
 
     const FName PlayWorldContextName = FName("PlayWorld");
Index: Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n Formatting library for C++\r\n\r\n Copyright (c) 2012 - present, Victor Zverovich\r\n\r\n Permission is hereby granted, free of charge, to any person obtaining\r\n a copy of this software and associated documentation files (the\r\n \"Software\"), to deal in the Software without restriction, including\r\n without limitation the rights to use, copy, modify, merge, publish,\r\n distribute, sublicense, and/or sell copies of the Software, and to\r\n permit persons to whom the Software is furnished to do so, subject to\r\n the following conditions:\r\n\r\n The above copyright notice and this permission notice shall be\r\n included in all copies or substantial portions of the Software.\r\n\r\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n --- Optional exception to the license ---\r\n\r\n As an exception, if, as a result of your compiling your source code, portions\r\n of this Software are embedded into a machine-executable object form of such\r\n source code, you may redistribute such embedded portions in such object form\r\n without including the above copyright and permission notices.\r\n */\r\n\r\n#ifndef FMT_FORMAT_H_\r\n#define FMT_FORMAT_H_\r\n\r\n#include <cmath>         // std::signbit\r\n#include <cstdint>       // uint32_t\r\n#include <limits>        // std::numeric_limits\r\n#include <memory>        // std::uninitialized_copy\r\n#include <stdexcept>     // std::runtime_error\r\n#include <system_error>  // std::system_error\r\n#include <utility>       // std::swap\r\n\r\n#ifdef __cpp_lib_bit_cast\r\n#  include <bit>  // std::bitcast\r\n#endif\r\n\r\n#include \"core.h\"\r\n\r\n#if FMT_GCC_VERSION\r\n#  define FMT_GCC_VISIBILITY_HIDDEN __attribute__((visibility(\"hidden\")))\r\n#else\r\n#  define FMT_GCC_VISIBILITY_HIDDEN\r\n#endif\r\n\r\n#ifdef __NVCC__\r\n#  define FMT_CUDA_VERSION (__CUDACC_VER_MAJOR__ * 100 + __CUDACC_VER_MINOR__)\r\n#else\r\n#  define FMT_CUDA_VERSION 0\r\n#endif\r\n\r\n#ifdef __has_builtin\r\n#  define FMT_HAS_BUILTIN(x) __has_builtin(x)\r\n#else\r\n#  define FMT_HAS_BUILTIN(x) 0\r\n#endif\r\n\r\n#if FMT_GCC_VERSION || FMT_CLANG_VERSION\r\n#  define FMT_NOINLINE __attribute__((noinline))\r\n#else\r\n#  define FMT_NOINLINE\r\n#endif\r\n\r\n#if FMT_MSC_VER\r\n#  define FMT_MSC_DEFAULT = default\r\n#else\r\n#  define FMT_MSC_DEFAULT\r\n#endif\r\n\r\n#ifndef FMT_THROW\r\n#  if FMT_EXCEPTIONS\r\n#    if FMT_MSC_VER || FMT_NVCC\r\nFMT_BEGIN_NAMESPACE\r\nnamespace detail {\r\ntemplate <typename Exception> inline void do_throw(const Exception& x) {\r\n  // Silence unreachable code warnings in MSVC and NVCC because these\r\n  // are nearly impossible to fix in a generic code.\r\n  volatile bool b = true;\r\n  if (b) throw x;\r\n}\r\n}  // namespace detail\r\nFMT_END_NAMESPACE\r\n#      define FMT_THROW(x) detail::do_throw(x)\r\n#    else\r\n#      define FMT_THROW(x) throw x\r\n#    endif\r\n#  else\r\n#    define FMT_THROW(x)               \\\r\n      do {                             \\\r\n        FMT_ASSERT(false, (x).what()); \\\r\n      } while (false)\r\n#  endif\r\n#endif\r\n\r\n#if FMT_EXCEPTIONS\r\n#  define FMT_TRY try\r\n#  define FMT_CATCH(x) catch (x)\r\n#else\r\n#  define FMT_TRY if (true)\r\n#  define FMT_CATCH(x) if (false)\r\n#endif\r\n\r\n#ifndef FMT_MAYBE_UNUSED\r\n#  if FMT_HAS_CPP17_ATTRIBUTE(maybe_unused)\r\n#    define FMT_MAYBE_UNUSED [[maybe_unused]]\r\n#  else\r\n#    define FMT_MAYBE_UNUSED\r\n#  endif\r\n#endif\r\n\r\n// Workaround broken [[deprecated]] in the Intel, PGI and NVCC compilers.\r\n#if FMT_ICC_VERSION || defined(__PGI) || FMT_NVCC\r\n#  define FMT_DEPRECATED_ALIAS\r\n#else\r\n#  define FMT_DEPRECATED_ALIAS FMT_DEPRECATED\r\n#endif\r\n\r\n#ifndef FMT_USE_USER_DEFINED_LITERALS\r\n// EDG based compilers (Intel, NVIDIA, Elbrus, etc), GCC and MSVC support UDLs.\r\n#  if (FMT_HAS_FEATURE(cxx_user_literals) || FMT_GCC_VERSION >= 407 || \\\r\n       FMT_MSC_VER >= 1900) &&                                         \\\r\n      (!defined(__EDG_VERSION__) || __EDG_VERSION__ >= /* UDL feature */ 480)\r\n#    define FMT_USE_USER_DEFINED_LITERALS 1\r\n#  else\r\n#    define FMT_USE_USER_DEFINED_LITERALS 0\r\n#  endif\r\n#endif\r\n\r\n// Defining FMT_REDUCE_INT_INSTANTIATIONS to 1, will reduce the number of\r\n// integer formatter template instantiations to just one by only using the\r\n// largest integer type. This results in a reduction in binary size but will\r\n// cause a decrease in integer formatting performance.\r\n#if !defined(FMT_REDUCE_INT_INSTANTIATIONS)\r\n#  define FMT_REDUCE_INT_INSTANTIATIONS 0\r\n#endif\r\n\r\n// __builtin_clz is broken in clang with Microsoft CodeGen:\r\n// https://github.com/fmtlib/fmt/issues/519.\r\n#if !FMT_MSC_VER\r\n#  if FMT_HAS_BUILTIN(__builtin_clz) || FMT_GCC_VERSION || FMT_ICC_VERSION\r\n#    define FMT_BUILTIN_CLZ(n) __builtin_clz(n)\r\n#  endif\r\n#  if FMT_HAS_BUILTIN(__builtin_clzll) || FMT_GCC_VERSION || FMT_ICC_VERSION\r\n#    define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)\r\n#  endif\r\n#endif\r\n\r\n// __builtin_ctz is broken in Intel Compiler Classic on Windows:\r\n// https://github.com/fmtlib/fmt/issues/2510.\r\n#ifndef __ICL\r\n#  if FMT_HAS_BUILTIN(__builtin_ctz) || FMT_GCC_VERSION || FMT_ICC_VERSION\r\n#    define FMT_BUILTIN_CTZ(n) __builtin_ctz(n)\r\n#  endif\r\n#  if FMT_HAS_BUILTIN(__builtin_ctzll) || FMT_GCC_VERSION || FMT_ICC_VERSION\r\n#    define FMT_BUILTIN_CTZLL(n) __builtin_ctzll(n)\r\n#  endif\r\n#endif\r\n\r\n#if FMT_MSC_VER\r\n#  include <intrin.h>  // _BitScanReverse[64], _BitScanForward[64], _umul128\r\n#endif\r\n\r\n// Some compilers masquerade as both MSVC and GCC-likes or otherwise support\r\n// __builtin_clz and __builtin_clzll, so only define FMT_BUILTIN_CLZ using the\r\n// MSVC intrinsics if the clz and clzll builtins are not available.\r\n#if FMT_MSC_VER && !defined(FMT_BUILTIN_CLZLL) && !defined(FMT_BUILTIN_CTZLL)\r\nFMT_BEGIN_NAMESPACE\r\nnamespace detail {\r\n// Avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning.\r\n#  if !defined(__clang__)\r\n#    pragma intrinsic(_BitScanForward)\r\n#    pragma intrinsic(_BitScanReverse)\r\n#    if defined(_WIN64)\r\n#      pragma intrinsic(_BitScanForward64)\r\n#      pragma intrinsic(_BitScanReverse64)\r\n#    endif\r\n#  endif\r\n\r\ninline auto clz(uint32_t x) -> int {\r\n  unsigned long r = 0;\r\n  _BitScanReverse(&r, x);\r\n  FMT_ASSERT(x != 0, \"\");\r\n  // Static analysis complains about using uninitialized data\r\n  // \"r\", but the only way that can happen is if \"x\" is 0,\r\n  // which the callers guarantee to not happen.\r\n  FMT_MSC_WARNING(suppress : 6102)\r\n  return 31 ^ static_cast<int>(r);\r\n}\r\n#  define FMT_BUILTIN_CLZ(n) detail::clz(n)\r\n\r\ninline auto clzll(uint64_t x) -> int {\r\n  unsigned long r = 0;\r\n#  ifdef _WIN64\r\n  _BitScanReverse64(&r, x);\r\n#  else\r\n  // Scan the high 32 bits.\r\n  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32))) return 63 ^ (r + 32);\r\n  // Scan the low 32 bits.\r\n  _BitScanReverse(&r, static_cast<uint32_t>(x));\r\n#  endif\r\n  FMT_ASSERT(x != 0, \"\");\r\n  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.\r\n  return 63 ^ static_cast<int>(r);\r\n}\r\n#  define FMT_BUILTIN_CLZLL(n) detail::clzll(n)\r\n\r\ninline auto ctz(uint32_t x) -> int {\r\n  unsigned long r = 0;\r\n  _BitScanForward(&r, x);\r\n  FMT_ASSERT(x != 0, \"\");\r\n  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.\r\n  return static_cast<int>(r);\r\n}\r\n#  define FMT_BUILTIN_CTZ(n) detail::ctz(n)\r\n\r\ninline auto ctzll(uint64_t x) -> int {\r\n  unsigned long r = 0;\r\n  FMT_ASSERT(x != 0, \"\");\r\n  FMT_MSC_WARNING(suppress : 6102)  // Suppress a bogus static analysis warning.\r\n#  ifdef _WIN64\r\n  _BitScanForward64(&r, x);\r\n#  else\r\n  // Scan the low 32 bits.\r\n  if (_BitScanForward(&r, static_cast<uint32_t>(x))) return static_cast<int>(r);\r\n  // Scan the high 32 bits.\r\n  _BitScanForward(&r, static_cast<uint32_t>(x >> 32));\r\n  r += 32;\r\n#  endif\r\n  return static_cast<int>(r);\r\n}\r\n#  define FMT_BUILTIN_CTZLL(n) detail::ctzll(n)\r\n}  // namespace detail\r\nFMT_END_NAMESPACE\r\n#endif\r\n\r\n#ifdef FMT_HEADER_ONLY\r\n#  define FMT_HEADER_ONLY_CONSTEXPR20 FMT_CONSTEXPR20\r\n#else\r\n#  define FMT_HEADER_ONLY_CONSTEXPR20\r\n#endif\r\n\r\nFMT_BEGIN_NAMESPACE\r\nnamespace detail {\r\n\r\ntemplate <typename Streambuf> class formatbuf : public Streambuf {\r\n private:\r\n  using char_type = typename Streambuf::char_type;\r\n  using streamsize = decltype(std::declval<Streambuf>().sputn(nullptr, 0));\r\n  using int_type = typename Streambuf::int_type;\r\n  using traits_type = typename Streambuf::traits_type;\r\n\r\n  buffer<char_type>& buffer_;\r\n\r\n public:\r\n  explicit formatbuf(buffer<char_type>& buf) : buffer_(buf) {}\r\n\r\n protected:\r\n  // The put area is always empty. This makes the implementation simpler and has\r\n  // the advantage that the streambuf and the buffer are always in sync and\r\n  // sputc never writes into uninitialized memory. A disadvantage is that each\r\n  // call to sputc always results in a (virtual) call to overflow. There is no\r\n  // disadvantage here for sputn since this always results in a call to xsputn.\r\n\r\n  auto overflow(int_type ch) -> int_type override {\r\n    if (!traits_type::eq_int_type(ch, traits_type::eof()))\r\n      buffer_.push_back(static_cast<char_type>(ch));\r\n    return ch;\r\n  }\r\n\r\n  auto xsputn(const char_type* s, streamsize count) -> streamsize override {\r\n    buffer_.append(s, s + count);\r\n    return count;\r\n  }\r\n};\r\n\r\n// Implementation of std::bit_cast for pre-C++20.\r\ntemplate <typename To, typename From>\r\nFMT_CONSTEXPR20 auto bit_cast(const From& from) -> To {\r\n  static_assert(sizeof(To) == sizeof(From), \"size mismatch\");\r\n#ifdef __cpp_lib_bit_cast\r\n  if (is_constant_evaluated()) return std::bit_cast<To>(from);\r\n#endif\r\n  auto to = To();\r\n  std::memcpy(&to, &from, sizeof(to));\r\n  return to;\r\n}\r\n\r\ninline auto is_big_endian() -> bool {\r\n#ifdef _WIN32\r\n  return false;\r\n#elif defined(__BIG_ENDIAN__)\r\n  return true;\r\n#elif defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__)\r\n  return __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__;\r\n#else\r\n  struct bytes {\r\n    char data[sizeof(int)];\r\n  };\r\n  return bit_cast<bytes>(1).data[0] == 0;\r\n#endif\r\n}\r\n\r\n// A fallback implementation of uintptr_t for systems that lack it.\r\nstruct fallback_uintptr {\r\n  unsigned char value[sizeof(void*)];\r\n\r\n  fallback_uintptr() = default;\r\n  explicit fallback_uintptr(const void* p) {\r\n    *this = bit_cast<fallback_uintptr>(p);\r\n    if (const_check(is_big_endian())) {\r\n      for (size_t i = 0, j = sizeof(void*) - 1; i < j; ++i, --j)\r\n        std::swap(value[i], value[j]);\r\n    }\r\n  }\r\n};\r\n#ifdef UINTPTR_MAX\r\nusing uintptr_t = ::uintptr_t;\r\ninline auto to_uintptr(const void* p) -> uintptr_t {\r\n  return bit_cast<uintptr_t>(p);\r\n}\r\n#else\r\nusing uintptr_t = fallback_uintptr;\r\ninline auto to_uintptr(const void* p) -> fallback_uintptr {\r\n  return fallback_uintptr(p);\r\n}\r\n#endif\r\n\r\n// Returns the largest possible value for type T. Same as\r\n// std::numeric_limits<T>::max() but shorter and not affected by the max macro.\r\ntemplate <typename T> constexpr auto max_value() -> T {\r\n  return (std::numeric_limits<T>::max)();\r\n}\r\ntemplate <typename T> constexpr auto num_bits() -> int {\r\n  return std::numeric_limits<T>::digits;\r\n}\r\n// std::numeric_limits<T>::digits may return 0 for 128-bit ints.\r\ntemplate <> constexpr auto num_bits<int128_t>() -> int { return 128; }\r\ntemplate <> constexpr auto num_bits<uint128_t>() -> int { return 128; }\r\ntemplate <> constexpr auto num_bits<fallback_uintptr>() -> int {\r\n  return static_cast<int>(sizeof(void*) *\r\n                          std::numeric_limits<unsigned char>::digits);\r\n}\r\n\r\nFMT_INLINE void assume(bool condition) {\r\n  (void)condition;\r\n#if FMT_HAS_BUILTIN(__builtin_assume)\r\n  __builtin_assume(condition);\r\n#endif\r\n}\r\n\r\n// An approximation of iterator_t for pre-C++20 systems.\r\ntemplate <typename T>\r\nusing iterator_t = decltype(std::begin(std::declval<T&>()));\r\ntemplate <typename T> using sentinel_t = decltype(std::end(std::declval<T&>()));\r\n\r\n// A workaround for std::string not having mutable data() until C++17.\r\ntemplate <typename Char>\r\ninline auto get_data(std::basic_string<Char>& s) -> Char* {\r\n  return &s[0];\r\n}\r\ntemplate <typename Container>\r\ninline auto get_data(Container& c) -> typename Container::value_type* {\r\n  return c.data();\r\n}\r\n\r\n#if defined(_SECURE_SCL) && _SECURE_SCL\r\n// Make a checked iterator to avoid MSVC warnings.\r\ntemplate <typename T> using checked_ptr = stdext::checked_array_iterator<T*>;\r\ntemplate <typename T>\r\nconstexpr auto make_checked(T* p, size_t size) -> checked_ptr<T> {\r\n  return {p, size};\r\n}\r\n#else\r\ntemplate <typename T> using checked_ptr = T*;\r\ntemplate <typename T> constexpr auto make_checked(T* p, size_t) -> T* {\r\n  return p;\r\n}\r\n#endif\r\n\r\n// Attempts to reserve space for n extra characters in the output range.\r\n// Returns a pointer to the reserved range or a reference to it.\r\ntemplate <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>\r\n#if FMT_CLANG_VERSION >= 307 && !FMT_ICC_VERSION\r\n__attribute__((no_sanitize(\"undefined\")))\r\n#endif\r\ninline auto\r\nreserve(std::back_insert_iterator<Container> it, size_t n)\r\n    -> checked_ptr<typename Container::value_type> {\r\n  Container& c = get_container(it);\r\n  size_t size = c.size();\r\n  c.resize(size + n);\r\n  return make_checked(get_data(c) + size, n);\r\n}\r\n\r\ntemplate <typename T>\r\ninline auto reserve(buffer_appender<T> it, size_t n) -> buffer_appender<T> {\r\n  buffer<T>& buf = get_container(it);\r\n  buf.try_reserve(buf.size() + n);\r\n  return it;\r\n}\r\n\r\ntemplate <typename Iterator>\r\nconstexpr auto reserve(Iterator& it, size_t) -> Iterator& {\r\n  return it;\r\n}\r\n\r\ntemplate <typename OutputIt>\r\nusing reserve_iterator =\r\n    remove_reference_t<decltype(reserve(std::declval<OutputIt&>(), 0))>;\r\n\r\ntemplate <typename T, typename OutputIt>\r\nconstexpr auto to_pointer(OutputIt, size_t) -> T* {\r\n  return nullptr;\r\n}\r\ntemplate <typename T> auto to_pointer(buffer_appender<T> it, size_t n) -> T* {\r\n  buffer<T>& buf = get_container(it);\r\n  auto size = buf.size();\r\n  if (buf.capacity() < size + n) return nullptr;\r\n  buf.try_resize(size + n);\r\n  return buf.data() + size;\r\n}\r\n\r\ntemplate <typename Container, FMT_ENABLE_IF(is_contiguous<Container>::value)>\r\ninline auto base_iterator(std::back_insert_iterator<Container>& it,\r\n                          checked_ptr<typename Container::value_type>)\r\n    -> std::back_insert_iterator<Container> {\r\n  return it;\r\n}\r\n\r\ntemplate <typename Iterator>\r\nconstexpr auto base_iterator(Iterator, Iterator it) -> Iterator {\r\n  return it;\r\n}\r\n\r\n// <algorithm> is spectacularly slow to compile in C++20 so use a simple fill_n\r\n// instead (#1998).\r\ntemplate <typename OutputIt, typename Size, typename T>\r\nFMT_CONSTEXPR auto fill_n(OutputIt out, Size count, const T& value)\r\n    -> OutputIt {\r\n  for (Size i = 0; i < count; ++i) *out++ = value;\r\n  return out;\r\n}\r\ntemplate <typename T, typename Size>\r\nFMT_CONSTEXPR20 auto fill_n(T* out, Size count, char value) -> T* {\r\n  if (is_constant_evaluated()) {\r\n    return fill_n<T*, Size, T>(out, count, value);\r\n  }\r\n  std::memset(out, value, to_unsigned(count));\r\n  return out + count;\r\n}\r\n\r\n#ifdef __cpp_char8_t\r\nusing char8_type = char8_t;\r\n#else\r\nenum char8_type : unsigned char {};\r\n#endif\r\n\r\ntemplate <typename OutChar, typename InputIt, typename OutputIt>\r\nFMT_CONSTEXPR FMT_NOINLINE auto copy_str_noinline(InputIt begin, InputIt end,\r\n                                                  OutputIt out) -> OutputIt {\r\n  return copy_str<OutChar>(begin, end, out);\r\n}\r\n\r\n// A public domain branchless UTF-8 decoder by Christopher Wellons:\r\n// https://github.com/skeeto/branchless-utf8\r\n/* Decode the next character, c, from s, reporting errors in e.\r\n *\r\n * Since this is a branchless decoder, four bytes will be read from the\r\n * buffer regardless of the actual length of the next character. This\r\n * means the buffer _must_ have at least three bytes of zero padding\r\n * following the end of the data stream.\r\n *\r\n * Errors are reported in e, which will be non-zero if the parsed\r\n * character was somehow invalid: invalid byte sequence, non-canonical\r\n * encoding, or a surrogate half.\r\n *\r\n * The function returns a pointer to the next character. When an error\r\n * occurs, this pointer will be a guess that depends on the particular\r\n * error, but it will always advance at least one byte.\r\n */\r\nFMT_CONSTEXPR inline auto utf8_decode(const char* s, uint32_t* c, int* e)\r\n    -> const char* {\r\n  constexpr const int masks[] = {0x00, 0x7f, 0x1f, 0x0f, 0x07};\r\n  constexpr const uint32_t mins[] = {4194304, 0, 128, 2048, 65536};\r\n  constexpr const int shiftc[] = {0, 18, 12, 6, 0};\r\n  constexpr const int shifte[] = {0, 6, 4, 2, 0};\r\n\r\n  int len = code_point_length(s);\r\n  const char* next = s + len;\r\n\r\n  // Assume a four-byte character and load four bytes. Unused bits are\r\n  // shifted out.\r\n  *c = uint32_t(s[0] & masks[len]) << 18;\r\n  *c |= uint32_t(s[1] & 0x3f) << 12;\r\n  *c |= uint32_t(s[2] & 0x3f) << 6;\r\n  *c |= uint32_t(s[3] & 0x3f) << 0;\r\n  *c >>= shiftc[len];\r\n\r\n  // Accumulate the various error conditions.\r\n  using uchar = unsigned char;\r\n  *e = (*c < mins[len]) << 6;       // non-canonical encoding\r\n  *e |= ((*c >> 11) == 0x1b) << 7;  // surrogate half?\r\n  *e |= (*c > 0x10FFFF) << 8;       // out of range?\r\n  *e |= (uchar(s[1]) & 0xc0) >> 2;\r\n  *e |= (uchar(s[2]) & 0xc0) >> 4;\r\n  *e |= uchar(s[3]) >> 6;\r\n  *e ^= 0x2a;  // top two bits of each tail byte correct?\r\n  *e >>= shifte[len];\r\n\r\n  return next;\r\n}\r\n\r\nconstexpr uint32_t invalid_code_point = ~uint32_t();\r\n\r\n// Invokes f(cp, sv) for every code point cp in s with sv being the string view\r\n// corresponding to the code point. cp is invalid_code_point on error.\r\ntemplate <typename F>\r\nFMT_CONSTEXPR void for_each_codepoint(string_view s, F f) {\r\n  auto decode = [f](const char* buf_ptr, const char* ptr) {\r\n    auto cp = uint32_t();\r\n    auto error = 0;\r\n    auto end = utf8_decode(buf_ptr, &cp, &error);\r\n    bool result = f(error ? invalid_code_point : cp,\r\n                    string_view(ptr, to_unsigned(end - buf_ptr)));\r\n    return result ? end : nullptr;\r\n  };\r\n  auto p = s.data();\r\n  const size_t block_size = 4;  // utf8_decode always reads blocks of 4 chars.\r\n  if (s.size() >= block_size) {\r\n    for (auto end = p + s.size() - block_size + 1; p < end;) {\r\n      p = decode(p, p);\r\n      if (!p) return;\r\n    }\r\n  }\r\n  if (auto num_chars_left = s.data() + s.size() - p) {\r\n    char buf[2 * block_size - 1] = {};\r\n    copy_str<char>(p, p + num_chars_left, buf);\r\n    const char* buf_ptr = buf;\r\n    do {\r\n      auto end = decode(buf_ptr, p);\r\n      if (!end) return;\r\n      p += end - buf_ptr;\r\n      buf_ptr = end;\r\n    } while (buf_ptr - buf < num_chars_left);\r\n  }\r\n}\r\n\r\ntemplate <typename Char>\r\ninline auto compute_width(basic_string_view<Char> s) -> size_t {\r\n  return s.size();\r\n}\r\n\r\n// Computes approximate display width of a UTF-8 string.\r\nFMT_CONSTEXPR inline size_t compute_width(string_view s) {\r\n  size_t num_code_points = 0;\r\n  // It is not a lambda for compatibility with C++14.\r\n  struct count_code_points {\r\n    size_t* count;\r\n    FMT_CONSTEXPR auto operator()(uint32_t cp, string_view) const -> bool {\r\n      *count += detail::to_unsigned(\r\n          1 +\r\n          (cp >= 0x1100 &&\r\n           (cp <= 0x115f ||  // Hangul Jamo init. consonants\r\n            cp == 0x2329 ||  // LEFT-POINTING ANGLE BRACKET\r\n            cp == 0x232a ||  // RIGHT-POINTING ANGLE BRACKET\r\n            // CJK ... Yi except IDEOGRAPHIC HALF FILL SPACE:\r\n            (cp >= 0x2e80 && cp <= 0xa4cf && cp != 0x303f) ||\r\n            (cp >= 0xac00 && cp <= 0xd7a3) ||    // Hangul Syllables\r\n            (cp >= 0xf900 && cp <= 0xfaff) ||    // CJK Compatibility Ideographs\r\n            (cp >= 0xfe10 && cp <= 0xfe19) ||    // Vertical Forms\r\n            (cp >= 0xfe30 && cp <= 0xfe6f) ||    // CJK Compatibility Forms\r\n            (cp >= 0xff00 && cp <= 0xff60) ||    // Fullwidth Forms\r\n            (cp >= 0xffe0 && cp <= 0xffe6) ||    // Fullwidth Forms\r\n            (cp >= 0x20000 && cp <= 0x2fffd) ||  // CJK\r\n            (cp >= 0x30000 && cp <= 0x3fffd) ||\r\n            // Miscellaneous Symbols and Pictographs + Emoticons:\r\n            (cp >= 0x1f300 && cp <= 0x1f64f) ||\r\n            // Supplemental Symbols and Pictographs:\r\n            (cp >= 0x1f900 && cp <= 0x1f9ff))));\r\n      return true;\r\n    }\r\n  };\r\n  for_each_codepoint(s, count_code_points{&num_code_points});\r\n  return num_code_points;\r\n}\r\n\r\ninline auto compute_width(basic_string_view<char8_type> s) -> size_t {\r\n  return compute_width(basic_string_view<char>(\r\n      reinterpret_cast<const char*>(s.data()), s.size()));\r\n}\r\n\r\ntemplate <typename Char>\r\ninline auto code_point_index(basic_string_view<Char> s, size_t n) -> size_t {\r\n  size_t size = s.size();\r\n  return n < size ? n : size;\r\n}\r\n\r\n// Calculates the index of the nth code point in a UTF-8 string.\r\ninline auto code_point_index(basic_string_view<char8_type> s, size_t n)\r\n    -> size_t {\r\n  const char8_type* data = s.data();\r\n  size_t num_code_points = 0;\r\n  for (size_t i = 0, size = s.size(); i != size; ++i) {\r\n    if ((data[i] & 0xc0) != 0x80 && ++num_code_points > n) return i;\r\n  }\r\n  return s.size();\r\n}\r\n\r\ntemplate <typename T, bool = std::is_floating_point<T>::value>\r\nstruct is_fast_float : bool_constant<std::numeric_limits<T>::is_iec559 &&\r\n                                     sizeof(T) <= sizeof(double)> {};\r\ntemplate <typename T> struct is_fast_float<T, false> : std::false_type {};\r\n\r\n#ifndef FMT_USE_FULL_CACHE_DRAGONBOX\r\n#  define FMT_USE_FULL_CACHE_DRAGONBOX 0\r\n#endif\r\n\r\ntemplate <typename T>\r\ntemplate <typename U>\r\nvoid buffer<T>::append(const U* begin, const U* end) {\r\n  while (begin != end) {\r\n    auto count = to_unsigned(end - begin);\r\n    try_reserve(size_ + count);\r\n    auto free_cap = capacity_ - size_;\r\n    if (free_cap < count) count = free_cap;\r\n    std::uninitialized_copy_n(begin, count, make_checked(ptr_ + size_, count));\r\n    size_ += count;\r\n    begin += count;\r\n  }\r\n}\r\n\r\ntemplate <typename T, typename Enable = void>\r\nstruct is_locale : std::false_type {};\r\ntemplate <typename T>\r\nstruct is_locale<T, void_t<decltype(T::classic())>> : std::true_type {};\r\n}  // namespace detail\r\n\r\nFMT_MODULE_EXPORT_BEGIN\r\n\r\n// The number of characters to store in the basic_memory_buffer object itself\r\n// to avoid dynamic memory allocation.\r\nenum { inline_buffer_size = 500 };\r\n\r\n/**\r\n  \\rst\r\n  A dynamically growing memory buffer for trivially copyable/constructible types\r\n  with the first ``SIZE`` elements stored in the object itself.\r\n\r\n  You can use the ``memory_buffer`` type alias for ``char`` instead.\r\n\r\n  **Example**::\r\n\r\n     auto out = fmt::memory_buffer();\r\n     format_to(std::back_inserter(out), \"The answer is {}.\", 42);\r\n\r\n  This will append the following output to the ``out`` object:\r\n\r\n  .. code-block:: none\r\n\r\n     The answer is 42.\r\n\r\n  The output can be converted to an ``std::string`` with ``to_string(out)``.\r\n  \\endrst\r\n */\r\ntemplate <typename T, size_t SIZE = inline_buffer_size,\r\n          typename Allocator = std::allocator<T>>\r\nclass basic_memory_buffer final : public detail::buffer<T> {\r\n private:\r\n  T store_[SIZE];\r\n\r\n  // Don't inherit from Allocator avoid generating type_info for it.\r\n  Allocator alloc_;\r\n\r\n  // Deallocate memory allocated by the buffer.\r\n  FMT_CONSTEXPR20 void deallocate() {\r\n    T* data = this->data();\r\n    if (data != store_) alloc_.deallocate(data, this->capacity());\r\n  }\r\n\r\n protected:\r\n  FMT_CONSTEXPR20 void grow(size_t size) override;\r\n\r\n public:\r\n  using value_type = T;\r\n  using const_reference = const T&;\r\n\r\n  FMT_CONSTEXPR20 explicit basic_memory_buffer(\r\n      const Allocator& alloc = Allocator())\r\n      : alloc_(alloc) {\r\n    this->set(store_, SIZE);\r\n    if (detail::is_constant_evaluated()) {\r\n      detail::fill_n(store_, SIZE, T{});\r\n    }\r\n  }\r\n  FMT_CONSTEXPR20 ~basic_memory_buffer() { deallocate(); }\r\n\r\n private:\r\n  // Move data from other to this buffer.\r\n  FMT_CONSTEXPR20 void move(basic_memory_buffer& other) {\r\n    alloc_ = std::move(other.alloc_);\r\n    T* data = other.data();\r\n    size_t size = other.size(), capacity = other.capacity();\r\n    if (data == other.store_) {\r\n      this->set(store_, capacity);\r\n      if (detail::is_constant_evaluated()) {\r\n        detail::copy_str<T>(other.store_, other.store_ + size,\r\n                            detail::make_checked(store_, capacity));\r\n      } else {\r\n        std::uninitialized_copy(other.store_, other.store_ + size,\r\n                                detail::make_checked(store_, capacity));\r\n      }\r\n    } else {\r\n      this->set(data, capacity);\r\n      // Set pointer to the inline array so that delete is not called\r\n      // when deallocating.\r\n      other.set(other.store_, 0);\r\n    }\r\n    this->resize(size);\r\n  }\r\n\r\n public:\r\n  /**\r\n    \\rst\r\n    Constructs a :class:`fmt::basic_memory_buffer` object moving the content\r\n    of the other object to it.\r\n    \\endrst\r\n   */\r\n  FMT_CONSTEXPR20 basic_memory_buffer(basic_memory_buffer&& other)\r\n      FMT_NOEXCEPT {\r\n    move(other);\r\n  }\r\n\r\n  /**\r\n    \\rst\r\n    Moves the content of the other ``basic_memory_buffer`` object to this one.\r\n    \\endrst\r\n   */\r\n  auto operator=(basic_memory_buffer&& other) FMT_NOEXCEPT\r\n      -> basic_memory_buffer& {\r\n    FMT_ASSERT(this != &other, \"\");\r\n    deallocate();\r\n    move(other);\r\n    return *this;\r\n  }\r\n\r\n  // Returns a copy of the allocator associated with this buffer.\r\n  auto get_allocator() const -> Allocator { return alloc_; }\r\n\r\n  /**\r\n    Resizes the buffer to contain *count* elements. If T is a POD type new\r\n    elements may not be initialized.\r\n   */\r\n  FMT_CONSTEXPR20 void resize(size_t count) { this->try_resize(count); }\r\n\r\n  /** Increases the buffer capacity to *new_capacity*. */\r\n  void reserve(size_t new_capacity) { this->try_reserve(new_capacity); }\r\n\r\n  // Directly append data into the buffer\r\n  using detail::buffer<T>::append;\r\n  template <typename ContiguousRange>\r\n  void append(const ContiguousRange& range) {\r\n    append(range.data(), range.data() + range.size());\r\n  }\r\n};\r\n\r\ntemplate <typename T, size_t SIZE, typename Allocator>\r\nFMT_CONSTEXPR20 void basic_memory_buffer<T, SIZE, Allocator>::grow(\r\n    size_t size) {\r\n#ifdef FMT_FUZZ\r\n  if (size > 5000) throw std::runtime_error(\"fuzz mode - won't grow that much\");\r\n#endif\r\n  const size_t max_size = std::allocator_traits<Allocator>::max_size(alloc_);\r\n  size_t old_capacity = this->capacity();\r\n  size_t new_capacity = old_capacity + old_capacity / 2;\r\n  if (size > new_capacity)\r\n    new_capacity = size;\r\n  else if (new_capacity > max_size)\r\n    new_capacity = size > max_size ? size : max_size;\r\n  T* old_data = this->data();\r\n  T* new_data =\r\n      std::allocator_traits<Allocator>::allocate(alloc_, new_capacity);\r\n  // The following code doesn't throw, so the raw pointer above doesn't leak.\r\n  std::uninitialized_copy(old_data, old_data + this->size(),\r\n                          detail::make_checked(new_data, new_capacity));\r\n  this->set(new_data, new_capacity);\r\n  // deallocate must not throw according to the standard, but even if it does,\r\n  // the buffer already uses the new storage and will deallocate it in\r\n  // destructor.\r\n  if (old_data != store_) alloc_.deallocate(old_data, old_capacity);\r\n}\r\n\r\nusing memory_buffer = basic_memory_buffer<char>;\r\n\r\ntemplate <typename T, size_t SIZE, typename Allocator>\r\nstruct is_contiguous<basic_memory_buffer<T, SIZE, Allocator>> : std::true_type {\r\n};\r\n\r\nnamespace detail {\r\nFMT_API void print(std::FILE*, string_view);\r\n}\r\n\r\n/** A formatting error such as invalid format string. */\r\nFMT_CLASS_API\r\nclass FMT_API format_error : public std::runtime_error {\r\n public:\r\n  explicit format_error(const char* message) : std::runtime_error(message) {}\r\n  explicit format_error(const std::string& message)\r\n      : std::runtime_error(message) {}\r\n  format_error(const format_error&) = default;\r\n  format_error& operator=(const format_error&) = default;\r\n  format_error(format_error&&) = default;\r\n  format_error& operator=(format_error&&) = default;\r\n  ~format_error() FMT_NOEXCEPT override FMT_MSC_DEFAULT;\r\n};\r\n\r\n/**\r\n  \\rst\r\n  Constructs a `~fmt::format_arg_store` object that contains references\r\n  to arguments and can be implicitly converted to `~fmt::format_args`.\r\n  If ``fmt`` is a compile-time string then `make_args_checked` checks\r\n  its validity at compile time.\r\n  \\endrst\r\n */\r\ntemplate <typename... Args, typename S, typename Char = char_t<S>>\r\nFMT_INLINE auto make_args_checked(const S& fmt,\r\n                                  const remove_reference_t<Args>&... args)\r\n    -> format_arg_store<buffer_context<Char>, remove_reference_t<Args>...> {\r\n  static_assert(\r\n      detail::count<(\r\n              std::is_base_of<detail::view, remove_reference_t<Args>>::value &&\r\n              std::is_reference<Args>::value)...>() == 0,\r\n      \"passing views as lvalues is disallowed\");\r\n  detail::check_format_string<Args...>(fmt);\r\n  return {args...};\r\n}\r\n\r\n// compile-time support\r\nnamespace detail_exported {\r\n#if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS\r\ntemplate <typename Char, size_t N> struct fixed_string {\r\n  constexpr fixed_string(const Char (&str)[N]) {\r\n    detail::copy_str<Char, const Char*, Char*>(static_cast<const Char*>(str),\r\n                                               str + N, data);\r\n  }\r\n  Char data[N]{};\r\n};\r\n#endif\r\n\r\n// Converts a compile-time string to basic_string_view.\r\ntemplate <typename Char, size_t N>\r\nconstexpr auto compile_string_to_view(const Char (&s)[N])\r\n    -> basic_string_view<Char> {\r\n  // Remove trailing NUL character if needed. Won't be present if this is used\r\n  // with a raw character array (i.e. not defined as a string).\r\n  return {s, N - (std::char_traits<Char>::to_int_type(s[N - 1]) == 0 ? 1 : 0)};\r\n}\r\ntemplate <typename Char>\r\nconstexpr auto compile_string_to_view(detail::std_string_view<Char> s)\r\n    -> basic_string_view<Char> {\r\n  return {s.data(), s.size()};\r\n}\r\n}  // namespace detail_exported\r\n\r\nFMT_BEGIN_DETAIL_NAMESPACE\r\n\r\ntemplate <typename T> struct is_integral : std::is_integral<T> {};\r\ntemplate <> struct is_integral<int128_t> : std::true_type {};\r\ntemplate <> struct is_integral<uint128_t> : std::true_type {};\r\n\r\ntemplate <typename T>\r\nusing is_signed =\r\n    std::integral_constant<bool, std::numeric_limits<T>::is_signed ||\r\n                                     std::is_same<T, int128_t>::value>;\r\n\r\n// Returns true if value is negative, false otherwise.\r\n// Same as `value < 0` but doesn't produce warnings if T is an unsigned type.\r\ntemplate <typename T, FMT_ENABLE_IF(is_signed<T>::value)>\r\nFMT_CONSTEXPR auto is_negative(T value) -> bool {\r\n  return value < 0;\r\n}\r\ntemplate <typename T, FMT_ENABLE_IF(!is_signed<T>::value)>\r\nFMT_CONSTEXPR auto is_negative(T) -> bool {\r\n  return false;\r\n}\r\n\r\ntemplate <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\r\nFMT_CONSTEXPR auto is_supported_floating_point(T) -> uint16_t {\r\n  return (std::is_same<T, float>::value && FMT_USE_FLOAT) ||\r\n         (std::is_same<T, double>::value && FMT_USE_DOUBLE) ||\r\n         (std::is_same<T, long double>::value && FMT_USE_LONG_DOUBLE);\r\n}\r\n\r\n// Smallest of uint32_t, uint64_t, uint128_t that is large enough to\r\n// represent all values of an integral type T.\r\ntemplate <typename T>\r\nusing uint32_or_64_or_128_t =\r\n    conditional_t<num_bits<T>() <= 32 && !FMT_REDUCE_INT_INSTANTIATIONS,\r\n                  uint32_t,\r\n                  conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>>;\r\ntemplate <typename T>\r\nusing uint64_or_128_t = conditional_t<num_bits<T>() <= 64, uint64_t, uint128_t>;\r\n\r\n#define FMT_POWERS_OF_10(factor)                                             \\\r\n  factor * 10, (factor)*100, (factor)*1000, (factor)*10000, (factor)*100000, \\\r\n      (factor)*1000000, (factor)*10000000, (factor)*100000000,               \\\r\n      (factor)*1000000000\r\n\r\n// Converts value in the range [0, 100) to a string.\r\nconstexpr const char* digits2(size_t value) {\r\n  // GCC generates slightly better code when value is pointer-size.\r\n  return &\"0001020304050607080910111213141516171819\"\r\n         \"2021222324252627282930313233343536373839\"\r\n         \"4041424344454647484950515253545556575859\"\r\n         \"6061626364656667686970717273747576777879\"\r\n         \"8081828384858687888990919293949596979899\"[value * 2];\r\n}\r\n\r\n// Sign is a template parameter to workaround a bug in gcc 4.8.\r\ntemplate <typename Char, typename Sign> constexpr Char sign(Sign s) {\r\n#if !FMT_GCC_VERSION || FMT_GCC_VERSION >= 604\r\n  static_assert(std::is_same<Sign, sign_t>::value, \"\");\r\n#endif\r\n  return static_cast<Char>(\"\\0-+ \"[s]);\r\n}\r\n\r\ntemplate <typename T> FMT_CONSTEXPR auto count_digits_fallback(T n) -> int {\r\n  int count = 1;\r\n  for (;;) {\r\n    // Integer division is slow so do it for a group of four digits instead\r\n    // of for every digit. The idea comes from the talk by Alexandrescu\r\n    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\r\n    if (n < 10) return count;\r\n    if (n < 100) return count + 1;\r\n    if (n < 1000) return count + 2;\r\n    if (n < 10000) return count + 3;\r\n    n /= 10000u;\r\n    count += 4;\r\n  }\r\n}\r\n#if FMT_USE_INT128\r\nFMT_CONSTEXPR inline auto count_digits(uint128_t n) -> int {\r\n  return count_digits_fallback(n);\r\n}\r\n#endif\r\n\r\n#ifdef FMT_BUILTIN_CLZLL\r\n// It is a separate function rather than a part of count_digits to workaround\r\n// the lack of static constexpr in constexpr functions.\r\ninline auto do_count_digits(uint64_t n) -> int {\r\n  // This has comparable performance to the version by Kendall Willets\r\n  // (https://github.com/fmtlib/format-benchmark/blob/master/digits10)\r\n  // but uses smaller tables.\r\n  // Maps bsr(n) to ceil(log10(pow(2, bsr(n) + 1) - 1)).\r\n  static constexpr uint8_t bsr2log10[] = {\r\n      1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  4,  5,  5,  5,\r\n      6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  9,  9,  9,  10, 10, 10,\r\n      10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 15, 15,\r\n      15, 16, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 19, 19, 20};\r\n  auto t = bsr2log10[FMT_BUILTIN_CLZLL(n | 1) ^ 63];\r\n  static constexpr const uint64_t zero_or_powers_of_10[] = {\r\n      0, 0, FMT_POWERS_OF_10(1U), FMT_POWERS_OF_10(1000000000ULL),\r\n      10000000000000000000ULL};\r\n  return t - (n < zero_or_powers_of_10[t]);\r\n}\r\n#endif\r\n\r\n// Returns the number of decimal digits in n. Leading zeros are not counted\r\n// except for n == 0 in which case count_digits returns 1.\r\nFMT_CONSTEXPR20 inline auto count_digits(uint64_t n) -> int {\r\n#ifdef FMT_BUILTIN_CLZLL\r\n  if (!is_constant_evaluated()) {\r\n    return do_count_digits(n);\r\n  }\r\n#endif\r\n  return count_digits_fallback(n);\r\n}\r\n\r\n// Counts the number of digits in n. BITS = log2(radix).\r\ntemplate <int BITS, typename UInt>\r\nFMT_CONSTEXPR auto count_digits(UInt n) -> int {\r\n#ifdef FMT_BUILTIN_CLZ\r\n  if (num_bits<UInt>() == 32)\r\n    return (FMT_BUILTIN_CLZ(static_cast<uint32_t>(n) | 1) ^ 31) / BITS + 1;\r\n#endif\r\n  // Lambda avoids unreachable code warnings from NVHPC.\r\n  return [](UInt m) {\r\n    int num_digits = 0;\r\n    do {\r\n      ++num_digits;\r\n    } while ((m >>= BITS) != 0);\r\n    return num_digits;\r\n  }(n);\r\n}\r\n\r\ntemplate <> auto count_digits<4>(detail::fallback_uintptr n) -> int;\r\n\r\n#ifdef FMT_BUILTIN_CLZ\r\n// It is a separate function rather than a part of count_digits to workaround\r\n// the lack of static constexpr in constexpr functions.\r\nFMT_INLINE auto do_count_digits(uint32_t n) -> int {\r\n// An optimization by Kendall Willets from https://bit.ly/3uOIQrB.\r\n// This increments the upper 32 bits (log10(T) - 1) when >= T is added.\r\n#  define FMT_INC(T) (((sizeof(#  T) - 1ull) << 32) - T)\r\n  static constexpr uint64_t table[] = {\r\n      FMT_INC(0),          FMT_INC(0),          FMT_INC(0),           // 8\r\n      FMT_INC(10),         FMT_INC(10),         FMT_INC(10),          // 64\r\n      FMT_INC(100),        FMT_INC(100),        FMT_INC(100),         // 512\r\n      FMT_INC(1000),       FMT_INC(1000),       FMT_INC(1000),        // 4096\r\n      FMT_INC(10000),      FMT_INC(10000),      FMT_INC(10000),       // 32k\r\n      FMT_INC(100000),     FMT_INC(100000),     FMT_INC(100000),      // 256k\r\n      FMT_INC(1000000),    FMT_INC(1000000),    FMT_INC(1000000),     // 2048k\r\n      FMT_INC(10000000),   FMT_INC(10000000),   FMT_INC(10000000),    // 16M\r\n      FMT_INC(100000000),  FMT_INC(100000000),  FMT_INC(100000000),   // 128M\r\n      FMT_INC(1000000000), FMT_INC(1000000000), FMT_INC(1000000000),  // 1024M\r\n      FMT_INC(1000000000), FMT_INC(1000000000)                        // 4B\r\n  };\r\n  auto inc = table[FMT_BUILTIN_CLZ(n | 1) ^ 31];\r\n  return static_cast<int>((n + inc) >> 32);\r\n}\r\n#endif\r\n\r\n// Optional version of count_digits for better performance on 32-bit platforms.\r\nFMT_CONSTEXPR20 inline auto count_digits(uint32_t n) -> int {\r\n#ifdef FMT_BUILTIN_CLZ\r\n  if (!is_constant_evaluated()) {\r\n    return do_count_digits(n);\r\n  }\r\n#endif\r\n  return count_digits_fallback(n);\r\n}\r\n\r\ntemplate <typename Int> constexpr auto digits10() FMT_NOEXCEPT -> int {\r\n  return std::numeric_limits<Int>::digits10;\r\n}\r\ntemplate <> constexpr auto digits10<int128_t>() FMT_NOEXCEPT -> int {\r\n  return 38;\r\n}\r\ntemplate <> constexpr auto digits10<uint128_t>() FMT_NOEXCEPT -> int {\r\n  return 38;\r\n}\r\n\r\ntemplate <typename Char> struct thousands_sep_result {\r\n  std::string grouping;\r\n  Char thousands_sep;\r\n};\r\n\r\ntemplate <typename Char>\r\nFMT_API auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char>;\r\ntemplate <typename Char>\r\ninline auto thousands_sep(locale_ref loc) -> thousands_sep_result<Char> {\r\n  auto result = thousands_sep_impl<char>(loc);\r\n  return {result.grouping, Char(result.thousands_sep)};\r\n}\r\ntemplate <>\r\ninline auto thousands_sep(locale_ref loc) -> thousands_sep_result<wchar_t> {\r\n  return thousands_sep_impl<wchar_t>(loc);\r\n}\r\n\r\ntemplate <typename Char>\r\nFMT_API auto decimal_point_impl(locale_ref loc) -> Char;\r\ntemplate <typename Char> inline auto decimal_point(locale_ref loc) -> Char {\r\n  return Char(decimal_point_impl<char>(loc));\r\n}\r\ntemplate <> inline auto decimal_point(locale_ref loc) -> wchar_t {\r\n  return decimal_point_impl<wchar_t>(loc);\r\n}\r\n\r\n// Compares two characters for equality.\r\ntemplate <typename Char> auto equal2(const Char* lhs, const char* rhs) -> bool {\r\n  return lhs[0] == Char(rhs[0]) && lhs[1] == Char(rhs[1]);\r\n}\r\ninline auto equal2(const char* lhs, const char* rhs) -> bool {\r\n  return memcmp(lhs, rhs, 2) == 0;\r\n}\r\n\r\n// Copies two characters from src to dst.\r\ntemplate <typename Char>\r\nFMT_CONSTEXPR20 FMT_INLINE void copy2(Char* dst, const char* src) {\r\n  if (!is_constant_evaluated() && sizeof(Char) == sizeof(char)) {\r\n    memcpy(dst, src, 2);\r\n    return;\r\n  }\r\n  *dst++ = static_cast<Char>(*src++);\r\n  *dst = static_cast<Char>(*src);\r\n}\r\n\r\ntemplate <typename Iterator> struct format_decimal_result {\r\n  Iterator begin;\r\n  Iterator end;\r\n};\r\n\r\n// Formats a decimal unsigned integer value writing into out pointing to a\r\n// buffer of specified size. The caller must ensure that the buffer is large\r\n// enough.\r\ntemplate <typename Char, typename UInt>\r\nFMT_CONSTEXPR20 auto format_decimal(Char* out, UInt value, int size)\r\n    -> format_decimal_result<Char*> {\r\n  FMT_ASSERT(size >= count_digits(value), \"invalid digit count\");\r\n  out += size;\r\n  Char* end = out;\r\n  while (value >= 100) {\r\n    // Integer division is slow so do it for a group of two digits instead\r\n    // of for every digit. The idea comes from the talk by Alexandrescu\r\n    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\r\n    out -= 2;\r\n    copy2(out, digits2(static_cast<size_t>(value % 100)));\r\n    value /= 100;\r\n  }\r\n  if (value < 10) {\r\n    *--out = static_cast<Char>('0' + value);\r\n    return {out, end};\r\n  }\r\n  out -= 2;\r\n  copy2(out, digits2(static_cast<size_t>(value)));\r\n  return {out, end};\r\n}\r\n\r\ntemplate <typename Char, typename UInt, typename Iterator,\r\n          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<Iterator>>::value)>\r\ninline auto format_decimal(Iterator out, UInt value, int size)\r\n    -> format_decimal_result<Iterator> {\r\n  // Buffer is large enough to hold all digits (digits10 + 1).\r\n  Char buffer[digits10<UInt>() + 1];\r\n  auto end = format_decimal(buffer, value, size).end;\r\n  return {out, detail::copy_str_noinline<Char>(buffer, end, out)};\r\n}\r\n\r\ntemplate <unsigned BASE_BITS, typename Char, typename UInt>\r\nFMT_CONSTEXPR auto format_uint(Char* buffer, UInt value, int num_digits,\r\n                               bool upper = false) -> Char* {\r\n  buffer += num_digits;\r\n  Char* end = buffer;\r\n  do {\r\n    const char* digits = upper ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\r\n    unsigned digit = (value & ((1 << BASE_BITS) - 1));\r\n    *--buffer = static_cast<Char>(BASE_BITS < 4 ? static_cast<char>('0' + digit)\r\n                                                : digits[digit]);\r\n  } while ((value >>= BASE_BITS) != 0);\r\n  return end;\r\n}\r\n\r\ntemplate <unsigned BASE_BITS, typename Char>\r\nauto format_uint(Char* buffer, detail::fallback_uintptr n, int num_digits,\r\n                 bool = false) -> Char* {\r\n  auto char_digits = std::numeric_limits<unsigned char>::digits / 4;\r\n  int start = (num_digits + char_digits - 1) / char_digits - 1;\r\n  if (int start_digits = num_digits % char_digits) {\r\n    unsigned value = n.value[start--];\r\n    buffer = format_uint<BASE_BITS>(buffer, value, start_digits);\r\n  }\r\n  for (; start >= 0; --start) {\r\n    unsigned value = n.value[start];\r\n    buffer += char_digits;\r\n    auto p = buffer;\r\n    for (int i = 0; i < char_digits; ++i) {\r\n      unsigned digit = (value & ((1 << BASE_BITS) - 1));\r\n      *--p = static_cast<Char>(\"0123456789abcdef\"[digit]);\r\n      value >>= BASE_BITS;\r\n    }\r\n  }\r\n  return buffer;\r\n}\r\n\r\ntemplate <unsigned BASE_BITS, typename Char, typename It, typename UInt>\r\ninline auto format_uint(It out, UInt value, int num_digits, bool upper = false)\r\n    -> It {\r\n  if (auto ptr = to_pointer<Char>(out, to_unsigned(num_digits))) {\r\n    format_uint<BASE_BITS>(ptr, value, num_digits, upper);\r\n    return out;\r\n  }\r\n  // Buffer should be large enough to hold all digits (digits / BASE_BITS + 1).\r\n  char buffer[num_bits<UInt>() / BASE_BITS + 1];\r\n  format_uint<BASE_BITS>(buffer, value, num_digits, upper);\r\n  return detail::copy_str_noinline<Char>(buffer, buffer + num_digits, out);\r\n}\r\n\r\n// A converter from UTF-8 to UTF-16.\r\nclass utf8_to_utf16 {\r\n private:\r\n  basic_memory_buffer<wchar_t> buffer_;\r\n\r\n public:\r\n  FMT_API explicit utf8_to_utf16(string_view s);\r\n  operator basic_string_view<wchar_t>() const { return {&buffer_[0], size()}; }\r\n  auto size() const -> size_t { return buffer_.size() - 1; }\r\n  auto c_str() const -> const wchar_t* { return &buffer_[0]; }\r\n  auto str() const -> std::wstring { return {&buffer_[0], size()}; }\r\n};\r\n\r\nnamespace dragonbox {\r\n\r\n// Type-specific information that Dragonbox uses.\r\ntemplate <class T> struct float_info;\r\n\r\ntemplate <> struct float_info<float> {\r\n  using carrier_uint = uint32_t;\r\n  static const int significand_bits = 23;\r\n  static const int exponent_bits = 8;\r\n  static const int min_exponent = -126;\r\n  static const int max_exponent = 127;\r\n  static const int exponent_bias = -127;\r\n  static const int decimal_digits = 9;\r\n  static const int kappa = 1;\r\n  static const int big_divisor = 100;\r\n  static const int small_divisor = 10;\r\n  static const int min_k = -31;\r\n  static const int max_k = 46;\r\n  static const int cache_bits = 64;\r\n  static const int divisibility_check_by_5_threshold = 39;\r\n  static const int case_fc_pm_half_lower_threshold = -1;\r\n  static const int case_fc_pm_half_upper_threshold = 6;\r\n  static const int case_fc_lower_threshold = -2;\r\n  static const int case_fc_upper_threshold = 6;\r\n  static const int case_shorter_interval_left_endpoint_lower_threshold = 2;\r\n  static const int case_shorter_interval_left_endpoint_upper_threshold = 3;\r\n  static const int shorter_interval_tie_lower_threshold = -35;\r\n  static const int shorter_interval_tie_upper_threshold = -35;\r\n  static const int max_trailing_zeros = 7;\r\n};\r\n\r\ntemplate <> struct float_info<double> {\r\n  using carrier_uint = uint64_t;\r\n  static const int significand_bits = 52;\r\n  static const int exponent_bits = 11;\r\n  static const int min_exponent = -1022;\r\n  static const int max_exponent = 1023;\r\n  static const int exponent_bias = -1023;\r\n  static const int decimal_digits = 17;\r\n  static const int kappa = 2;\r\n  static const int big_divisor = 1000;\r\n  static const int small_divisor = 100;\r\n  static const int min_k = -292;\r\n  static const int max_k = 326;\r\n  static const int cache_bits = 128;\r\n  static const int divisibility_check_by_5_threshold = 86;\r\n  static const int case_fc_pm_half_lower_threshold = -2;\r\n  static const int case_fc_pm_half_upper_threshold = 9;\r\n  static const int case_fc_lower_threshold = -4;\r\n  static const int case_fc_upper_threshold = 9;\r\n  static const int case_shorter_interval_left_endpoint_lower_threshold = 2;\r\n  static const int case_shorter_interval_left_endpoint_upper_threshold = 3;\r\n  static const int shorter_interval_tie_lower_threshold = -77;\r\n  static const int shorter_interval_tie_upper_threshold = -77;\r\n  static const int max_trailing_zeros = 16;\r\n};\r\n\r\ntemplate <typename T> struct decimal_fp {\r\n  using significand_type = typename float_info<T>::carrier_uint;\r\n  significand_type significand;\r\n  int exponent;\r\n};\r\n\r\ntemplate <typename T>\r\nFMT_API auto to_decimal(T x) FMT_NOEXCEPT -> decimal_fp<T>;\r\n}  // namespace dragonbox\r\n\r\ntemplate <typename T>\r\nconstexpr auto exponent_mask() ->\r\n    typename dragonbox::float_info<T>::carrier_uint {\r\n  using uint = typename dragonbox::float_info<T>::carrier_uint;\r\n  return ((uint(1) << dragonbox::float_info<T>::exponent_bits) - 1)\r\n         << dragonbox::float_info<T>::significand_bits;\r\n}\r\n\r\n// Writes the exponent exp in the form \"[+-]d{2,3}\" to buffer.\r\ntemplate <typename Char, typename It>\r\nFMT_CONSTEXPR auto write_exponent(int exp, It it) -> It {\r\n  FMT_ASSERT(-10000 < exp && exp < 10000, \"exponent out of range\");\r\n  if (exp < 0) {\r\n    *it++ = static_cast<Char>('-');\r\n    exp = -exp;\r\n  } else {\r\n    *it++ = static_cast<Char>('+');\r\n  }\r\n  if (exp >= 100) {\r\n    const char* top = digits2(to_unsigned(exp / 100));\r\n    if (exp >= 1000) *it++ = static_cast<Char>(top[0]);\r\n    *it++ = static_cast<Char>(top[1]);\r\n    exp %= 100;\r\n  }\r\n  const char* d = digits2(to_unsigned(exp));\r\n  *it++ = static_cast<Char>(d[0]);\r\n  *it++ = static_cast<Char>(d[1]);\r\n  return it;\r\n}\r\n\r\ntemplate <typename T>\r\nFMT_HEADER_ONLY_CONSTEXPR20 auto format_float(T value, int precision,\r\n                                              float_specs specs,\r\n                                              buffer<char>& buf) -> int;\r\n\r\n// Formats a floating-point number with snprintf.\r\ntemplate <typename T>\r\nauto snprintf_float(T value, int precision, float_specs specs,\r\n                    buffer<char>& buf) -> int;\r\n\r\ntemplate <typename T> constexpr auto promote_float(T value) -> T {\r\n  return value;\r\n}\r\nconstexpr auto promote_float(float value) -> double {\r\n  return static_cast<double>(value);\r\n}\r\n\r\ntemplate <typename OutputIt, typename Char>\r\nFMT_NOINLINE FMT_CONSTEXPR auto fill(OutputIt it, size_t n,\r\n                                     const fill_t<Char>& fill) -> OutputIt {\r\n  auto fill_size = fill.size();\r\n  if (fill_size == 1) return detail::fill_n(it, n, fill[0]);\r\n  auto data = fill.data();\r\n  for (size_t i = 0; i < n; ++i)\r\n    it = copy_str<Char>(data, data + fill_size, it);\r\n  return it;\r\n}\r\n\r\n// Writes the output of f, padded according to format specifications in specs.\r\n// size: output size in code units.\r\n// width: output display width in (terminal) column positions.\r\ntemplate <align::type align = align::left, typename OutputIt, typename Char,\r\n          typename F>\r\nFMT_CONSTEXPR auto write_padded(OutputIt out,\r\n                                const basic_format_specs<Char>& specs,\r\n                                size_t size, size_t width, F&& f) -> OutputIt {\r\n  static_assert(align == align::left || align == align::right, \"\");\r\n  unsigned spec_width = to_unsigned(specs.width);\r\n  size_t padding = spec_width > width ? spec_width - width : 0;\r\n  // Shifts are encoded as string literals because static constexpr is not\r\n  // supported in constexpr functions.\r\n  auto* shifts = align == align::left ? \"\\x1f\\x1f\\x00\\x01\" : \"\\x00\\x1f\\x00\\x01\";\r\n  size_t left_padding = padding >> shifts[specs.align];\r\n  size_t right_padding = padding - left_padding;\r\n  auto it = reserve(out, size + padding * specs.fill.size());\r\n  if (left_padding != 0) it = fill(it, left_padding, specs.fill);\r\n  it = f(it);\r\n  if (right_padding != 0) it = fill(it, right_padding, specs.fill);\r\n  return base_iterator(out, it);\r\n}\r\n\r\ntemplate <align::type align = align::left, typename OutputIt, typename Char,\r\n          typename F>\r\nconstexpr auto write_padded(OutputIt out, const basic_format_specs<Char>& specs,\r\n                            size_t size, F&& f) -> OutputIt {\r\n  return write_padded<align>(out, specs, size, size, f);\r\n}\r\n\r\ntemplate <align::type align = align::left, typename Char, typename OutputIt>\r\nFMT_CONSTEXPR auto write_bytes(OutputIt out, string_view bytes,\r\n                               const basic_format_specs<Char>& specs)\r\n    -> OutputIt {\r\n  return write_padded<align>(\r\n      out, specs, bytes.size(), [bytes](reserve_iterator<OutputIt> it) {\r\n        const char* data = bytes.data();\r\n        return copy_str<Char>(data, data + bytes.size(), it);\r\n      });\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt, typename UIntPtr>\r\nauto write_ptr(OutputIt out, UIntPtr value,\r\n               const basic_format_specs<Char>* specs) -> OutputIt {\r\n  int num_digits = count_digits<4>(value);\r\n  auto size = to_unsigned(num_digits) + size_t(2);\r\n  auto write = [=](reserve_iterator<OutputIt> it) {\r\n    *it++ = static_cast<Char>('0');\r\n    *it++ = static_cast<Char>('x');\r\n    return format_uint<4, Char>(it, value, num_digits);\r\n  };\r\n  return specs ? write_padded<align::right>(out, *specs, size, write)\r\n               : base_iterator(out, write(reserve(out, size)));\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt>\r\nFMT_CONSTEXPR auto write_char(OutputIt out, Char value,\r\n                              const basic_format_specs<Char>& specs)\r\n    -> OutputIt {\r\n  return write_padded(out, specs, 1, [=](reserve_iterator<OutputIt> it) {\r\n    *it++ = value;\r\n    return it;\r\n  });\r\n}\r\ntemplate <typename Char, typename OutputIt>\r\nFMT_CONSTEXPR auto write(OutputIt out, Char value,\r\n                         const basic_format_specs<Char>& specs,\r\n                         locale_ref loc = {}) -> OutputIt {\r\n  return check_char_specs(specs)\r\n             ? write_char(out, value, specs)\r\n             : write(out, static_cast<int>(value), specs, loc);\r\n}\r\n\r\n// Data for write_int that doesn't depend on output iterator type. It is used to\r\n// avoid template code bloat.\r\ntemplate <typename Char> struct write_int_data {\r\n  size_t size;\r\n  size_t padding;\r\n\r\n  FMT_CONSTEXPR write_int_data(int num_digits, unsigned prefix,\r\n                               const basic_format_specs<Char>& specs)\r\n      : size((prefix >> 24) + to_unsigned(num_digits)), padding(0) {\r\n    if (specs.align == align::numeric) {\r\n      auto width = to_unsigned(specs.width);\r\n      if (width > size) {\r\n        padding = width - size;\r\n        size = width;\r\n      }\r\n    } else if (specs.precision > num_digits) {\r\n      size = (prefix >> 24) + to_unsigned(specs.precision);\r\n      padding = to_unsigned(specs.precision - num_digits);\r\n    }\r\n  }\r\n};\r\n\r\n// Writes an integer in the format\r\n//   <left-padding><prefix><numeric-padding><digits><right-padding>\r\n// where <digits> are written by write_digits(it).\r\n// prefix contains chars in three lower bytes and the size in the fourth byte.\r\ntemplate <typename OutputIt, typename Char, typename W>\r\nFMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, int num_digits,\r\n                                        unsigned prefix,\r\n                                        const basic_format_specs<Char>& specs,\r\n                                        W write_digits) -> OutputIt {\r\n  // Slightly faster check for specs.width == 0 && specs.precision == -1.\r\n  if ((specs.width | (specs.precision + 1)) == 0) {\r\n    auto it = reserve(out, to_unsigned(num_digits) + (prefix >> 24));\r\n    if (prefix != 0) {\r\n      for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)\r\n        *it++ = static_cast<Char>(p & 0xff);\r\n    }\r\n    return base_iterator(out, write_digits(it));\r\n  }\r\n  auto data = write_int_data<Char>(num_digits, prefix, specs);\r\n  return write_padded<align::right>(\r\n      out, specs, data.size, [=](reserve_iterator<OutputIt> it) {\r\n        for (unsigned p = prefix & 0xffffff; p != 0; p >>= 8)\r\n          *it++ = static_cast<Char>(p & 0xff);\r\n        it = detail::fill_n(it, data.padding, static_cast<Char>('0'));\r\n        return write_digits(it);\r\n      });\r\n}\r\n\r\ntemplate <typename Char> class digit_grouping {\r\n private:\r\n  thousands_sep_result<Char> sep_;\r\n\r\n  struct next_state {\r\n    std::string::const_iterator group;\r\n    int pos;\r\n  };\r\n  next_state initial_state() const { return {sep_.grouping.begin(), 0}; }\r\n\r\n  // Returns the next digit group separator position.\r\n  int next(next_state& state) const {\r\n    if (!sep_.thousands_sep) return max_value<int>();\r\n    if (state.group == sep_.grouping.end())\r\n      return state.pos += sep_.grouping.back();\r\n    if (*state.group <= 0 || *state.group == max_value<char>())\r\n      return max_value<int>();\r\n    state.pos += *state.group++;\r\n    return state.pos;\r\n  }\r\n\r\n public:\r\n  explicit digit_grouping(locale_ref loc, bool localized = true) {\r\n    if (localized)\r\n      sep_ = thousands_sep<Char>(loc);\r\n    else\r\n      sep_.thousands_sep = Char();\r\n  }\r\n  explicit digit_grouping(thousands_sep_result<Char> sep) : sep_(sep) {}\r\n\r\n  Char separator() const { return sep_.thousands_sep; }\r\n\r\n  int count_separators(int num_digits) const {\r\n    int count = 0;\r\n    auto state = initial_state();\r\n    while (num_digits > next(state)) ++count;\r\n    return count;\r\n  }\r\n\r\n  // Applies grouping to digits and write the output to out.\r\n  template <typename Out, typename C>\r\n  Out apply(Out out, basic_string_view<C> digits) const {\r\n    auto num_digits = static_cast<int>(digits.size());\r\n    auto separators = basic_memory_buffer<int>();\r\n    separators.push_back(0);\r\n    auto state = initial_state();\r\n    while (int i = next(state)) {\r\n      if (i >= num_digits) break;\r\n      separators.push_back(i);\r\n    }\r\n    for (int i = 0, sep_index = static_cast<int>(separators.size() - 1);\r\n         i < num_digits; ++i) {\r\n      if (num_digits - i == separators[sep_index]) {\r\n        *out++ = separator();\r\n        --sep_index;\r\n      }\r\n      *out++ = static_cast<Char>(digits[to_unsigned(i)]);\r\n    }\r\n    return out;\r\n  }\r\n};\r\n\r\ntemplate <typename OutputIt, typename UInt, typename Char>\r\nauto write_int_localized(OutputIt out, UInt value, unsigned prefix,\r\n                         const basic_format_specs<Char>& specs,\r\n                         const digit_grouping<Char>& grouping) -> OutputIt {\r\n  static_assert(std::is_same<uint64_or_128_t<UInt>, UInt>::value, \"\");\r\n  int num_digits = count_digits(value);\r\n  char digits[40];\r\n  format_decimal(digits, value, num_digits);\r\n  unsigned size = to_unsigned((prefix != 0 ? 1 : 0) + num_digits +\r\n                              grouping.count_separators(num_digits));\r\n  return write_padded<align::right>(\r\n      out, specs, size, size, [&](reserve_iterator<OutputIt> it) {\r\n        if (prefix != 0) *it++ = static_cast<Char>(prefix);\r\n        return grouping.apply(it, string_view(digits, to_unsigned(num_digits)));\r\n      });\r\n}\r\n\r\ntemplate <typename OutputIt, typename UInt, typename Char>\r\nauto write_int_localized(OutputIt& out, UInt value, unsigned prefix,\r\n                         const basic_format_specs<Char>& specs, locale_ref loc)\r\n    -> bool {\r\n  auto grouping = digit_grouping<Char>(loc);\r\n  out = write_int_localized(out, value, prefix, specs, grouping);\r\n  return true;\r\n}\r\n\r\nFMT_CONSTEXPR inline void prefix_append(unsigned& prefix, unsigned value) {\r\n  prefix |= prefix != 0 ? value << 8 : value;\r\n  prefix += (1u + (value > 0xff ? 1 : 0)) << 24;\r\n}\r\n\r\ntemplate <typename UInt> struct write_int_arg {\r\n  UInt abs_value;\r\n  unsigned prefix;\r\n};\r\n\r\ntemplate <typename T>\r\nFMT_CONSTEXPR auto make_write_int_arg(T value, sign_t sign)\r\n    -> write_int_arg<uint32_or_64_or_128_t<T>> {\r\n  auto prefix = 0u;\r\n  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);\r\n  if (is_negative(value)) {\r\n    prefix = 0x01000000 | '-';\r\n    abs_value = 0 - abs_value;\r\n  } else {\r\n    constexpr const unsigned prefixes[4] = {0, 0, 0x1000000u | '+',\r\n                                            0x1000000u | ' '};\r\n    prefix = prefixes[sign];\r\n  }\r\n  return {abs_value, prefix};\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt, typename T>\r\nFMT_CONSTEXPR FMT_INLINE auto write_int(OutputIt out, write_int_arg<T> arg,\r\n                                        const basic_format_specs<Char>& specs,\r\n                                        locale_ref loc) -> OutputIt {\r\n  static_assert(std::is_same<T, uint32_or_64_or_128_t<T>>::value, \"\");\r\n  auto abs_value = arg.abs_value;\r\n  auto prefix = arg.prefix;\r\n  switch (specs.type) {\r\n  case presentation_type::none:\r\n  case presentation_type::dec: {\r\n    if (specs.localized &&\r\n        write_int_localized(out, static_cast<uint64_or_128_t<T>>(abs_value),\r\n                            prefix, specs, loc)) {\r\n      return out;\r\n    }\r\n    auto num_digits = count_digits(abs_value);\r\n    return write_int(\r\n        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {\r\n          return format_decimal<Char>(it, abs_value, num_digits).end;\r\n        });\r\n  }\r\n  case presentation_type::hex_lower:\r\n  case presentation_type::hex_upper: {\r\n    bool upper = specs.type == presentation_type::hex_upper;\r\n    if (specs.alt)\r\n      prefix_append(prefix, unsigned(upper ? 'X' : 'x') << 8 | '0');\r\n    int num_digits = count_digits<4>(abs_value);\r\n    return write_int(\r\n        out, num_digits, prefix, specs, [=](reserve_iterator<OutputIt> it) {\r\n          return format_uint<4, Char>(it, abs_value, num_digits, upper);\r\n        });\r\n  }\r\n  case presentation_type::bin_lower:\r\n  case presentation_type::bin_upper: {\r\n    bool upper = specs.type == presentation_type::bin_upper;\r\n    if (specs.alt)\r\n      prefix_append(prefix, unsigned(upper ? 'B' : 'b') << 8 | '0');\r\n    int num_digits = count_digits<1>(abs_value);\r\n    return write_int(out, num_digits, prefix, specs,\r\n                     [=](reserve_iterator<OutputIt> it) {\r\n                       return format_uint<1, Char>(it, abs_value, num_digits);\r\n                     });\r\n  }\r\n  case presentation_type::oct: {\r\n    int num_digits = count_digits<3>(abs_value);\r\n    // Octal prefix '0' is counted as a digit, so only add it if precision\r\n    // is not greater than the number of digits.\r\n    if (specs.alt && specs.precision <= num_digits && abs_value != 0)\r\n      prefix_append(prefix, '0');\r\n    return write_int(out, num_digits, prefix, specs,\r\n                     [=](reserve_iterator<OutputIt> it) {\r\n                       return format_uint<3, Char>(it, abs_value, num_digits);\r\n                     });\r\n  }\r\n  case presentation_type::chr:\r\n    return write_char(out, static_cast<Char>(abs_value), specs);\r\n  default:\r\n    throw_format_error(\"invalid type specifier\");\r\n  }\r\n  return out;\r\n}\r\ntemplate <typename Char, typename OutputIt, typename T>\r\nFMT_CONSTEXPR FMT_NOINLINE auto write_int_noinline(\r\n    OutputIt out, write_int_arg<T> arg, const basic_format_specs<Char>& specs,\r\n    locale_ref loc) -> OutputIt {\r\n  return write_int(out, arg, specs, loc);\r\n}\r\ntemplate <typename Char, typename OutputIt, typename T,\r\n          FMT_ENABLE_IF(is_integral<T>::value &&\r\n                        !std::is_same<T, bool>::value &&\r\n                        std::is_same<OutputIt, buffer_appender<Char>>::value)>\r\nFMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,\r\n                                    const basic_format_specs<Char>& specs,\r\n                                    locale_ref loc) -> OutputIt {\r\n  return write_int_noinline(out, make_write_int_arg(value, specs.sign), specs,\r\n                            loc);\r\n}\r\n// An inlined version of write used in format string compilation.\r\ntemplate <typename Char, typename OutputIt, typename T,\r\n          FMT_ENABLE_IF(is_integral<T>::value &&\r\n                        !std::is_same<T, bool>::value &&\r\n                        !std::is_same<OutputIt, buffer_appender<Char>>::value)>\r\nFMT_CONSTEXPR FMT_INLINE auto write(OutputIt out, T value,\r\n                                    const basic_format_specs<Char>& specs,\r\n                                    locale_ref loc) -> OutputIt {\r\n  return write_int(out, make_write_int_arg(value, specs.sign), specs, loc);\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt>\r\nFMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> s,\r\n                         const basic_format_specs<Char>& specs) -> OutputIt {\r\n  auto data = s.data();\r\n  auto size = s.size();\r\n  if (specs.precision >= 0 && to_unsigned(specs.precision) < size)\r\n    size = code_point_index(s, to_unsigned(specs.precision));\r\n  auto width =\r\n      specs.width != 0 ? compute_width(basic_string_view<Char>(data, size)) : 0;\r\n  return write_padded(out, specs, size, width,\r\n                      [=](reserve_iterator<OutputIt> it) {\r\n                        return copy_str<Char>(data, data + size, it);\r\n                      });\r\n}\r\ntemplate <typename Char, typename OutputIt>\r\nFMT_CONSTEXPR auto write(OutputIt out,\r\n                         basic_string_view<type_identity_t<Char>> s,\r\n                         const basic_format_specs<Char>& specs, locale_ref)\r\n    -> OutputIt {\r\n  check_string_type_spec(specs.type);\r\n  return write(out, s, specs);\r\n}\r\ntemplate <typename Char, typename OutputIt>\r\nFMT_CONSTEXPR auto write(OutputIt out, const Char* s,\r\n                         const basic_format_specs<Char>& specs, locale_ref)\r\n    -> OutputIt {\r\n  return check_cstring_type_spec(specs.type)\r\n             ? write(out, basic_string_view<Char>(s), specs, {})\r\n             : write_ptr<Char>(out, to_uintptr(s), &specs);\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt>\r\nFMT_CONSTEXPR20 auto write_nonfinite(OutputIt out, bool isinf,\r\n                                     basic_format_specs<Char> specs,\r\n                                     const float_specs& fspecs) -> OutputIt {\r\n  auto str =\r\n      isinf ? (fspecs.upper ? \"INF\" : \"inf\") : (fspecs.upper ? \"NAN\" : \"nan\");\r\n  constexpr size_t str_size = 3;\r\n  auto sign = fspecs.sign;\r\n  auto size = str_size + (sign ? 1 : 0);\r\n  // Replace '0'-padding with space for non-finite values.\r\n  const bool is_zero_fill =\r\n      specs.fill.size() == 1 && *specs.fill.data() == static_cast<Char>('0');\r\n  if (is_zero_fill) specs.fill[0] = static_cast<Char>(' ');\r\n  return write_padded(out, specs, size, [=](reserve_iterator<OutputIt> it) {\r\n    if (sign) *it++ = detail::sign<Char>(sign);\r\n    return copy_str<Char>(str, str + str_size, it);\r\n  });\r\n}\r\n\r\n// A decimal floating-point number significand * pow(10, exp).\r\nstruct big_decimal_fp {\r\n  const char* significand;\r\n  int significand_size;\r\n  int exponent;\r\n};\r\n\r\nconstexpr auto get_significand_size(const big_decimal_fp& fp) -> int {\r\n  return fp.significand_size;\r\n}\r\ntemplate <typename T>\r\ninline auto get_significand_size(const dragonbox::decimal_fp<T>& fp) -> int {\r\n  return count_digits(fp.significand);\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt>\r\nconstexpr auto write_significand(OutputIt out, const char* significand,\r\n                                 int significand_size) -> OutputIt {\r\n  return copy_str<Char>(significand, significand + significand_size, out);\r\n}\r\ntemplate <typename Char, typename OutputIt, typename UInt>\r\ninline auto write_significand(OutputIt out, UInt significand,\r\n                              int significand_size) -> OutputIt {\r\n  return format_decimal<Char>(out, significand, significand_size).end;\r\n}\r\ntemplate <typename Char, typename OutputIt, typename T, typename Grouping>\r\nFMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,\r\n                                       int significand_size, int exponent,\r\n                                       const Grouping& grouping) -> OutputIt {\r\n  if (!grouping.separator()) {\r\n    out = write_significand<Char>(out, significand, significand_size);\r\n    return detail::fill_n(out, exponent, static_cast<Char>('0'));\r\n  }\r\n  auto buffer = memory_buffer();\r\n  write_significand<char>(appender(buffer), significand, significand_size);\r\n  detail::fill_n(appender(buffer), exponent, '0');\r\n  return grouping.apply(out, string_view(buffer.data(), buffer.size()));\r\n}\r\n\r\ntemplate <typename Char, typename UInt,\r\n          FMT_ENABLE_IF(std::is_integral<UInt>::value)>\r\ninline auto write_significand(Char* out, UInt significand, int significand_size,\r\n                              int integral_size, Char decimal_point) -> Char* {\r\n  if (!decimal_point)\r\n    return format_decimal(out, significand, significand_size).end;\r\n  out += significand_size + 1;\r\n  Char* end = out;\r\n  int floating_size = significand_size - integral_size;\r\n  for (int i = floating_size / 2; i > 0; --i) {\r\n    out -= 2;\r\n    copy2(out, digits2(significand % 100));\r\n    significand /= 100;\r\n  }\r\n  if (floating_size % 2 != 0) {\r\n    *--out = static_cast<Char>('0' + significand % 10);\r\n    significand /= 10;\r\n  }\r\n  *--out = decimal_point;\r\n  format_decimal(out - integral_size, significand, integral_size);\r\n  return end;\r\n}\r\n\r\ntemplate <typename OutputIt, typename UInt, typename Char,\r\n          FMT_ENABLE_IF(!std::is_pointer<remove_cvref_t<OutputIt>>::value)>\r\ninline auto write_significand(OutputIt out, UInt significand,\r\n                              int significand_size, int integral_size,\r\n                              Char decimal_point) -> OutputIt {\r\n  // Buffer is large enough to hold digits (digits10 + 1) and a decimal point.\r\n  Char buffer[digits10<UInt>() + 2];\r\n  auto end = write_significand(buffer, significand, significand_size,\r\n                               integral_size, decimal_point);\r\n  return detail::copy_str_noinline<Char>(buffer, end, out);\r\n}\r\n\r\ntemplate <typename OutputIt, typename Char>\r\nFMT_CONSTEXPR auto write_significand(OutputIt out, const char* significand,\r\n                                     int significand_size, int integral_size,\r\n                                     Char decimal_point) -> OutputIt {\r\n  out = detail::copy_str_noinline<Char>(significand,\r\n                                        significand + integral_size, out);\r\n  if (!decimal_point) return out;\r\n  *out++ = decimal_point;\r\n  return detail::copy_str_noinline<Char>(significand + integral_size,\r\n                                         significand + significand_size, out);\r\n}\r\n\r\ntemplate <typename OutputIt, typename Char, typename T, typename Grouping>\r\nFMT_CONSTEXPR20 auto write_significand(OutputIt out, T significand,\r\n                                       int significand_size, int integral_size,\r\n                                       Char decimal_point,\r\n                                       const Grouping& grouping) -> OutputIt {\r\n  if (!grouping.separator()) {\r\n    return write_significand(out, significand, significand_size, integral_size,\r\n                             decimal_point);\r\n  }\r\n  auto buffer = basic_memory_buffer<Char>();\r\n  write_significand(buffer_appender<Char>(buffer), significand,\r\n                    significand_size, integral_size, decimal_point);\r\n  grouping.apply(\r\n      out, basic_string_view<Char>(buffer.data(), to_unsigned(integral_size)));\r\n  return detail::copy_str_noinline<Char>(buffer.data() + integral_size,\r\n                                         buffer.end(), out);\r\n}\r\n\r\ntemplate <typename OutputIt, typename DecimalFP, typename Char,\r\n          typename Grouping = digit_grouping<Char>>\r\nFMT_CONSTEXPR20 auto do_write_float(OutputIt out, const DecimalFP& fp,\r\n                                    const basic_format_specs<Char>& specs,\r\n                                    float_specs fspecs, locale_ref loc)\r\n    -> OutputIt {\r\n  auto significand = fp.significand;\r\n  int significand_size = get_significand_size(fp);\r\n  constexpr Char zero = static_cast<Char>('0');\r\n  auto sign = fspecs.sign;\r\n  size_t size = to_unsigned(significand_size) + (sign ? 1 : 0);\r\n  using iterator = reserve_iterator<OutputIt>;\r\n\r\n  Char decimal_point =\r\n      fspecs.locale ? detail::decimal_point<Char>(loc) : static_cast<Char>('.');\r\n\r\n  int output_exp = fp.exponent + significand_size - 1;\r\n  auto use_exp_format = [=]() {\r\n    if (fspecs.format == float_format::exp) return true;\r\n    if (fspecs.format != float_format::general) return false;\r\n    // Use the fixed notation if the exponent is in [exp_lower, exp_upper),\r\n    // e.g. 0.0001 instead of 1e-04. Otherwise use the exponent notation.\r\n    const int exp_lower = -4, exp_upper = 16;\r\n    return output_exp < exp_lower ||\r\n           output_exp >= (fspecs.precision > 0 ? fspecs.precision : exp_upper);\r\n  };\r\n  if (use_exp_format()) {\r\n    int num_zeros = 0;\r\n    if (fspecs.showpoint) {\r\n      num_zeros = fspecs.precision - significand_size;\r\n      if (num_zeros < 0) num_zeros = 0;\r\n      size += to_unsigned(num_zeros);\r\n    } else if (significand_size == 1) {\r\n      decimal_point = Char();\r\n    }\r\n    auto abs_output_exp = output_exp >= 0 ? output_exp : -output_exp;\r\n    int exp_digits = 2;\r\n    if (abs_output_exp >= 100) exp_digits = abs_output_exp >= 1000 ? 4 : 3;\r\n\r\n    size += to_unsigned((decimal_point ? 1 : 0) + 2 + exp_digits);\r\n    char exp_char = fspecs.upper ? 'E' : 'e';\r\n    auto write = [=](iterator it) {\r\n      if (sign) *it++ = detail::sign<Char>(sign);\r\n      // Insert a decimal point after the first digit and add an exponent.\r\n      it = write_significand(it, significand, significand_size, 1,\r\n                             decimal_point);\r\n      if (num_zeros > 0) it = detail::fill_n(it, num_zeros, zero);\r\n      *it++ = static_cast<Char>(exp_char);\r\n      return write_exponent<Char>(output_exp, it);\r\n    };\r\n    return specs.width > 0 ? write_padded<align::right>(out, specs, size, write)\r\n                           : base_iterator(out, write(reserve(out, size)));\r\n  }\r\n\r\n  int exp = fp.exponent + significand_size;\r\n  if (fp.exponent >= 0) {\r\n    // 1234e5 -> 123400000[.0+]\r\n    size += to_unsigned(fp.exponent);\r\n    int num_zeros = fspecs.precision - exp;\r\n#ifdef FMT_FUZZ\r\n    if (num_zeros > 5000)\r\n      throw std::runtime_error(\"fuzz mode - avoiding excessive cpu use\");\r\n#endif\r\n    if (fspecs.showpoint) {\r\n      if (num_zeros <= 0 && fspecs.format != float_format::fixed) num_zeros = 1;\r\n      if (num_zeros > 0) size += to_unsigned(num_zeros) + 1;\r\n    }\r\n    auto grouping = Grouping(loc, fspecs.locale);\r\n    size += to_unsigned(grouping.count_separators(significand_size));\r\n    return write_padded<align::right>(out, specs, size, [&](iterator it) {\r\n      if (sign) *it++ = detail::sign<Char>(sign);\r\n      it = write_significand<Char>(it, significand, significand_size,\r\n                                   fp.exponent, grouping);\r\n      if (!fspecs.showpoint) return it;\r\n      *it++ = decimal_point;\r\n      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;\r\n    });\r\n  } else if (exp > 0) {\r\n    // 1234e-2 -> 12.34[0+]\r\n    int num_zeros = fspecs.showpoint ? fspecs.precision - significand_size : 0;\r\n    size += 1 + to_unsigned(num_zeros > 0 ? num_zeros : 0);\r\n    auto grouping = Grouping(loc, fspecs.locale);\r\n    size += to_unsigned(grouping.count_separators(significand_size));\r\n    return write_padded<align::right>(out, specs, size, [&](iterator it) {\r\n      if (sign) *it++ = detail::sign<Char>(sign);\r\n      it = write_significand(it, significand, significand_size, exp,\r\n                             decimal_point, grouping);\r\n      return num_zeros > 0 ? detail::fill_n(it, num_zeros, zero) : it;\r\n    });\r\n  }\r\n  // 1234e-6 -> 0.001234\r\n  int num_zeros = -exp;\r\n  if (significand_size == 0 && fspecs.precision >= 0 &&\r\n      fspecs.precision < num_zeros) {\r\n    num_zeros = fspecs.precision;\r\n  }\r\n  bool pointy = num_zeros != 0 || significand_size != 0 || fspecs.showpoint;\r\n  size += 1 + (pointy ? 1 : 0) + to_unsigned(num_zeros);\r\n  return write_padded<align::right>(out, specs, size, [&](iterator it) {\r\n    if (sign) *it++ = detail::sign<Char>(sign);\r\n    *it++ = zero;\r\n    if (!pointy) return it;\r\n    *it++ = decimal_point;\r\n    it = detail::fill_n(it, num_zeros, zero);\r\n    return write_significand<Char>(it, significand, significand_size);\r\n  });\r\n}\r\n\r\ntemplate <typename Char> class fallback_digit_grouping {\r\n public:\r\n  constexpr fallback_digit_grouping(locale_ref, bool) {}\r\n\r\n  constexpr Char separator() const { return Char(); }\r\n\r\n  constexpr int count_separators(int) const { return 0; }\r\n\r\n  template <typename Out, typename C>\r\n  constexpr Out apply(Out out, basic_string_view<C>) const {\r\n    return out;\r\n  }\r\n};\r\n\r\ntemplate <typename OutputIt, typename DecimalFP, typename Char>\r\nFMT_CONSTEXPR20 auto write_float(OutputIt out, const DecimalFP& fp,\r\n                                 const basic_format_specs<Char>& specs,\r\n                                 float_specs fspecs, locale_ref loc)\r\n    -> OutputIt {\r\n  if (is_constant_evaluated()) {\r\n    return do_write_float<OutputIt, DecimalFP, Char,\r\n                          fallback_digit_grouping<Char>>(out, fp, specs, fspecs,\r\n                                                         loc);\r\n  } else {\r\n    return do_write_float(out, fp, specs, fspecs, loc);\r\n  }\r\n}\r\n\r\ntemplate <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\r\nFMT_CONSTEXPR20 bool isinf(T value) {\r\n  if (is_constant_evaluated()) {\r\n#if defined(__cpp_if_constexpr)\r\n    if constexpr (std::numeric_limits<double>::is_iec559) {\r\n      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));\r\n      constexpr auto significand_bits =\r\n          dragonbox::float_info<double>::significand_bits;\r\n      return (bits & exponent_mask<double>()) &&\r\n             !(bits & ((uint64_t(1) << significand_bits) - 1));\r\n    }\r\n#endif\r\n  }\r\n  return std::isinf(value);\r\n}\r\n\r\ntemplate <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\r\nFMT_CONSTEXPR20 bool isfinite(T value) {\r\n  if (is_constant_evaluated()) {\r\n#if defined(__cpp_if_constexpr)\r\n    if constexpr (std::numeric_limits<double>::is_iec559) {\r\n      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));\r\n      return (bits & exponent_mask<double>()) != exponent_mask<double>();\r\n    }\r\n#endif\r\n  }\r\n  return std::isfinite(value);\r\n}\r\n\r\ntemplate <typename T, FMT_ENABLE_IF(std::is_floating_point<T>::value)>\r\nFMT_INLINE FMT_CONSTEXPR bool signbit(T value) {\r\n  if (is_constant_evaluated()) {\r\n#ifdef __cpp_if_constexpr\r\n    if constexpr (std::numeric_limits<double>::is_iec559) {\r\n      auto bits = detail::bit_cast<uint64_t>(static_cast<double>(value));\r\n      return (bits & (uint64_t(1) << (num_bits<uint64_t>() - 1))) != 0;\r\n    }\r\n#endif\r\n  }\r\n  return std::signbit(value);\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt, typename T,\r\n          FMT_ENABLE_IF(std::is_floating_point<T>::value)>\r\nFMT_CONSTEXPR20 auto write(OutputIt out, T value,\r\n                           basic_format_specs<Char> specs, locale_ref loc = {})\r\n    -> OutputIt {\r\n  if (const_check(!is_supported_floating_point(value))) return out;\r\n  float_specs fspecs = parse_float_type_spec(specs);\r\n  fspecs.sign = specs.sign;\r\n  if (detail::signbit(value)) {  // value < 0 is false for NaN so use signbit.\r\n    fspecs.sign = sign::minus;\r\n    value = -value;\r\n  } else if (fspecs.sign == sign::minus) {\r\n    fspecs.sign = sign::none;\r\n  }\r\n\r\n  if (!detail::isfinite(value))\r\n    return write_nonfinite(out, detail::isinf(value), specs, fspecs);\r\n\r\n  if (specs.align == align::numeric && fspecs.sign) {\r\n    auto it = reserve(out, 1);\r\n    *it++ = detail::sign<Char>(fspecs.sign);\r\n    out = base_iterator(out, it);\r\n    fspecs.sign = sign::none;\r\n    if (specs.width != 0) --specs.width;\r\n  }\r\n\r\n  memory_buffer buffer;\r\n  if (fspecs.format == float_format::hex) {\r\n    if (fspecs.sign) buffer.push_back(detail::sign<char>(fspecs.sign));\r\n    snprintf_float(promote_float(value), specs.precision, fspecs, buffer);\r\n    return write_bytes<align::right>(out, {buffer.data(), buffer.size()},\r\n                                     specs);\r\n  }\r\n  int precision = specs.precision >= 0 || specs.type == presentation_type::none\r\n                      ? specs.precision\r\n                      : 6;\r\n  if (fspecs.format == float_format::exp) {\r\n    if (precision == max_value<int>())\r\n      throw_format_error(\"number is too big\");\r\n    else\r\n      ++precision;\r\n  }\r\n  if (const_check(std::is_same<T, float>())) fspecs.binary32 = true;\r\n  if (!is_fast_float<T>()) fspecs.fallback = true;\r\n  int exp = format_float(promote_float(value), precision, fspecs, buffer);\r\n  fspecs.precision = precision;\r\n  auto fp = big_decimal_fp{buffer.data(), static_cast<int>(buffer.size()), exp};\r\n  return write_float(out, fp, specs, fspecs, loc);\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt, typename T,\r\n          FMT_ENABLE_IF(is_fast_float<T>::value)>\r\nFMT_CONSTEXPR20 auto write(OutputIt out, T value) -> OutputIt {\r\n  if (is_constant_evaluated()) {\r\n    return write(out, value, basic_format_specs<Char>());\r\n  }\r\n\r\n  if (const_check(!is_supported_floating_point(value))) return out;\r\n\r\n  using floaty = conditional_t<std::is_same<T, long double>::value, double, T>;\r\n  using uint = typename dragonbox::float_info<floaty>::carrier_uint;\r\n  auto bits = bit_cast<uint>(value);\r\n\r\n  auto fspecs = float_specs();\r\n  if (detail::signbit(value)) {\r\n    fspecs.sign = sign::minus;\r\n    value = -value;\r\n  }\r\n\r\n  constexpr auto specs = basic_format_specs<Char>();\r\n  uint mask = exponent_mask<floaty>();\r\n  if ((bits & mask) == mask)\r\n    return write_nonfinite(out, std::isinf(value), specs, fspecs);\r\n\r\n  auto dec = dragonbox::to_decimal(static_cast<floaty>(value));\r\n  return write_float(out, dec, specs, fspecs, {});\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt, typename T,\r\n          FMT_ENABLE_IF(std::is_floating_point<T>::value &&\r\n                        !is_fast_float<T>::value)>\r\ninline auto write(OutputIt out, T value) -> OutputIt {\r\n  return write(out, value, basic_format_specs<Char>());\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt>\r\nauto write(OutputIt out, monostate, basic_format_specs<Char> = {},\r\n           locale_ref = {}) -> OutputIt {\r\n  FMT_ASSERT(false, \"\");\r\n  return out;\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt>\r\nFMT_CONSTEXPR auto write(OutputIt out, basic_string_view<Char> value)\r\n    -> OutputIt {\r\n  auto it = reserve(out, value.size());\r\n  it = copy_str_noinline<Char>(value.begin(), value.end(), it);\r\n  return base_iterator(out, it);\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt, typename T,\r\n          FMT_ENABLE_IF(is_string<T>::value)>\r\nconstexpr auto write(OutputIt out, const T& value) -> OutputIt {\r\n  return write<Char>(out, to_string_view(value));\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt, typename T,\r\n          FMT_ENABLE_IF(is_integral<T>::value &&\r\n                        !std::is_same<T, bool>::value &&\r\n                        !std::is_same<T, Char>::value)>\r\nFMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {\r\n  auto abs_value = static_cast<uint32_or_64_or_128_t<T>>(value);\r\n  bool negative = is_negative(value);\r\n  // Don't do -abs_value since it trips unsigned-integer-overflow sanitizer.\r\n  if (negative) abs_value = ~abs_value + 1;\r\n  int num_digits = count_digits(abs_value);\r\n  auto size = (negative ? 1 : 0) + static_cast<size_t>(num_digits);\r\n  auto it = reserve(out, size);\r\n  if (auto ptr = to_pointer<Char>(it, size)) {\r\n    if (negative) *ptr++ = static_cast<Char>('-');\r\n    format_decimal<Char>(ptr, abs_value, num_digits);\r\n    return out;\r\n  }\r\n  if (negative) *it++ = static_cast<Char>('-');\r\n  it = format_decimal<Char>(it, abs_value, num_digits).end;\r\n  return base_iterator(out, it);\r\n}\r\n\r\n// FMT_ENABLE_IF() condition separated to workaround an MSVC bug.\r\ntemplate <\r\n    typename Char, typename OutputIt, typename T,\r\n    bool check =\r\n        std::is_enum<T>::value && !std::is_same<T, Char>::value &&\r\n        mapped_type_constant<T, basic_format_context<OutputIt, Char>>::value !=\r\n            type::custom_type,\r\n    FMT_ENABLE_IF(check)>\r\nFMT_CONSTEXPR auto write(OutputIt out, T value) -> OutputIt {\r\n  return write<Char>(\r\n      out, static_cast<typename std::underlying_type<T>::type>(value));\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt, typename T,\r\n          FMT_ENABLE_IF(std::is_same<T, bool>::value)>\r\nFMT_CONSTEXPR auto write(OutputIt out, T value,\r\n                         const basic_format_specs<Char>& specs = {},\r\n                         locale_ref = {}) -> OutputIt {\r\n  return specs.type != presentation_type::none &&\r\n                 specs.type != presentation_type::string\r\n             ? write(out, value ? 1 : 0, specs, {})\r\n             : write_bytes(out, value ? \"true\" : \"false\", specs);\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt>\r\nFMT_CONSTEXPR auto write(OutputIt out, Char value) -> OutputIt {\r\n  auto it = reserve(out, 1);\r\n  *it++ = value;\r\n  return base_iterator(out, it);\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt>\r\nFMT_CONSTEXPR_CHAR_TRAITS auto write(OutputIt out, const Char* value)\r\n    -> OutputIt {\r\n  if (!value) {\r\n    throw_format_error(\"string pointer is null\");\r\n  } else {\r\n    out = write(out, basic_string_view<Char>(value));\r\n  }\r\n  return out;\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt, typename T,\r\n          FMT_ENABLE_IF(std::is_same<T, void>::value)>\r\nauto write(OutputIt out, const T* value,\r\n           const basic_format_specs<Char>& specs = {}, locale_ref = {})\r\n    -> OutputIt {\r\n  check_pointer_type_spec(specs.type, error_handler());\r\n  return write_ptr<Char>(out, to_uintptr(value), &specs);\r\n}\r\n\r\n// A write overload that handles implicit conversions.\r\ntemplate <typename Char, typename OutputIt, typename T,\r\n          typename Context = basic_format_context<OutputIt, Char>>\r\nFMT_CONSTEXPR auto write(OutputIt out, const T& value) -> enable_if_t<\r\n    std::is_class<T>::value && !is_string<T>::value &&\r\n        !std::is_same<T, Char>::value &&\r\n        !std::is_same<const T&,\r\n                      decltype(arg_mapper<Context>().map(value))>::value,\r\n    OutputIt> {\r\n  return write<Char>(out, arg_mapper<Context>().map(value));\r\n}\r\n\r\ntemplate <typename Char, typename OutputIt, typename T,\r\n          typename Context = basic_format_context<OutputIt, Char>>\r\nFMT_CONSTEXPR auto write(OutputIt out, const T& value)\r\n    -> enable_if_t<mapped_type_constant<T, Context>::value == type::custom_type,\r\n                   OutputIt> {\r\n  using formatter_type =\r\n      conditional_t<has_formatter<T, Context>::value,\r\n                    typename Context::template formatter_type<T>,\r\n                    fallback_formatter<T, Char>>;\r\n  auto ctx = Context(out, {}, {});\r\n  return formatter_type().format(value, ctx);\r\n}\r\n\r\n// An argument visitor that formats the argument and writes it via the output\r\n// iterator. It's a class and not a generic lambda for compatibility with C++11.\r\ntemplate <typename Char> struct default_arg_formatter {\r\n  using iterator = buffer_appender<Char>;\r\n  using context = buffer_context<Char>;\r\n\r\n  iterator out;\r\n  basic_format_args<context> args;\r\n  locale_ref loc;\r\n\r\n  template <typename T> auto operator()(T value) -> iterator {\r\n    return write<Char>(out, value);\r\n  }\r\n  auto operator()(typename basic_format_arg<context>::handle h) -> iterator {\r\n    basic_format_parse_context<Char> parse_ctx({});\r\n    context format_ctx(out, args, loc);\r\n    h.format(parse_ctx, format_ctx);\r\n    return format_ctx.out();\r\n  }\r\n};\r\n\r\ntemplate <typename Char> struct arg_formatter {\r\n  using iterator = buffer_appender<Char>;\r\n  using context = buffer_context<Char>;\r\n\r\n  iterator out;\r\n  const basic_format_specs<Char>& specs;\r\n  locale_ref locale;\r\n\r\n  template <typename T>\r\n  FMT_CONSTEXPR FMT_INLINE auto operator()(T value) -> iterator {\r\n    return detail::write(out, value, specs, locale);\r\n  }\r\n  auto operator()(typename basic_format_arg<context>::handle) -> iterator {\r\n    // User-defined types are handled separately because they require access\r\n    // to the parse context.\r\n    return out;\r\n  }\r\n};\r\n\r\ntemplate <typename Char> struct custom_formatter {\r\n  basic_format_parse_context<Char>& parse_ctx;\r\n  buffer_context<Char>& ctx;\r\n\r\n  void operator()(\r\n      typename basic_format_arg<buffer_context<Char>>::handle h) const {\r\n    h.format(parse_ctx, ctx);\r\n  }\r\n  template <typename T> void operator()(T) const {}\r\n};\r\n\r\ntemplate <typename T>\r\nusing is_integer =\r\n    bool_constant<is_integral<T>::value && !std::is_same<T, bool>::value &&\r\n                  !std::is_same<T, char>::value &&\r\n                  !std::is_same<T, wchar_t>::value>;\r\n\r\ntemplate <typename ErrorHandler> class width_checker {\r\n public:\r\n  explicit FMT_CONSTEXPR width_checker(ErrorHandler& eh) : handler_(eh) {}\r\n\r\n  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>\r\n  FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {\r\n    if (is_negative(value)) handler_.on_error(\"negative width\");\r\n    return static_cast<unsigned long long>(value);\r\n  }\r\n\r\n  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>\r\n  FMT_CONSTEXPR auto operator()(T) -> unsigned long long {\r\n    handler_.on_error(\"width is not integer\");\r\n    return 0;\r\n  }\r\n\r\n private:\r\n  ErrorHandler& handler_;\r\n};\r\n\r\ntemplate <typename ErrorHandler> class precision_checker {\r\n public:\r\n  explicit FMT_CONSTEXPR precision_checker(ErrorHandler& eh) : handler_(eh) {}\r\n\r\n  template <typename T, FMT_ENABLE_IF(is_integer<T>::value)>\r\n  FMT_CONSTEXPR auto operator()(T value) -> unsigned long long {\r\n    if (is_negative(value)) handler_.on_error(\"negative precision\");\r\n    return static_cast<unsigned long long>(value);\r\n  }\r\n\r\n  template <typename T, FMT_ENABLE_IF(!is_integer<T>::value)>\r\n  FMT_CONSTEXPR auto operator()(T) -> unsigned long long {\r\n    handler_.on_error(\"precision is not integer\");\r\n    return 0;\r\n  }\r\n\r\n private:\r\n  ErrorHandler& handler_;\r\n};\r\n\r\ntemplate <template <typename> class Handler, typename FormatArg,\r\n          typename ErrorHandler>\r\nFMT_CONSTEXPR auto get_dynamic_spec(FormatArg arg, ErrorHandler eh) -> int {\r\n  unsigned long long value = visit_format_arg(Handler<ErrorHandler>(eh), arg);\r\n  if (value > to_unsigned(max_value<int>())) eh.on_error(\"number is too big\");\r\n  return static_cast<int>(value);\r\n}\r\n\r\ntemplate <typename Context, typename ID>\r\nFMT_CONSTEXPR auto get_arg(Context& ctx, ID id) ->\r\n    typename Context::format_arg {\r\n  auto arg = ctx.arg(id);\r\n  if (!arg) ctx.on_error(\"argument not found\");\r\n  return arg;\r\n}\r\n\r\n// The standard format specifier handler with checking.\r\ntemplate <typename Char> class specs_handler : public specs_setter<Char> {\r\n private:\r\n  basic_format_parse_context<Char>& parse_context_;\r\n  buffer_context<Char>& context_;\r\n\r\n  // This is only needed for compatibility with gcc 4.4.\r\n  using format_arg = basic_format_arg<buffer_context<Char>>;\r\n\r\n  FMT_CONSTEXPR auto get_arg(auto_id) -> format_arg {\r\n    return detail::get_arg(context_, parse_context_.next_arg_id());\r\n  }\r\n\r\n  FMT_CONSTEXPR auto get_arg(int arg_id) -> format_arg {\r\n    parse_context_.check_arg_id(arg_id);\r\n    return detail::get_arg(context_, arg_id);\r\n  }\r\n\r\n  FMT_CONSTEXPR auto get_arg(basic_string_view<Char> arg_id) -> format_arg {\r\n    parse_context_.check_arg_id(arg_id);\r\n    return detail::get_arg(context_, arg_id);\r\n  }\r\n\r\n public:\r\n  FMT_CONSTEXPR specs_handler(basic_format_specs<Char>& specs,\r\n                              basic_format_parse_context<Char>& parse_ctx,\r\n                              buffer_context<Char>& ctx)\r\n      : specs_setter<Char>(specs), parse_context_(parse_ctx), context_(ctx) {}\r\n\r\n  template <typename Id> FMT_CONSTEXPR void on_dynamic_width(Id arg_id) {\r\n    this->specs_.width = get_dynamic_spec<width_checker>(\r\n        get_arg(arg_id), context_.error_handler());\r\n  }\r\n\r\n  template <typename Id> FMT_CONSTEXPR void on_dynamic_precision(Id arg_id) {\r\n    this->specs_.precision = get_dynamic_spec<precision_checker>(\r\n        get_arg(arg_id), context_.error_handler());\r\n  }\r\n\r\n  void on_error(const char* message) { context_.on_error(message); }\r\n};\r\n\r\ntemplate <template <typename> class Handler, typename Context>\r\nFMT_CONSTEXPR void handle_dynamic_spec(int& value,\r\n                                       arg_ref<typename Context::char_type> ref,\r\n                                       Context& ctx) {\r\n  switch (ref.kind) {\r\n  case arg_id_kind::none:\r\n    break;\r\n  case arg_id_kind::index:\r\n    value = detail::get_dynamic_spec<Handler>(ctx.arg(ref.val.index),\r\n                                              ctx.error_handler());\r\n    break;\r\n  case arg_id_kind::name:\r\n    value = detail::get_dynamic_spec<Handler>(ctx.arg(ref.val.name),\r\n                                              ctx.error_handler());\r\n    break;\r\n  }\r\n}\r\n\r\n#define FMT_STRING_IMPL(s, base, explicit)                                 \\\r\n  [] {                                                                     \\\r\n    /* Use the hidden visibility as a workaround for a GCC bug (#1973). */ \\\r\n    /* Use a macro-like name to avoid shadowing warnings. */               \\\r\n    struct FMT_GCC_VISIBILITY_HIDDEN FMT_COMPILE_STRING : base {           \\\r\n      using char_type = fmt::remove_cvref_t<decltype(s[0])>;               \\\r\n      FMT_MAYBE_UNUSED FMT_CONSTEXPR explicit                              \\\r\n      operator fmt::basic_string_view<char_type>() const {                 \\\r\n        return fmt::detail_exported::compile_string_to_view<char_type>(s); \\\r\n      }                                                                    \\\r\n    };                                                                     \\\r\n    return FMT_COMPILE_STRING();                                           \\\r\n  }()\r\n\r\n/**\r\n  \\rst\r\n  Constructs a compile-time format string from a string literal *s*.\r\n\r\n  **Example**::\r\n\r\n    // A compile-time error because 'd' is an invalid specifier for strings.\r\n    std::string s = fmt::format(FMT_STRING(\"{:d}\"), \"foo\");\r\n  \\endrst\r\n */\r\n#define FMT_STRING(s) FMT_STRING_IMPL(s, fmt::compile_string, )\r\n\r\n#if FMT_USE_USER_DEFINED_LITERALS\r\ntemplate <typename Char> struct udl_formatter {\r\n  basic_string_view<Char> str;\r\n\r\n  template <typename... T>\r\n  auto operator()(T&&... args) const -> std::basic_string<Char> {\r\n    return vformat(str, fmt::make_args_checked<T...>(str, args...));\r\n  }\r\n};\r\n\r\n#  if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS\r\ntemplate <typename T, typename Char, size_t N,\r\n          fmt::detail_exported::fixed_string<Char, N> Str>\r\nstruct statically_named_arg : view {\r\n  static constexpr auto name = Str.data;\r\n\r\n  const T& value;\r\n  statically_named_arg(const T& v) : value(v) {}\r\n};\r\n\r\ntemplate <typename T, typename Char, size_t N,\r\n          fmt::detail_exported::fixed_string<Char, N> Str>\r\nstruct is_named_arg<statically_named_arg<T, Char, N, Str>> : std::true_type {};\r\n\r\ntemplate <typename T, typename Char, size_t N,\r\n          fmt::detail_exported::fixed_string<Char, N> Str>\r\nstruct is_statically_named_arg<statically_named_arg<T, Char, N, Str>>\r\n    : std::true_type {};\r\n\r\ntemplate <typename Char, size_t N,\r\n          fmt::detail_exported::fixed_string<Char, N> Str>\r\nstruct udl_arg {\r\n  template <typename T> auto operator=(T&& value) const {\r\n    return statically_named_arg<T, Char, N, Str>(std::forward<T>(value));\r\n  }\r\n};\r\n#  else\r\ntemplate <typename Char> struct udl_arg {\r\n  const Char* str;\r\n\r\n  template <typename T> auto operator=(T&& value) const -> named_arg<Char, T> {\r\n    return {str, std::forward<T>(value)};\r\n  }\r\n};\r\n#  endif\r\n#endif  // FMT_USE_USER_DEFINED_LITERALS\r\n\r\ntemplate <typename Locale, typename Char>\r\nauto vformat(const Locale& loc, basic_string_view<Char> format_str,\r\n             basic_format_args<buffer_context<type_identity_t<Char>>> args)\r\n    -> std::basic_string<Char> {\r\n  basic_memory_buffer<Char> buffer;\r\n  detail::vformat_to(buffer, format_str, args, detail::locale_ref(loc));\r\n  return {buffer.data(), buffer.size()};\r\n}\r\n\r\nusing format_func = void (*)(detail::buffer<char>&, int, const char*);\r\n\r\nFMT_API void format_error_code(buffer<char>& out, int error_code,\r\n                               string_view message) FMT_NOEXCEPT;\r\n\r\nFMT_API void report_error(format_func func, int error_code,\r\n                          const char* message) FMT_NOEXCEPT;\r\nFMT_END_DETAIL_NAMESPACE\r\n\r\nFMT_API auto vsystem_error(int error_code, string_view format_str,\r\n                           format_args args) -> std::system_error;\r\n\r\n/**\r\n \\rst\r\n Constructs :class:`std::system_error` with a message formatted with\r\n ``fmt::format(fmt, args...)``.\r\n  *error_code* is a system error code as given by ``errno``.\r\n\r\n **Example**::\r\n\r\n   // This throws std::system_error with the description\r\n   //   cannot open file 'madeup': No such file or directory\r\n   // or similar (system message may vary).\r\n   const char* filename = \"madeup\";\r\n   std::FILE* file = std::fopen(filename, \"r\");\r\n   if (!file)\r\n     throw fmt::system_error(errno, \"cannot open file '{}'\", filename);\r\n \\endrst\r\n*/\r\ntemplate <typename... T>\r\nauto system_error(int error_code, format_string<T...> fmt, T&&... args)\r\n    -> std::system_error {\r\n  return vsystem_error(error_code, fmt, fmt::make_format_args(args...));\r\n}\r\n\r\n/**\r\n  \\rst\r\n  Formats an error message for an error returned by an operating system or a\r\n  language runtime, for example a file opening error, and writes it to *out*.\r\n  The format is the same as the one used by ``std::system_error(ec, message)``\r\n  where ``ec`` is ``std::error_code(error_code, std::generic_category()})``.\r\n  It is implementation-defined but normally looks like:\r\n\r\n  .. parsed-literal::\r\n     *<message>*: *<system-message>*\r\n\r\n  where *<message>* is the passed message and *<system-message>* is the system\r\n  message corresponding to the error code.\r\n  *error_code* is a system error code as given by ``errno``.\r\n  \\endrst\r\n */\r\nFMT_API void format_system_error(detail::buffer<char>& out, int error_code,\r\n                                 const char* message) FMT_NOEXCEPT;\r\n\r\n// Reports a system error without throwing an exception.\r\n// Can be used to report errors from destructors.\r\nFMT_API void report_system_error(int error_code,\r\n                                 const char* message) FMT_NOEXCEPT;\r\n\r\n/** Fast integer formatter. */\r\nclass format_int {\r\n private:\r\n  // Buffer should be large enough to hold all digits (digits10 + 1),\r\n  // a sign and a null character.\r\n  enum { buffer_size = std::numeric_limits<unsigned long long>::digits10 + 3 };\r\n  mutable char buffer_[buffer_size];\r\n  char* str_;\r\n\r\n  template <typename UInt> auto format_unsigned(UInt value) -> char* {\r\n    auto n = static_cast<detail::uint32_or_64_or_128_t<UInt>>(value);\r\n    return detail::format_decimal(buffer_, n, buffer_size - 1).begin;\r\n  }\r\n\r\n  template <typename Int> auto format_signed(Int value) -> char* {\r\n    auto abs_value = static_cast<detail::uint32_or_64_or_128_t<Int>>(value);\r\n    bool negative = value < 0;\r\n    if (negative) abs_value = 0 - abs_value;\r\n    auto begin = format_unsigned(abs_value);\r\n    if (negative) *--begin = '-';\r\n    return begin;\r\n  }\r\n\r\n public:\r\n  explicit format_int(int value) : str_(format_signed(value)) {}\r\n  explicit format_int(long value) : str_(format_signed(value)) {}\r\n  explicit format_int(long long value) : str_(format_signed(value)) {}\r\n  explicit format_int(unsigned value) : str_(format_unsigned(value)) {}\r\n  explicit format_int(unsigned long value) : str_(format_unsigned(value)) {}\r\n  explicit format_int(unsigned long long value)\r\n      : str_(format_unsigned(value)) {}\r\n\r\n  /** Returns the number of characters written to the output buffer. */\r\n  auto size() const -> size_t {\r\n    return detail::to_unsigned(buffer_ - str_ + buffer_size - 1);\r\n  }\r\n\r\n  /**\r\n    Returns a pointer to the output buffer content. No terminating null\r\n    character is appended.\r\n   */\r\n  auto data() const -> const char* { return str_; }\r\n\r\n  /**\r\n    Returns a pointer to the output buffer content with terminating null\r\n    character appended.\r\n   */\r\n  auto c_str() const -> const char* {\r\n    buffer_[buffer_size - 1] = '\\0';\r\n    return str_;\r\n  }\r\n\r\n  /**\r\n    \\rst\r\n    Returns the content of the output buffer as an ``std::string``.\r\n    \\endrst\r\n   */\r\n  auto str() const -> std::string { return std::string(str_, size()); }\r\n};\r\n\r\ntemplate <typename T, typename Char>\r\ntemplate <typename FormatContext>\r\nFMT_CONSTEXPR FMT_INLINE auto\r\nformatter<T, Char,\r\n          enable_if_t<detail::type_constant<T, Char>::value !=\r\n                      detail::type::custom_type>>::format(const T& val,\r\n                                                          FormatContext& ctx)\r\n    const -> decltype(ctx.out()) {\r\n  if (specs_.width_ref.kind != detail::arg_id_kind::none ||\r\n      specs_.precision_ref.kind != detail::arg_id_kind::none) {\r\n    auto specs = specs_;\r\n    detail::handle_dynamic_spec<detail::width_checker>(specs.width,\r\n                                                       specs.width_ref, ctx);\r\n    detail::handle_dynamic_spec<detail::precision_checker>(\r\n        specs.precision, specs.precision_ref, ctx);\r\n    return detail::write<Char>(ctx.out(), val, specs, ctx.locale());\r\n  }\r\n  return detail::write<Char>(ctx.out(), val, specs_, ctx.locale());\r\n}\r\n\r\n#define FMT_FORMAT_AS(Type, Base)                                        \\\r\n  template <typename Char>                                               \\\r\n  struct formatter<Type, Char> : formatter<Base, Char> {                 \\\r\n    template <typename FormatContext>                                    \\\r\n    auto format(Type const& val, FormatContext& ctx) const               \\\r\n        -> decltype(ctx.out()) {                                         \\\r\n      return formatter<Base, Char>::format(static_cast<Base>(val), ctx); \\\r\n    }                                                                    \\\r\n  }\r\n\r\nFMT_FORMAT_AS(signed char, int);\r\nFMT_FORMAT_AS(unsigned char, unsigned);\r\nFMT_FORMAT_AS(short, int);\r\nFMT_FORMAT_AS(unsigned short, unsigned);\r\nFMT_FORMAT_AS(long, long long);\r\nFMT_FORMAT_AS(unsigned long, unsigned long long);\r\nFMT_FORMAT_AS(Char*, const Char*);\r\nFMT_FORMAT_AS(std::basic_string<Char>, basic_string_view<Char>);\r\nFMT_FORMAT_AS(std::nullptr_t, const void*);\r\nFMT_FORMAT_AS(detail::byte, unsigned char);\r\nFMT_FORMAT_AS(detail::std_string_view<Char>, basic_string_view<Char>);\r\n\r\ntemplate <typename Char>\r\nstruct formatter<void*, Char> : formatter<const void*, Char> {\r\n  template <typename FormatContext>\r\n  auto format(void* val, FormatContext& ctx) const -> decltype(ctx.out()) {\r\n    return formatter<const void*, Char>::format(val, ctx);\r\n  }\r\n};\r\n\r\ntemplate <typename Char, size_t N>\r\nstruct formatter<Char[N], Char> : formatter<basic_string_view<Char>, Char> {\r\n  template <typename FormatContext>\r\n  FMT_CONSTEXPR auto format(const Char* val, FormatContext& ctx) const\r\n      -> decltype(ctx.out()) {\r\n    return formatter<basic_string_view<Char>, Char>::format(val, ctx);\r\n  }\r\n};\r\n\r\n// A formatter for types known only at run time such as variant alternatives.\r\n//\r\n// Usage:\r\n//   using variant = std::variant<int, std::string>;\r\n//   template <>\r\n//   struct formatter<variant>: dynamic_formatter<> {\r\n//     auto format(const variant& v, format_context& ctx) {\r\n//       return visit([&](const auto& val) {\r\n//           return dynamic_formatter<>::format(val, ctx);\r\n//       }, v);\r\n//     }\r\n//   };\r\ntemplate <typename Char = char> class dynamic_formatter {\r\n private:\r\n  detail::dynamic_format_specs<Char> specs_;\r\n  const Char* format_str_;\r\n\r\n  struct null_handler : detail::error_handler {\r\n    void on_align(align_t) {}\r\n    void on_sign(sign_t) {}\r\n    void on_hash() {}\r\n  };\r\n\r\n  template <typename Context> void handle_specs(Context& ctx) {\r\n    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,\r\n                                                       specs_.width_ref, ctx);\r\n    detail::handle_dynamic_spec<detail::precision_checker>(\r\n        specs_.precision, specs_.precision_ref, ctx);\r\n  }\r\n\r\n public:\r\n  template <typename ParseContext>\r\n  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\r\n    format_str_ = ctx.begin();\r\n    // Checks are deferred to formatting time when the argument type is known.\r\n    detail::dynamic_specs_handler<ParseContext> handler(specs_, ctx);\r\n    return detail::parse_format_specs(ctx.begin(), ctx.end(), handler);\r\n  }\r\n\r\n  template <typename T, typename FormatContext>\r\n  auto format(const T& val, FormatContext& ctx) -> decltype(ctx.out()) {\r\n    handle_specs(ctx);\r\n    detail::specs_checker<null_handler> checker(\r\n        null_handler(), detail::mapped_type_constant<T, FormatContext>::value);\r\n    checker.on_align(specs_.align);\r\n    if (specs_.sign != sign::none) checker.on_sign(specs_.sign);\r\n    if (specs_.alt) checker.on_hash();\r\n    if (specs_.precision >= 0) checker.end_precision();\r\n    return detail::write<Char>(ctx.out(), val, specs_, ctx.locale());\r\n  }\r\n};\r\n\r\n/**\r\n  \\rst\r\n  Converts ``p`` to ``const void*`` for pointer formatting.\r\n\r\n  **Example**::\r\n\r\n    auto s = fmt::format(\"{}\", fmt::ptr(p));\r\n  \\endrst\r\n */\r\ntemplate <typename T> auto ptr(T p) -> const void* {\r\n  static_assert(std::is_pointer<T>::value, \"\");\r\n  return detail::bit_cast<const void*>(p);\r\n}\r\ntemplate <typename T> auto ptr(const std::unique_ptr<T>& p) -> const void* {\r\n  return p.get();\r\n}\r\ntemplate <typename T> auto ptr(const std::shared_ptr<T>& p) -> const void* {\r\n  return p.get();\r\n}\r\n\r\nclass bytes {\r\n private:\r\n  string_view data_;\r\n  friend struct formatter<bytes>;\r\n\r\n public:\r\n  explicit bytes(string_view data) : data_(data) {}\r\n};\r\n\r\ntemplate <> struct formatter<bytes> {\r\n private:\r\n  detail::dynamic_format_specs<char> specs_;\r\n\r\n public:\r\n  template <typename ParseContext>\r\n  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\r\n    using handler_type = detail::dynamic_specs_handler<ParseContext>;\r\n    detail::specs_checker<handler_type> handler(handler_type(specs_, ctx),\r\n                                                detail::type::string_type);\r\n    auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);\r\n    detail::check_string_type_spec(specs_.type, ctx.error_handler());\r\n    return it;\r\n  }\r\n\r\n  template <typename FormatContext>\r\n  auto format(bytes b, FormatContext& ctx) -> decltype(ctx.out()) {\r\n    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,\r\n                                                       specs_.width_ref, ctx);\r\n    detail::handle_dynamic_spec<detail::precision_checker>(\r\n        specs_.precision, specs_.precision_ref, ctx);\r\n    return detail::write_bytes(ctx.out(), b.data_, specs_);\r\n  }\r\n};\r\n\r\n// group_digits_view is not derived from view because it copies the argument.\r\ntemplate <typename T> struct group_digits_view { T value; };\r\n\r\n/**\r\n  \\rst\r\n  Returns a view that formats an integer value using ',' as a locale-independent\r\n  thousands separator.\r\n\r\n  **Example**::\r\n\r\n    fmt::print(\"{}\", fmt::group_digits(12345));\r\n    // Output: \"12,345\"\r\n  \\endrst\r\n */\r\ntemplate <typename T> auto group_digits(T value) -> group_digits_view<T> {\r\n  return {value};\r\n}\r\n\r\ntemplate <typename T> struct formatter<group_digits_view<T>> : formatter<T> {\r\n private:\r\n  detail::dynamic_format_specs<char> specs_;\r\n\r\n public:\r\n  template <typename ParseContext>\r\n  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\r\n    using handler_type = detail::dynamic_specs_handler<ParseContext>;\r\n    detail::specs_checker<handler_type> handler(handler_type(specs_, ctx),\r\n                                                detail::type::int_type);\r\n    auto it = parse_format_specs(ctx.begin(), ctx.end(), handler);\r\n    detail::check_string_type_spec(specs_.type, ctx.error_handler());\r\n    return it;\r\n  }\r\n\r\n  template <typename FormatContext>\r\n  auto format(group_digits_view<T> t, FormatContext& ctx)\r\n      -> decltype(ctx.out()) {\r\n    detail::handle_dynamic_spec<detail::width_checker>(specs_.width,\r\n                                                       specs_.width_ref, ctx);\r\n    detail::handle_dynamic_spec<detail::precision_checker>(\r\n        specs_.precision, specs_.precision_ref, ctx);\r\n    return detail::write_int_localized(\r\n        ctx.out(), static_cast<detail::uint64_or_128_t<T>>(t.value), 0, specs_,\r\n        detail::digit_grouping<char>({\"\\3\", ','}));\r\n  }\r\n};\r\n\r\ntemplate <typename It, typename Sentinel, typename Char = char>\r\nstruct join_view : detail::view {\r\n  It begin;\r\n  Sentinel end;\r\n  basic_string_view<Char> sep;\r\n\r\n  join_view(It b, Sentinel e, basic_string_view<Char> s)\r\n      : begin(b), end(e), sep(s) {}\r\n};\r\n\r\ntemplate <typename It, typename Sentinel, typename Char>\r\nusing arg_join FMT_DEPRECATED_ALIAS = join_view<It, Sentinel, Char>;\r\n\r\ntemplate <typename It, typename Sentinel, typename Char>\r\nstruct formatter<join_view<It, Sentinel, Char>, Char> {\r\n private:\r\n  using value_type =\r\n#ifdef __cpp_lib_ranges\r\n      std::iter_value_t<It>;\r\n#else\r\n      typename std::iterator_traits<It>::value_type;\r\n#endif\r\n  using context = buffer_context<Char>;\r\n  using mapper = detail::arg_mapper<context>;\r\n\r\n  template <typename T, FMT_ENABLE_IF(has_formatter<T, context>::value)>\r\n  static auto map(const T& value) -> const T& {\r\n    return value;\r\n  }\r\n  template <typename T, FMT_ENABLE_IF(!has_formatter<T, context>::value)>\r\n  static auto map(const T& value) -> decltype(mapper().map(value)) {\r\n    return mapper().map(value);\r\n  }\r\n\r\n  using formatter_type =\r\n      conditional_t<is_formattable<value_type, Char>::value,\r\n                    formatter<remove_cvref_t<decltype(map(\r\n                                  std::declval<const value_type&>()))>,\r\n                              Char>,\r\n                    detail::fallback_formatter<value_type, Char>>;\r\n\r\n  formatter_type value_formatter_;\r\n\r\n public:\r\n  template <typename ParseContext>\r\n  FMT_CONSTEXPR auto parse(ParseContext& ctx) -> decltype(ctx.begin()) {\r\n    return value_formatter_.parse(ctx);\r\n  }\r\n\r\n  template <typename FormatContext>\r\n  auto format(const join_view<It, Sentinel, Char>& value, FormatContext& ctx)\r\n      -> decltype(ctx.out()) {\r\n    auto it = value.begin;\r\n    auto out = ctx.out();\r\n    if (it != value.end) {\r\n      out = value_formatter_.format(map(*it), ctx);\r\n      ++it;\r\n      while (it != value.end) {\r\n        out = detail::copy_str<Char>(value.sep.begin(), value.sep.end(), out);\r\n        ctx.advance_to(out);\r\n        out = value_formatter_.format(map(*it), ctx);\r\n        ++it;\r\n      }\r\n    }\r\n    return out;\r\n  }\r\n};\r\n\r\n/**\r\n  Returns a view that formats the iterator range `[begin, end)` with elements\r\n  separated by `sep`.\r\n */\r\ntemplate <typename It, typename Sentinel>\r\nauto join(It begin, Sentinel end, string_view sep) -> join_view<It, Sentinel> {\r\n  return {begin, end, sep};\r\n}\r\n\r\n/**\r\n  \\rst\r\n  Returns a view that formats `range` with elements separated by `sep`.\r\n\r\n  **Example**::\r\n\r\n    std::vector<int> v = {1, 2, 3};\r\n    fmt::print(\"{}\", fmt::join(v, \", \"));\r\n    // Output: \"1, 2, 3\"\r\n\r\n  ``fmt::join`` applies passed format specifiers to the range elements::\r\n\r\n    fmt::print(\"{:02}\", fmt::join(v, \", \"));\r\n    // Output: \"01, 02, 03\"\r\n  \\endrst\r\n */\r\ntemplate <typename Range>\r\nauto join(Range&& range, string_view sep)\r\n    -> join_view<detail::iterator_t<Range>, detail::sentinel_t<Range>> {\r\n  return join(std::begin(range), std::end(range), sep);\r\n}\r\n\r\n/**\r\n  \\rst\r\n  Converts *value* to ``std::string`` using the default format for type *T*.\r\n\r\n  **Example**::\r\n\r\n    #include <fmt/format.h>\r\n\r\n    std::string answer = fmt::to_string(42);\r\n  \\endrst\r\n */\r\ntemplate <typename T, FMT_ENABLE_IF(!std::is_integral<T>::value)>\r\ninline auto to_string(const T& value) -> std::string {\r\n  auto result = std::string();\r\n  detail::write<char>(std::back_inserter(result), value);\r\n  return result;\r\n}\r\n\r\ntemplate <typename T, FMT_ENABLE_IF(std::is_integral<T>::value)>\r\nFMT_NODISCARD inline auto to_string(T value) -> std::string {\r\n  // The buffer should be large enough to store the number including the sign\r\n  // or \"false\" for bool.\r\n  constexpr int max_size = detail::digits10<T>() + 2;\r\n  char buffer[max_size > 5 ? static_cast<unsigned>(max_size) : 5];\r\n  char* begin = buffer;\r\n  return std::string(begin, detail::write<char>(begin, value));\r\n}\r\n\r\ntemplate <typename Char, size_t SIZE>\r\nFMT_NODISCARD auto to_string(const basic_memory_buffer<Char, SIZE>& buf)\r\n    -> std::basic_string<Char> {\r\n  auto size = buf.size();\r\n  detail::assume(size < std::basic_string<Char>().max_size());\r\n  return std::basic_string<Char>(buf.data(), size);\r\n}\r\n\r\nFMT_BEGIN_DETAIL_NAMESPACE\r\n\r\ntemplate <typename Char>\r\nvoid vformat_to(\r\n    buffer<Char>& buf, basic_string_view<Char> fmt,\r\n    basic_format_args<FMT_BUFFER_CONTEXT(type_identity_t<Char>)> args,\r\n    locale_ref loc) {\r\n  // workaround for msvc bug regarding name-lookup in module\r\n  // link names into function scope\r\n  using detail::arg_formatter;\r\n  using detail::buffer_appender;\r\n  using detail::custom_formatter;\r\n  using detail::default_arg_formatter;\r\n  using detail::get_arg;\r\n  using detail::locale_ref;\r\n  using detail::parse_format_specs;\r\n  using detail::specs_checker;\r\n  using detail::specs_handler;\r\n  using detail::to_unsigned;\r\n  using detail::type;\r\n  using detail::write;\r\n  auto out = buffer_appender<Char>(buf);\r\n  if (fmt.size() == 2 && equal2(fmt.data(), \"{}\")) {\r\n    auto arg = args.get(0);\r\n    if (!arg) error_handler().on_error(\"argument not found\");\r\n    visit_format_arg(default_arg_formatter<Char>{out, args, loc}, arg);\r\n    return;\r\n  }\r\n\r\n  struct format_handler : error_handler {\r\n    basic_format_parse_context<Char> parse_context;\r\n    buffer_context<Char> context;\r\n\r\n    format_handler(buffer_appender<Char> out, basic_string_view<Char> str,\r\n                   basic_format_args<buffer_context<Char>> args, locale_ref loc)\r\n        : parse_context(str), context(out, args, loc) {}\r\n\r\n    void on_text(const Char* begin, const Char* end) {\r\n      auto text = basic_string_view<Char>(begin, to_unsigned(end - begin));\r\n      context.advance_to(write<Char>(context.out(), text));\r\n    }\r\n\r\n    FMT_CONSTEXPR auto on_arg_id() -> int {\r\n      return parse_context.next_arg_id();\r\n    }\r\n    FMT_CONSTEXPR auto on_arg_id(int id) -> int {\r\n      return parse_context.check_arg_id(id), id;\r\n    }\r\n    FMT_CONSTEXPR auto on_arg_id(basic_string_view<Char> id) -> int {\r\n      int arg_id = context.arg_id(id);\r\n      if (arg_id < 0) on_error(\"argument not found\");\r\n      return arg_id;\r\n    }\r\n\r\n    FMT_INLINE void on_replacement_field(int id, const Char*) {\r\n      auto arg = get_arg(context, id);\r\n      context.advance_to(visit_format_arg(\r\n          default_arg_formatter<Char>{context.out(), context.args(),\r\n                                      context.locale()},\r\n          arg));\r\n    }\r\n\r\n    auto on_format_specs(int id, const Char* begin, const Char* end)\r\n        -> const Char* {\r\n      auto arg = get_arg(context, id);\r\n      if (arg.type() == type::custom_type) {\r\n        parse_context.advance_to(parse_context.begin() +\r\n                                 (begin - &*parse_context.begin()));\r\n        visit_format_arg(custom_formatter<Char>{parse_context, context}, arg);\r\n        return parse_context.begin();\r\n      }\r\n      auto specs = basic_format_specs<Char>();\r\n      specs_checker<specs_handler<Char>> handler(\r\n          specs_handler<Char>(specs, parse_context, context), arg.type());\r\n      begin = parse_format_specs(begin, end, handler);\r\n      if (begin == end || *begin != '}')\r\n        on_error(\"missing '}' in format string\");\r\n      auto f = arg_formatter<Char>{context.out(), specs, context.locale()};\r\n      context.advance_to(visit_format_arg(f, arg));\r\n      return begin;\r\n    }\r\n  };\r\n  detail::parse_format_string<false>(fmt, format_handler(out, fmt, args, loc));\r\n}\r\n\r\n#ifndef FMT_HEADER_ONLY\r\nextern template FMT_API auto thousands_sep_impl<char>(locale_ref)\r\n    -> thousands_sep_result<char>;\r\nextern template FMT_API auto thousands_sep_impl<wchar_t>(locale_ref)\r\n    -> thousands_sep_result<wchar_t>;\r\nextern template FMT_API auto decimal_point_impl(locale_ref) -> char;\r\nextern template FMT_API auto decimal_point_impl(locale_ref) -> wchar_t;\r\nextern template auto format_float<double>(double value, int precision,\r\n                                          float_specs specs, buffer<char>& buf)\r\n    -> int;\r\nextern template auto format_float<long double>(long double value, int precision,\r\n                                               float_specs specs,\r\n                                               buffer<char>& buf) -> int;\r\nvoid snprintf_float(float, int, float_specs, buffer<char>&) = delete;\r\nextern template auto snprintf_float<double>(double value, int precision,\r\n                                            float_specs specs,\r\n                                            buffer<char>& buf) -> int;\r\nextern template auto snprintf_float<long double>(long double value,\r\n                                                 int precision,\r\n                                                 float_specs specs,\r\n                                                 buffer<char>& buf) -> int;\r\n#endif  // FMT_HEADER_ONLY\r\n\r\nFMT_END_DETAIL_NAMESPACE\r\n\r\n#if FMT_USE_USER_DEFINED_LITERALS\r\ninline namespace literals {\r\n/**\r\n  \\rst\r\n  User-defined literal equivalent of :func:`fmt::arg`.\r\n\r\n  **Example**::\r\n\r\n    using namespace fmt::literals;\r\n    fmt::print(\"Elapsed time: {s:.2f} seconds\", \"s\"_a=1.23);\r\n  \\endrst\r\n */\r\n#  if FMT_USE_NONTYPE_TEMPLATE_PARAMETERS\r\ntemplate <detail_exported::fixed_string Str>\r\nconstexpr auto operator\"\"_a()\r\n    -> detail::udl_arg<remove_cvref_t<decltype(Str.data[0])>,\r\n                       sizeof(Str.data) / sizeof(decltype(Str.data[0])), Str> {\r\n  return {};\r\n}\r\n#  else\r\nconstexpr auto operator\"\" _a(const char* s, size_t) -> detail::udl_arg<char> {\r\n  return {s};\r\n}\r\n#  endif\r\n\r\n// DEPRECATED!\r\n// User-defined literal equivalent of fmt::format.\r\nFMT_DEPRECATED constexpr auto operator\"\" _format(const char* s, size_t n)\r\n    -> detail::udl_formatter<char> {\r\n  return {{s, n}};\r\n}\r\n}  // namespace literals\r\n#endif  // FMT_USE_USER_DEFINED_LITERALS\r\n\r\ntemplate <typename Locale, FMT_ENABLE_IF(detail::is_locale<Locale>::value)>\r\ninline auto vformat(const Locale& loc, string_view fmt, format_args args)\r\n    -> std::string {\r\n  return detail::vformat(loc, fmt, args);\r\n}\r\n\r\ntemplate <typename Locale, typename... T,\r\n          FMT_ENABLE_IF(detail::is_locale<Locale>::value)>\r\ninline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)\r\n    -> std::string {\r\n  return vformat(loc, string_view(fmt), fmt::make_format_args(args...));\r\n}\r\n\r\ntemplate <typename... T, size_t SIZE, typename Allocator>\r\nFMT_DEPRECATED auto format_to(basic_memory_buffer<char, SIZE, Allocator>& buf,\r\n                              format_string<T...> fmt, T&&... args)\r\n    -> appender {\r\n  detail::vformat_to(buf, string_view(fmt), fmt::make_format_args(args...));\r\n  return appender(buf);\r\n}\r\n\r\ntemplate <typename OutputIt, typename Locale,\r\n          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&\r\n                            detail::is_locale<Locale>::value)>\r\nauto vformat_to(OutputIt out, const Locale& loc, string_view fmt,\r\n                format_args args) -> OutputIt {\r\n  using detail::get_buffer;\r\n  auto&& buf = get_buffer<char>(out);\r\n  detail::vformat_to(buf, fmt, args, detail::locale_ref(loc));\r\n  return detail::get_iterator(buf);\r\n}\r\n\r\ntemplate <typename OutputIt, typename Locale, typename... T,\r\n          FMT_ENABLE_IF(detail::is_output_iterator<OutputIt, char>::value&&\r\n                            detail::is_locale<Locale>::value)>\r\nFMT_INLINE auto format_to(OutputIt out, const Locale& loc,\r\n                          format_string<T...> fmt, T&&... args) -> OutputIt {\r\n  return vformat_to(out, loc, fmt, fmt::make_format_args(args...));\r\n}\r\n\r\nFMT_MODULE_EXPORT_END\r\nFMT_END_NAMESPACE\r\n\r\n#ifdef FMT_DEPRECATED_INCLUDE_XCHAR\r\n#  include \"xchar.h\"\r\n#endif\r\n\r\n#ifdef FMT_HEADER_ONLY\r\n#  define FMT_FUNC inline\r\n#  include \"format-inl.h\"\r\n#else\r\n#  define FMT_FUNC\r\n#endif\r\n\r\n#endif  // FMT_FORMAT_H_\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format.h b/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format.h
--- a/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format.h	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format.h	(date 1720344409043)
@@ -1206,7 +1206,7 @@
   using carrier_uint = uint32_t;
   static const int significand_bits = 23;
   static const int exponent_bits = 8;
-  static const int min_exponent = -126;
+  static const int min_EXPonent = -126;
   static const int max_exponent = 127;
   static const int exponent_bias = -127;
   static const int decimal_digits = 9;
@@ -1232,7 +1232,7 @@
   using carrier_uint = uint64_t;
   static const int significand_bits = 52;
   static const int exponent_bits = 11;
-  static const int min_exponent = -1022;
+  static const int min_EXPonent = -1022;
   static const int max_exponent = 1023;
   static const int exponent_bias = -1023;
   static const int decimal_digits = 17;
Index: Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/RiderBlueprint.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"RiderBlueprint.hpp\"\r\n\r\n#include \"BlueprintProvider.hpp\"\r\n#include \"IRiderLink.hpp\"\r\n#include \"Model/RdEditorProtocol/RdEditorModel/RdEditorModel.Pregenerated.h\"\r\n\r\n\r\n#include \"Engine/Blueprint.h\"\r\n#include \"Framework/Docking/TabManager.h\"\r\n#include \"HAL/PlatformProcess.h\"\r\n#include \"MessageEndpoint.h\"\r\n#include \"MessageEndpointBuilder.h\"\r\n#include \"Modules/ModuleManager.h\"\r\n#include \"Runtime/Launch/Resources/Version.h\"\r\n\r\n#if ENGINE_MAJOR_VERSION < 5\r\n#include \"AssetRegistryModule.h\"\r\n#else\r\n#include \"AssetRegistry/AssetRegistryModule.h\"\r\n#endif\r\n\r\n#define LOCTEXT_NAMESPACE \"RiderBlueprint\"\r\n\r\nDEFINE_LOG_CATEGORY(FLogRiderBlueprintModule);\r\n\r\nIMPLEMENT_MODULE(FRiderBlueprintModule, RiderBlueprint);\r\n\r\nstatic void AllowSetForeGroundForEditor(JetBrains::EditorPlugin::RdEditorModel const & unrealToBackendModel) {\r\n    static const int32 CurrentProcessId = FPlatformProcess::GetCurrentProcessId();\r\n    try {\r\n        const rd::WiredRdTask<bool> Task = unrealToBackendModel.get_allowSetForegroundWindow().sync(CurrentProcessId);\r\n        if (Task.is_faulted()) {\r\n            UE_LOG(FLogRiderBlueprintModule, Error, TEXT(\"AllowSetForeGroundForEditor failed: %hs \"), rd::to_string(Task.value_or_throw()).c_str());\r\n        }\r\n        else if (Task.is_succeeded()) {\r\n            if (!(Task.value_or_throw().unwrap())) {\r\n                UE_LOG(FLogRiderBlueprintModule, Error, TEXT(\"AllowSetForeGroundForEditor failed: %hs \"), rd::to_string(Task.value_or_throw()).c_str());\r\n            }\r\n        }\r\n    }\r\n    catch (std::exception const &e) {\r\n        UE_LOG(FLogRiderBlueprintModule, Error, TEXT(\"AllowSetForeGroundForEditor failed: %hs \"), rd::to_string(e).c_str());\r\n    }\r\n}\r\n\r\nvoid FRiderBlueprintModule::StartupModule()\r\n{\r\n    UE_LOG(FLogRiderBlueprintModule, Verbose, TEXT(\"STARTUP START\"));\r\n    IRiderLinkModule& RiderLinkModule = IRiderLinkModule::Get();\r\n    ModuleLifetimeDef = RiderLinkModule.CreateNestedLifetimeDefinition();\r\n\r\n    const FAssetRegistryModule* AssetRegistryModule = &FModuleManager::LoadModuleChecked<FAssetRegistryModule>\r\n        (AssetRegistryConstants::ModuleName);\r\n\r\n    MessageEndpoint = FMessageEndpoint::Builder(FName(\"FAssetEditorManager\")).Build();\r\n\r\n    AssetRegistryModule->Get().OnAssetAdded().AddLambda([](const FAssetData& AssetData) {\r\n        // TO-DO: Fix loading uasset's on 4.23-\r\n        // BluePrintProvider::AddAsset(AssetData);\r\n    });\r\n\r\n    RiderLinkModule.ViewModel(ModuleLifetimeDef.lifetime, [this] (rd::Lifetime ModelLifetime, JetBrains::EditorPlugin::RdEditorModel const& UnrealToBackendModel)\r\n    {\r\n        UnrealToBackendModel.get_openBlueprint().advise(\r\n            ModelLifetime,\r\n            [this, &UnrealToBackendModel](\r\n            JetBrains::EditorPlugin::BlueprintReference const& s)\r\n            {\r\n                try\r\n                {\r\n                    AllowSetForeGroundForEditor(UnrealToBackendModel);\r\n\r\n                    auto Window = FGlobalTabmanager::Get()->GetRootWindow();\r\n                    if (!Window.IsValid()) return;\r\n\r\n                    if (Window->IsWindowMinimized())\r\n                    {\r\n                        Window->Restore();\r\n                    }\r\n                    else\r\n                    {\r\n                        Window->HACK_ForceToFront();\r\n                    }\r\n                    BluePrintProvider::OpenBlueprint(s, MessageEndpoint);\r\n                }\r\n                catch (std::exception const& e)\r\n                {\r\n                    std::cerr << rd::to_string(e);\r\n                }\r\n            }\r\n        );\r\n\r\n        UnrealToBackendModel.get_isBlueprintPathName().set([](FString const& pathName) -> bool\r\n        {\r\n            return BluePrintProvider::IsBlueprint(pathName);\r\n        });\r\n    });\r\n    UE_LOG(FLogRiderBlueprintModule, Verbose, TEXT(\"STARTUP FINISH\"));\r\n}\r\n\r\nvoid FRiderBlueprintModule::ShutdownModule()\r\n{\r\n    UE_LOG(FLogRiderBlueprintModule, Verbose, TEXT(\"SHUTDOWN START\"));\r\n    ModuleLifetimeDef.terminate();\r\n    UE_LOG(FLogRiderBlueprintModule, Verbose, TEXT(\"SHUTDOWN FINISH\"));\r\n}\r\n\r\n#undef LOCTEXT_NAMESPACE
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/RiderBlueprint.cpp b/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/RiderBlueprint.cpp
--- a/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/RiderBlueprint.cpp	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/RiderBlueprint.cpp	(date 1720720014563)
@@ -52,7 +52,7 @@
     const FAssetRegistryModule* AssetRegistryModule = &FModuleManager::LoadModuleChecked<FAssetRegistryModule>
         (AssetRegistryConstants::ModuleName);
 
-    MessageEndpoint = FMessageEndpoint::Builder(FName("FAssetEditorManager")).Build();
+    MessageEndpoint = FMessageEndpoint::Builder(FName("FAssetEditorn_BASIC_MPger")).Build();
 
     AssetRegistryModule->Get().OnAssetAdded().AddLambda([](const FAssetData& AssetData) {
         // TO-DO: Fix loading uasset's on 4.23-
Index: Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format-inl.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Formatting library for C++ - implementation\r\n//\r\n// Copyright (c) 2012 - 2016, Victor Zverovich\r\n// All rights reserved.\r\n//\r\n// For the license information refer to format.h.\r\n\r\n#ifndef FMT_FORMAT_INL_H_\r\n#define FMT_FORMAT_INL_H_\r\n\r\n#include <algorithm>\r\n#include <cctype>\r\n#include <cerrno>  // errno\r\n#include <climits>\r\n#include <cmath>\r\n#include <cstdarg>\r\n#include <cstring>  // std::memmove\r\n#include <cwchar>\r\n#include <exception>\r\n\r\n#ifndef FMT_STATIC_THOUSANDS_SEPARATOR\r\n#  include <locale>\r\n#endif\r\n\r\n#ifdef _WIN32\r\n#  include <io.h>  // _isatty\r\n#endif\r\n\r\n#include \"format.h\"\r\n\r\nFMT_BEGIN_NAMESPACE\r\nnamespace detail {\r\n\r\nFMT_FUNC void assert_fail(const char* file, int line, const char* message) {\r\n  // Use unchecked std::fprintf to avoid triggering another assertion when\r\n  // writing to stderr fails\r\n  std::fprintf(stderr, \"%s:%d: assertion failed: %s\", file, line, message);\r\n  // Chosen instead of std::abort to satisfy Clang in CUDA mode during device\r\n  // code pass.\r\n  std::terminate();\r\n}\r\n\r\nFMT_FUNC void throw_format_error(const char* message) {\r\n  FMT_THROW(format_error(message));\r\n}\r\n\r\n#ifndef _MSC_VER\r\n#  define FMT_SNPRINTF snprintf\r\n#else  // _MSC_VER\r\ninline int fmt_snprintf(char* buffer, size_t size, const char* format, ...) {\r\n  va_list args;\r\n  va_start(args, format);\r\n  int result = vsnprintf_s(buffer, size, _TRUNCATE, format, args);\r\n  va_end(args);\r\n  return result;\r\n}\r\n#  define FMT_SNPRINTF fmt_snprintf\r\n#endif  // _MSC_VER\r\n\r\nFMT_FUNC void format_error_code(detail::buffer<char>& out, int error_code,\r\n                                string_view message) FMT_NOEXCEPT {\r\n  // Report error code making sure that the output fits into\r\n  // inline_buffer_size to avoid dynamic memory allocation and potential\r\n  // bad_alloc.\r\n  out.try_resize(0);\r\n  static const char SEP[] = \": \";\r\n  static const char ERROR_STR[] = \"error \";\r\n  // Subtract 2 to account for terminating null characters in SEP and ERROR_STR.\r\n  size_t error_code_size = sizeof(SEP) + sizeof(ERROR_STR) - 2;\r\n  auto abs_value = static_cast<uint32_or_64_or_128_t<int>>(error_code);\r\n  if (detail::is_negative(error_code)) {\r\n    abs_value = 0 - abs_value;\r\n    ++error_code_size;\r\n  }\r\n  error_code_size += detail::to_unsigned(detail::count_digits(abs_value));\r\n  auto it = buffer_appender<char>(out);\r\n  if (message.size() <= inline_buffer_size - error_code_size)\r\n    format_to(it, FMT_STRING(\"{}{}\"), message, SEP);\r\n  format_to(it, FMT_STRING(\"{}{}\"), ERROR_STR, error_code);\r\n  FMT_ASSERT(out.size() <= inline_buffer_size, \"\");\r\n}\r\n\r\nFMT_FUNC void report_error(format_func func, int error_code,\r\n                           const char* message) FMT_NOEXCEPT {\r\n  memory_buffer full_message;\r\n  func(full_message, error_code, message);\r\n  // Don't use fwrite_fully because the latter may throw.\r\n  if (std::fwrite(full_message.data(), full_message.size(), 1, stderr) > 0)\r\n    std::fputc('\\n', stderr);\r\n}\r\n\r\n// A wrapper around fwrite that throws on error.\r\ninline void fwrite_fully(const void* ptr, size_t size, size_t count,\r\n                         FILE* stream) {\r\n  size_t written = std::fwrite(ptr, size, count, stream);\r\n  if (written < count) FMT_THROW(system_error(errno, \"cannot write to file\"));\r\n}\r\n\r\n#ifndef FMT_STATIC_THOUSANDS_SEPARATOR\r\ntemplate <typename Locale>\r\nlocale_ref::locale_ref(const Locale& loc) : locale_(&loc) {\r\n  static_assert(std::is_same<Locale, std::locale>::value, \"\");\r\n}\r\n\r\ntemplate <typename Locale> Locale locale_ref::get() const {\r\n  static_assert(std::is_same<Locale, std::locale>::value, \"\");\r\n  return locale_ ? *static_cast<const std::locale*>(locale_) : std::locale();\r\n}\r\n\r\ntemplate <typename Char>\r\nFMT_FUNC auto thousands_sep_impl(locale_ref loc) -> thousands_sep_result<Char> {\r\n  auto& facet = std::use_facet<std::numpunct<Char>>(loc.get<std::locale>());\r\n  auto grouping = facet.grouping();\r\n  auto thousands_sep = grouping.empty() ? Char() : facet.thousands_sep();\r\n  return {std::move(grouping), thousands_sep};\r\n}\r\ntemplate <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref loc) {\r\n  return std::use_facet<std::numpunct<Char>>(loc.get<std::locale>())\r\n      .decimal_point();\r\n}\r\n#else\r\ntemplate <typename Char>\r\nFMT_FUNC auto thousands_sep_impl(locale_ref) -> thousands_sep_result<Char> {\r\n  return {\"\\03\", FMT_STATIC_THOUSANDS_SEPARATOR};\r\n}\r\ntemplate <typename Char> FMT_FUNC Char decimal_point_impl(locale_ref) {\r\n  return '.';\r\n}\r\n#endif\r\n}  // namespace detail\r\n\r\n#if !FMT_MSC_VER\r\nFMT_API FMT_FUNC format_error::~format_error() FMT_NOEXCEPT = default;\r\n#endif\r\n\r\nFMT_FUNC std::system_error vsystem_error(int error_code, string_view format_str,\r\n                                         format_args args) {\r\n  auto ec = std::error_code(error_code, std::generic_category());\r\n  return std::system_error(ec, vformat(format_str, args));\r\n}\r\n\r\nnamespace detail {\r\n\r\ntemplate <> FMT_FUNC int count_digits<4>(detail::fallback_uintptr n) {\r\n  // fallback_uintptr is always stored in little endian.\r\n  int i = static_cast<int>(sizeof(void*)) - 1;\r\n  while (i > 0 && n.value[i] == 0) --i;\r\n  auto char_digits = std::numeric_limits<unsigned char>::digits / 4;\r\n  return i >= 0 ? i * char_digits + count_digits<4, unsigned>(n.value[i]) : 1;\r\n}\r\n\r\n// log10(2) = 0x0.4d104d427de7fbcc...\r\nstatic constexpr uint64_t log10_2_significand = 0x4d104d427de7fbcc;\r\n\r\ntemplate <typename T = void> struct basic_impl_data {\r\n  // Normalized 64-bit significands of pow(10, k), for k = -348, -340, ..., 340.\r\n  // These are generated by support/compute-powers.py.\r\n  static constexpr uint64_t pow10_significands[87] = {\r\n      0xfa8fd5a0081c0288, 0xbaaee17fa23ebf76, 0x8b16fb203055ac76,\r\n      0xcf42894a5dce35ea, 0x9a6bb0aa55653b2d, 0xe61acf033d1a45df,\r\n      0xab70fe17c79ac6ca, 0xff77b1fcbebcdc4f, 0xbe5691ef416bd60c,\r\n      0x8dd01fad907ffc3c, 0xd3515c2831559a83, 0x9d71ac8fada6c9b5,\r\n      0xea9c227723ee8bcb, 0xaecc49914078536d, 0x823c12795db6ce57,\r\n      0xc21094364dfb5637, 0x9096ea6f3848984f, 0xd77485cb25823ac7,\r\n      0xa086cfcd97bf97f4, 0xef340a98172aace5, 0xb23867fb2a35b28e,\r\n      0x84c8d4dfd2c63f3b, 0xc5dd44271ad3cdba, 0x936b9fcebb25c996,\r\n      0xdbac6c247d62a584, 0xa3ab66580d5fdaf6, 0xf3e2f893dec3f126,\r\n      0xb5b5ada8aaff80b8, 0x87625f056c7c4a8b, 0xc9bcff6034c13053,\r\n      0x964e858c91ba2655, 0xdff9772470297ebd, 0xa6dfbd9fb8e5b88f,\r\n      0xf8a95fcf88747d94, 0xb94470938fa89bcf, 0x8a08f0f8bf0f156b,\r\n      0xcdb02555653131b6, 0x993fe2c6d07b7fac, 0xe45c10c42a2b3b06,\r\n      0xaa242499697392d3, 0xfd87b5f28300ca0e, 0xbce5086492111aeb,\r\n      0x8cbccc096f5088cc, 0xd1b71758e219652c, 0x9c40000000000000,\r\n      0xe8d4a51000000000, 0xad78ebc5ac620000, 0x813f3978f8940984,\r\n      0xc097ce7bc90715b3, 0x8f7e32ce7bea5c70, 0xd5d238a4abe98068,\r\n      0x9f4f2726179a2245, 0xed63a231d4c4fb27, 0xb0de65388cc8ada8,\r\n      0x83c7088e1aab65db, 0xc45d1df942711d9a, 0x924d692ca61be758,\r\n      0xda01ee641a708dea, 0xa26da3999aef774a, 0xf209787bb47d6b85,\r\n      0xb454e4a179dd1877, 0x865b86925b9bc5c2, 0xc83553c5c8965d3d,\r\n      0x952ab45cfa97a0b3, 0xde469fbd99a05fe3, 0xa59bc234db398c25,\r\n      0xf6c69a72a3989f5c, 0xb7dcbf5354e9bece, 0x88fcf317f22241e2,\r\n      0xcc20ce9bd35c78a5, 0x98165af37b2153df, 0xe2a0b5dc971f303a,\r\n      0xa8d9d1535ce3b396, 0xfb9b7cd9a4a7443c, 0xbb764c4ca7a44410,\r\n      0x8bab8eefb6409c1a, 0xd01fef10a657842c, 0x9b10a4e5e9913129,\r\n      0xe7109bfba19c0c9d, 0xac2820d9623bf429, 0x80444b5e7aa7cf85,\r\n      0xbf21e44003acdd2d, 0x8e679c2f5e44ff8f, 0xd433179d9c8cb841,\r\n      0x9e19db92b4e31ba9, 0xeb96bf6ebadf77d9, 0xaf87023b9bf0ee6b,\r\n  };\r\n\r\n#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409\r\n#  pragma GCC diagnostic push\r\n#  pragma GCC diagnostic ignored \"-Wnarrowing\"\r\n#endif\r\n  // Binary exponents of pow(10, k), for k = -348, -340, ..., 340, corresponding\r\n  // to significands above.\r\n  static constexpr int16_t pow10_exponents[87] = {\r\n      -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007, -980, -954,\r\n      -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,  -688, -661,\r\n      -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,  -422,  -396, -369,\r\n      -343,  -316,  -289,  -263,  -236,  -210,  -183,  -157,  -130,  -103, -77,\r\n      -50,   -24,   3,     30,    56,    83,    109,   136,   162,   189,  216,\r\n      242,   269,   295,   322,   348,   375,   402,   428,   455,   481,  508,\r\n      534,   561,   588,   614,   641,   667,   694,   720,   747,   774,  800,\r\n      827,   853,   880,   907,   933,   960,   986,   1013,  1039,  1066};\r\n#if FMT_GCC_VERSION && FMT_GCC_VERSION < 409\r\n#  pragma GCC diagnostic pop\r\n#endif\r\n\r\n  static constexpr uint64_t power_of_10_64[20] = {\r\n      1, FMT_POWERS_OF_10(1ULL), FMT_POWERS_OF_10(1000000000ULL),\r\n      10000000000000000000ULL};\r\n};\r\n\r\n// This is a struct rather than an alias to avoid shadowing warnings in gcc.\r\nstruct impl_data : basic_impl_data<> {};\r\n\r\n#if __cplusplus < 201703L\r\ntemplate <typename T>\r\nconstexpr uint64_t basic_impl_data<T>::pow10_significands[];\r\ntemplate <typename T> constexpr int16_t basic_impl_data<T>::pow10_exponents[];\r\ntemplate <typename T> constexpr uint64_t basic_impl_data<T>::power_of_10_64[];\r\n#endif\r\n\r\ntemplate <typename T> struct bits {\r\n  static FMT_CONSTEXPR_DECL const int value =\r\n      static_cast<int>(sizeof(T) * std::numeric_limits<unsigned char>::digits);\r\n};\r\n\r\n// Returns the number of significand bits in Float excluding the implicit bit.\r\ntemplate <typename Float> constexpr int num_significand_bits() {\r\n  // Subtract 1 to account for an implicit most significant bit in the\r\n  // normalized form.\r\n  return std::numeric_limits<Float>::digits - 1;\r\n}\r\n\r\n// A floating-point number f * pow(2, e).\r\nstruct fp {\r\n  uint64_t f;\r\n  int e;\r\n\r\n  static constexpr const int num_significand_bits = bits<decltype(f)>::value;\r\n\r\n  constexpr fp() : f(0), e(0) {}\r\n  constexpr fp(uint64_t f_val, int e_val) : f(f_val), e(e_val) {}\r\n\r\n  // Constructs fp from an IEEE754 floating-point number. It is a template to\r\n  // prevent compile errors on systems where n is not IEEE754.\r\n  template <typename Float> explicit FMT_CONSTEXPR fp(Float n) { assign(n); }\r\n\r\n  template <typename Float>\r\n  using is_supported = bool_constant<sizeof(Float) == sizeof(uint64_t) ||\r\n                                     sizeof(Float) == sizeof(uint32_t)>;\r\n\r\n  // Assigns d to this and return true iff predecessor is closer than successor.\r\n  template <typename Float, FMT_ENABLE_IF(is_supported<Float>::value)>\r\n  FMT_CONSTEXPR bool assign(Float n) {\r\n    // Assume float is in the format [sign][exponent][significand].\r\n    const int num_float_significand_bits =\r\n        detail::num_significand_bits<Float>();\r\n    const uint64_t implicit_bit = 1ULL << num_float_significand_bits;\r\n    const uint64_t significand_mask = implicit_bit - 1;\r\n    constexpr bool is_double = sizeof(Float) == sizeof(uint64_t);\r\n    auto u = bit_cast<conditional_t<is_double, uint64_t, uint32_t>>(n);\r\n    f = u & significand_mask;\r\n    const uint64_t exponent_mask = (~0ULL >> 1) & ~significand_mask;\r\n    int biased_e =\r\n        static_cast<int>((u & exponent_mask) >> num_float_significand_bits);\r\n    // The predecessor is closer if n is a normalized power of 2 (f == 0) other\r\n    // than the smallest normalized number (biased_e > 1).\r\n    bool is_predecessor_closer = f == 0 && biased_e > 1;\r\n    if (biased_e != 0)\r\n      f += implicit_bit;\r\n    else\r\n      biased_e = 1;  // Subnormals use biased exponent 1 (min exponent).\r\n    const int exponent_bias = std::numeric_limits<Float>::max_exponent - 1;\r\n    e = biased_e - exponent_bias - num_float_significand_bits;\r\n    return is_predecessor_closer;\r\n  }\r\n\r\n  template <typename Float, FMT_ENABLE_IF(!is_supported<Float>::value)>\r\n  bool assign(Float) {\r\n    FMT_ASSERT(false, \"\");\r\n    return false;\r\n  }\r\n};\r\n\r\n// Normalizes the value converted from double and multiplied by (1 << SHIFT).\r\ntemplate <int SHIFT = 0> FMT_CONSTEXPR fp normalize(fp value) {\r\n  // Handle subnormals.\r\n  const uint64_t implicit_bit = 1ULL << num_significand_bits<double>();\r\n  const auto shifted_implicit_bit = implicit_bit << SHIFT;\r\n  while ((value.f & shifted_implicit_bit) == 0) {\r\n    value.f <<= 1;\r\n    --value.e;\r\n  }\r\n  // Subtract 1 to account for hidden bit.\r\n  const auto offset =\r\n      fp::num_significand_bits - num_significand_bits<double>() - SHIFT - 1;\r\n  value.f <<= offset;\r\n  value.e -= offset;\r\n  return value;\r\n}\r\n\r\ninline bool operator==(fp x, fp y) { return x.f == y.f && x.e == y.e; }\r\n\r\n// Computes lhs * rhs / pow(2, 64) rounded to nearest with half-up tie breaking.\r\nFMT_CONSTEXPR inline uint64_t multiply(uint64_t lhs, uint64_t rhs) {\r\n#if FMT_USE_INT128\r\n  auto product = static_cast<__uint128_t>(lhs) * rhs;\r\n  auto f = static_cast<uint64_t>(product >> 64);\r\n  return (static_cast<uint64_t>(product) & (1ULL << 63)) != 0 ? f + 1 : f;\r\n#else\r\n  // Multiply 32-bit parts of significands.\r\n  uint64_t mask = (1ULL << 32) - 1;\r\n  uint64_t a = lhs >> 32, b = lhs & mask;\r\n  uint64_t c = rhs >> 32, d = rhs & mask;\r\n  uint64_t ac = a * c, bc = b * c, ad = a * d, bd = b * d;\r\n  // Compute mid 64-bit of result and round.\r\n  uint64_t mid = (bd >> 32) + (ad & mask) + (bc & mask) + (1U << 31);\r\n  return ac + (ad >> 32) + (bc >> 32) + (mid >> 32);\r\n#endif\r\n}\r\n\r\nFMT_CONSTEXPR inline fp operator*(fp x, fp y) {\r\n  return {multiply(x.f, y.f), x.e + y.e + 64};\r\n}\r\n\r\n// Returns a cached power of 10 `c_k = c_k.f * pow(2, c_k.e)` such that its\r\n// (binary) exponent satisfies `min_exponent <= c_k.e <= min_exponent + 28`.\r\nFMT_CONSTEXPR inline fp get_cached_power(int min_exponent,\r\n                                         int& pow10_exponent) {\r\n  const int shift = 32;\r\n  const auto significand = static_cast<int64_t>(log10_2_significand);\r\n  int index = static_cast<int>(\r\n      ((min_exponent + fp::num_significand_bits - 1) * (significand >> shift) +\r\n       ((int64_t(1) << shift) - 1))  // ceil\r\n      >> 32                          // arithmetic shift\r\n  );\r\n  // Decimal exponent of the first (smallest) cached power of 10.\r\n  const int first_dec_exp = -348;\r\n  // Difference between 2 consecutive decimal exponents in cached powers of 10.\r\n  const int dec_exp_step = 8;\r\n  index = (index - first_dec_exp - 1) / dec_exp_step + 1;\r\n  pow10_exponent = first_dec_exp + index * dec_exp_step;\r\n  return {impl_data::pow10_significands[index],\r\n          impl_data::pow10_exponents[index]};\r\n}\r\n\r\n// A simple accumulator to hold the sums of terms in bigint::square if uint128_t\r\n// is not available.\r\nstruct accumulator {\r\n  uint64_t lower;\r\n  uint64_t upper;\r\n\r\n  constexpr accumulator() : lower(0), upper(0) {}\r\n  constexpr explicit operator uint32_t() const {\r\n    return static_cast<uint32_t>(lower);\r\n  }\r\n\r\n  FMT_CONSTEXPR void operator+=(uint64_t n) {\r\n    lower += n;\r\n    if (lower < n) ++upper;\r\n  }\r\n  FMT_CONSTEXPR void operator>>=(int shift) {\r\n    FMT_ASSERT(shift == 32, \"\");\r\n    (void)shift;\r\n    lower = (upper << 32) | (lower >> 32);\r\n    upper >>= 32;\r\n  }\r\n};\r\n\r\nclass bigint {\r\n private:\r\n  // A bigint is stored as an array of bigits (big digits), with bigit at index\r\n  // 0 being the least significant one.\r\n  using bigit = uint32_t;\r\n  using double_bigit = uint64_t;\r\n  enum { bigits_capacity = 32 };\r\n  basic_memory_buffer<bigit, bigits_capacity> bigits_;\r\n  int exp_;\r\n\r\n  FMT_CONSTEXPR20 bigit operator[](int index) const {\r\n    return bigits_[to_unsigned(index)];\r\n  }\r\n  FMT_CONSTEXPR20 bigit& operator[](int index) {\r\n    return bigits_[to_unsigned(index)];\r\n  }\r\n\r\n  static FMT_CONSTEXPR_DECL const int bigit_bits = bits<bigit>::value;\r\n\r\n  friend struct formatter<bigint>;\r\n\r\n  FMT_CONSTEXPR20 void subtract_bigits(int index, bigit other, bigit& borrow) {\r\n    auto result = static_cast<double_bigit>((*this)[index]) - other - borrow;\r\n    (*this)[index] = static_cast<bigit>(result);\r\n    borrow = static_cast<bigit>(result >> (bigit_bits * 2 - 1));\r\n  }\r\n\r\n  FMT_CONSTEXPR20 void remove_leading_zeros() {\r\n    int num_bigits = static_cast<int>(bigits_.size()) - 1;\r\n    while (num_bigits > 0 && (*this)[num_bigits] == 0) --num_bigits;\r\n    bigits_.resize(to_unsigned(num_bigits + 1));\r\n  }\r\n\r\n  // Computes *this -= other assuming aligned bigints and *this >= other.\r\n  FMT_CONSTEXPR20 void subtract_aligned(const bigint& other) {\r\n    FMT_ASSERT(other.exp_ >= exp_, \"unaligned bigints\");\r\n    FMT_ASSERT(compare(*this, other) >= 0, \"\");\r\n    bigit borrow = 0;\r\n    int i = other.exp_ - exp_;\r\n    for (size_t j = 0, n = other.bigits_.size(); j != n; ++i, ++j)\r\n      subtract_bigits(i, other.bigits_[j], borrow);\r\n    while (borrow > 0) subtract_bigits(i, 0, borrow);\r\n    remove_leading_zeros();\r\n  }\r\n\r\n  FMT_CONSTEXPR20 void multiply(uint32_t value) {\r\n    const double_bigit wide_value = value;\r\n    bigit carry = 0;\r\n    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {\r\n      double_bigit result = bigits_[i] * wide_value + carry;\r\n      bigits_[i] = static_cast<bigit>(result);\r\n      carry = static_cast<bigit>(result >> bigit_bits);\r\n    }\r\n    if (carry != 0) bigits_.push_back(carry);\r\n  }\r\n\r\n  FMT_CONSTEXPR20 void multiply(uint64_t value) {\r\n    const bigit mask = ~bigit(0);\r\n    const double_bigit lower = value & mask;\r\n    const double_bigit upper = value >> bigit_bits;\r\n    double_bigit carry = 0;\r\n    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {\r\n      double_bigit result = bigits_[i] * lower + (carry & mask);\r\n      carry =\r\n          bigits_[i] * upper + (result >> bigit_bits) + (carry >> bigit_bits);\r\n      bigits_[i] = static_cast<bigit>(result);\r\n    }\r\n    while (carry != 0) {\r\n      bigits_.push_back(carry & mask);\r\n      carry >>= bigit_bits;\r\n    }\r\n  }\r\n\r\n public:\r\n  FMT_CONSTEXPR20 bigint() : exp_(0) {}\r\n  explicit bigint(uint64_t n) { assign(n); }\r\n  FMT_CONSTEXPR20 ~bigint() {\r\n    FMT_ASSERT(bigits_.capacity() <= bigits_capacity, \"\");\r\n  }\r\n\r\n  bigint(const bigint&) = delete;\r\n  void operator=(const bigint&) = delete;\r\n\r\n  FMT_CONSTEXPR20 void assign(const bigint& other) {\r\n    auto size = other.bigits_.size();\r\n    bigits_.resize(size);\r\n    auto data = other.bigits_.data();\r\n    std::copy(data, data + size, make_checked(bigits_.data(), size));\r\n    exp_ = other.exp_;\r\n  }\r\n\r\n  FMT_CONSTEXPR20 void assign(uint64_t n) {\r\n    size_t num_bigits = 0;\r\n    do {\r\n      bigits_[num_bigits++] = n & ~bigit(0);\r\n      n >>= bigit_bits;\r\n    } while (n != 0);\r\n    bigits_.resize(num_bigits);\r\n    exp_ = 0;\r\n  }\r\n\r\n  FMT_CONSTEXPR20 int num_bigits() const {\r\n    return static_cast<int>(bigits_.size()) + exp_;\r\n  }\r\n\r\n  FMT_NOINLINE FMT_CONSTEXPR20 bigint& operator<<=(int shift) {\r\n    FMT_ASSERT(shift >= 0, \"\");\r\n    exp_ += shift / bigit_bits;\r\n    shift %= bigit_bits;\r\n    if (shift == 0) return *this;\r\n    bigit carry = 0;\r\n    for (size_t i = 0, n = bigits_.size(); i < n; ++i) {\r\n      bigit c = bigits_[i] >> (bigit_bits - shift);\r\n      bigits_[i] = (bigits_[i] << shift) + carry;\r\n      carry = c;\r\n    }\r\n    if (carry != 0) bigits_.push_back(carry);\r\n    return *this;\r\n  }\r\n\r\n  template <typename Int> FMT_CONSTEXPR20 bigint& operator*=(Int value) {\r\n    FMT_ASSERT(value > 0, \"\");\r\n    multiply(uint32_or_64_or_128_t<Int>(value));\r\n    return *this;\r\n  }\r\n\r\n  friend FMT_CONSTEXPR20 int compare(const bigint& lhs, const bigint& rhs) {\r\n    int num_lhs_bigits = lhs.num_bigits(), num_rhs_bigits = rhs.num_bigits();\r\n    if (num_lhs_bigits != num_rhs_bigits)\r\n      return num_lhs_bigits > num_rhs_bigits ? 1 : -1;\r\n    int i = static_cast<int>(lhs.bigits_.size()) - 1;\r\n    int j = static_cast<int>(rhs.bigits_.size()) - 1;\r\n    int end = i - j;\r\n    if (end < 0) end = 0;\r\n    for (; i >= end; --i, --j) {\r\n      bigit lhs_bigit = lhs[i], rhs_bigit = rhs[j];\r\n      if (lhs_bigit != rhs_bigit) return lhs_bigit > rhs_bigit ? 1 : -1;\r\n    }\r\n    if (i != j) return i > j ? 1 : -1;\r\n    return 0;\r\n  }\r\n\r\n  // Returns compare(lhs1 + lhs2, rhs).\r\n  friend FMT_CONSTEXPR20 int add_compare(const bigint& lhs1, const bigint& lhs2,\r\n                                         const bigint& rhs) {\r\n    int max_lhs_bigits = (std::max)(lhs1.num_bigits(), lhs2.num_bigits());\r\n    int num_rhs_bigits = rhs.num_bigits();\r\n    if (max_lhs_bigits + 1 < num_rhs_bigits) return -1;\r\n    if (max_lhs_bigits > num_rhs_bigits) return 1;\r\n    auto get_bigit = [](const bigint& n, int i) -> bigit {\r\n      return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;\r\n    };\r\n    double_bigit borrow = 0;\r\n    int min_exp = (std::min)((std::min)(lhs1.exp_, lhs2.exp_), rhs.exp_);\r\n    for (int i = num_rhs_bigits - 1; i >= min_exp; --i) {\r\n      double_bigit sum =\r\n          static_cast<double_bigit>(get_bigit(lhs1, i)) + get_bigit(lhs2, i);\r\n      bigit rhs_bigit = get_bigit(rhs, i);\r\n      if (sum > rhs_bigit + borrow) return 1;\r\n      borrow = rhs_bigit + borrow - sum;\r\n      if (borrow > 1) return -1;\r\n      borrow <<= bigit_bits;\r\n    }\r\n    return borrow != 0 ? -1 : 0;\r\n  }\r\n\r\n  // Assigns pow(10, exp) to this bigint.\r\n  FMT_CONSTEXPR20 void assign_pow10(int exp) {\r\n    FMT_ASSERT(exp >= 0, \"\");\r\n    if (exp == 0) return assign(1);\r\n    // Find the top bit.\r\n    int bitmask = 1;\r\n    while (exp >= bitmask) bitmask <<= 1;\r\n    bitmask >>= 1;\r\n    // pow(10, exp) = pow(5, exp) * pow(2, exp). First compute pow(5, exp) by\r\n    // repeated squaring and multiplication.\r\n    assign(5);\r\n    bitmask >>= 1;\r\n    while (bitmask != 0) {\r\n      square();\r\n      if ((exp & bitmask) != 0) *this *= 5;\r\n      bitmask >>= 1;\r\n    }\r\n    *this <<= exp;  // Multiply by pow(2, exp) by shifting.\r\n  }\r\n\r\n  FMT_CONSTEXPR20 void square() {\r\n    int num_bigits = static_cast<int>(bigits_.size());\r\n    int num_result_bigits = 2 * num_bigits;\r\n    basic_memory_buffer<bigit, bigits_capacity> n(std::move(bigits_));\r\n    bigits_.resize(to_unsigned(num_result_bigits));\r\n    using accumulator_t = conditional_t<FMT_USE_INT128, uint128_t, accumulator>;\r\n    auto sum = accumulator_t();\r\n    for (int bigit_index = 0; bigit_index < num_bigits; ++bigit_index) {\r\n      // Compute bigit at position bigit_index of the result by adding\r\n      // cross-product terms n[i] * n[j] such that i + j == bigit_index.\r\n      for (int i = 0, j = bigit_index; j >= 0; ++i, --j) {\r\n        // Most terms are multiplied twice which can be optimized in the future.\r\n        sum += static_cast<double_bigit>(n[i]) * n[j];\r\n      }\r\n      (*this)[bigit_index] = static_cast<bigit>(sum);\r\n      sum >>= bits<bigit>::value;  // Compute the carry.\r\n    }\r\n    // Do the same for the top half.\r\n    for (int bigit_index = num_bigits; bigit_index < num_result_bigits;\r\n         ++bigit_index) {\r\n      for (int j = num_bigits - 1, i = bigit_index - j; i < num_bigits;)\r\n        sum += static_cast<double_bigit>(n[i++]) * n[j--];\r\n      (*this)[bigit_index] = static_cast<bigit>(sum);\r\n      sum >>= bits<bigit>::value;\r\n    }\r\n    remove_leading_zeros();\r\n    exp_ *= 2;\r\n  }\r\n\r\n  // If this bigint has a bigger exponent than other, adds trailing zero to make\r\n  // exponents equal. This simplifies some operations such as subtraction.\r\n  FMT_CONSTEXPR20 void align(const bigint& other) {\r\n    int exp_difference = exp_ - other.exp_;\r\n    if (exp_difference <= 0) return;\r\n    int num_bigits = static_cast<int>(bigits_.size());\r\n    bigits_.resize(to_unsigned(num_bigits + exp_difference));\r\n    for (int i = num_bigits - 1, j = i + exp_difference; i >= 0; --i, --j)\r\n      bigits_[j] = bigits_[i];\r\n    std::uninitialized_fill_n(bigits_.data(), exp_difference, 0);\r\n    exp_ -= exp_difference;\r\n  }\r\n\r\n  // Divides this bignum by divisor, assigning the remainder to this and\r\n  // returning the quotient.\r\n  FMT_CONSTEXPR20 int divmod_assign(const bigint& divisor) {\r\n    FMT_ASSERT(this != &divisor, \"\");\r\n    if (compare(*this, divisor) < 0) return 0;\r\n    FMT_ASSERT(divisor.bigits_[divisor.bigits_.size() - 1u] != 0, \"\");\r\n    align(divisor);\r\n    int quotient = 0;\r\n    do {\r\n      subtract_aligned(divisor);\r\n      ++quotient;\r\n    } while (compare(*this, divisor) >= 0);\r\n    return quotient;\r\n  }\r\n};\r\n\r\nenum class round_direction { unknown, up, down };\r\n\r\n// Given the divisor (normally a power of 10), the remainder = v % divisor for\r\n// some number v and the error, returns whether v should be rounded up, down, or\r\n// whether the rounding direction can't be determined due to error.\r\n// error should be less than divisor / 2.\r\nFMT_CONSTEXPR inline round_direction get_round_direction(uint64_t divisor,\r\n                                                         uint64_t remainder,\r\n                                                         uint64_t error) {\r\n  FMT_ASSERT(remainder < divisor, \"\");  // divisor - remainder won't overflow.\r\n  FMT_ASSERT(error < divisor, \"\");      // divisor - error won't overflow.\r\n  FMT_ASSERT(error < divisor - error, \"\");  // error * 2 won't overflow.\r\n  // Round down if (remainder + error) * 2 <= divisor.\r\n  if (remainder <= divisor - remainder && error * 2 <= divisor - remainder * 2)\r\n    return round_direction::down;\r\n  // Round up if (remainder - error) * 2 >= divisor.\r\n  if (remainder >= error &&\r\n      remainder - error >= divisor - (remainder - error)) {\r\n    return round_direction::up;\r\n  }\r\n  return round_direction::unknown;\r\n}\r\n\r\nnamespace digits {\r\nenum result {\r\n  more,  // Generate more digits.\r\n  done,  // Done generating digits.\r\n  error  // Digit generation cancelled due to an error.\r\n};\r\n}\r\n\r\nstruct gen_digits_handler {\r\n  char* buf;\r\n  int size;\r\n  int precision;\r\n  int exp10;\r\n  bool fixed;\r\n\r\n  FMT_CONSTEXPR digits::result on_digit(char digit, uint64_t divisor,\r\n                                        uint64_t remainder, uint64_t error,\r\n                                        bool integral) {\r\n    FMT_ASSERT(remainder < divisor, \"\");\r\n    buf[size++] = digit;\r\n    if (!integral && error >= remainder) return digits::error;\r\n    if (size < precision) return digits::more;\r\n    if (!integral) {\r\n      // Check if error * 2 < divisor with overflow prevention.\r\n      // The check is not needed for the integral part because error = 1\r\n      // and divisor > (1 << 32) there.\r\n      if (error >= divisor || error >= divisor - error) return digits::error;\r\n    } else {\r\n      FMT_ASSERT(error == 1 && divisor > 2, \"\");\r\n    }\r\n    auto dir = get_round_direction(divisor, remainder, error);\r\n    if (dir != round_direction::up)\r\n      return dir == round_direction::down ? digits::done : digits::error;\r\n    ++buf[size - 1];\r\n    for (int i = size - 1; i > 0 && buf[i] > '9'; --i) {\r\n      buf[i] = '0';\r\n      ++buf[i - 1];\r\n    }\r\n    if (buf[0] > '9') {\r\n      buf[0] = '1';\r\n      if (fixed)\r\n        buf[size++] = '0';\r\n      else\r\n        ++exp10;\r\n    }\r\n    return digits::done;\r\n  }\r\n};\r\n\r\n// Generates output using the Grisu digit-gen algorithm.\r\n// error: the size of the region (lower, upper) outside of which numbers\r\n// definitely do not round to value (Delta in Grisu3).\r\nFMT_INLINE FMT_CONSTEXPR20 digits::result grisu_gen_digits(\r\n    fp value, uint64_t error, int& exp, gen_digits_handler& handler) {\r\n  const fp one(1ULL << -value.e, value.e);\r\n  // The integral part of scaled value (p1 in Grisu) = value / one. It cannot be\r\n  // zero because it contains a product of two 64-bit numbers with MSB set (due\r\n  // to normalization) - 1, shifted right by at most 60 bits.\r\n  auto integral = static_cast<uint32_t>(value.f >> -one.e);\r\n  FMT_ASSERT(integral != 0, \"\");\r\n  FMT_ASSERT(integral == value.f >> -one.e, \"\");\r\n  // The fractional part of scaled value (p2 in Grisu) c = value % one.\r\n  uint64_t fractional = value.f & (one.f - 1);\r\n  exp = count_digits(integral);  // kappa in Grisu.\r\n  // Non-fixed formats require at least one digit and no precision adjustment.\r\n  if (handler.fixed) {\r\n    // Adjust fixed precision by exponent because it is relative to decimal\r\n    // point.\r\n    int precision_offset = exp + handler.exp10;\r\n    if (precision_offset > 0 &&\r\n        handler.precision > max_value<int>() - precision_offset) {\r\n      FMT_THROW(format_error(\"number is too big\"));\r\n    }\r\n    handler.precision += precision_offset;\r\n    // Check if precision is satisfied just by leading zeros, e.g.\r\n    // format(\"{:.2f}\", 0.001) gives \"0.00\" without generating any digits.\r\n    if (handler.precision <= 0) {\r\n      if (handler.precision < 0) return digits::done;\r\n      // Divide by 10 to prevent overflow.\r\n      uint64_t divisor = impl_data::power_of_10_64[exp - 1] << -one.e;\r\n      auto dir = get_round_direction(divisor, value.f / 10, error * 10);\r\n      if (dir == round_direction::unknown) return digits::error;\r\n      handler.buf[handler.size++] = dir == round_direction::up ? '1' : '0';\r\n      return digits::done;\r\n    }\r\n  }\r\n  // Generate digits for the integral part. This can produce up to 10 digits.\r\n  do {\r\n    uint32_t digit = 0;\r\n    auto divmod_integral = [&](uint32_t divisor) {\r\n      digit = integral / divisor;\r\n      integral %= divisor;\r\n    };\r\n    // This optimization by Milo Yip reduces the number of integer divisions by\r\n    // one per iteration.\r\n    switch (exp) {\r\n    case 10:\r\n      divmod_integral(1000000000);\r\n      break;\r\n    case 9:\r\n      divmod_integral(100000000);\r\n      break;\r\n    case 8:\r\n      divmod_integral(10000000);\r\n      break;\r\n    case 7:\r\n      divmod_integral(1000000);\r\n      break;\r\n    case 6:\r\n      divmod_integral(100000);\r\n      break;\r\n    case 5:\r\n      divmod_integral(10000);\r\n      break;\r\n    case 4:\r\n      divmod_integral(1000);\r\n      break;\r\n    case 3:\r\n      divmod_integral(100);\r\n      break;\r\n    case 2:\r\n      divmod_integral(10);\r\n      break;\r\n    case 1:\r\n      digit = integral;\r\n      integral = 0;\r\n      break;\r\n    default:\r\n      FMT_ASSERT(false, \"invalid number of digits\");\r\n    }\r\n    --exp;\r\n    auto remainder = (static_cast<uint64_t>(integral) << -one.e) + fractional;\r\n    auto result = handler.on_digit(static_cast<char>('0' + digit),\r\n                                   impl_data::power_of_10_64[exp] << -one.e,\r\n                                   remainder, error, true);\r\n    if (result != digits::more) return result;\r\n  } while (exp > 0);\r\n  // Generate digits for the fractional part.\r\n  for (;;) {\r\n    fractional *= 10;\r\n    error *= 10;\r\n    char digit = static_cast<char>('0' + (fractional >> -one.e));\r\n    fractional &= one.f - 1;\r\n    --exp;\r\n    auto result = handler.on_digit(digit, one.f, fractional, error, false);\r\n    if (result != digits::more) return result;\r\n  }\r\n}\r\n\r\n// A 128-bit integer type used internally,\r\nstruct uint128_wrapper {\r\n  uint128_wrapper() = default;\r\n\r\n#if FMT_USE_INT128\r\n  uint128_t internal_;\r\n\r\n  constexpr uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT\r\n      : internal_{static_cast<uint128_t>(low) |\r\n                  (static_cast<uint128_t>(high) << 64)} {}\r\n\r\n  constexpr uint128_wrapper(uint128_t u) : internal_{u} {}\r\n\r\n  constexpr uint64_t high() const FMT_NOEXCEPT {\r\n    return uint64_t(internal_ >> 64);\r\n  }\r\n  constexpr uint64_t low() const FMT_NOEXCEPT { return uint64_t(internal_); }\r\n\r\n  uint128_wrapper& operator+=(uint64_t n) FMT_NOEXCEPT {\r\n    internal_ += n;\r\n    return *this;\r\n  }\r\n#else\r\n  uint64_t high_;\r\n  uint64_t low_;\r\n\r\n  constexpr uint128_wrapper(uint64_t high, uint64_t low) FMT_NOEXCEPT\r\n      : high_{high},\r\n        low_{low} {}\r\n\r\n  constexpr uint64_t high() const FMT_NOEXCEPT { return high_; }\r\n  constexpr uint64_t low() const FMT_NOEXCEPT { return low_; }\r\n\r\n  uint128_wrapper& operator+=(uint64_t n) FMT_NOEXCEPT {\r\n#  if defined(_MSC_VER) && defined(_M_X64)\r\n    unsigned char carry = _addcarry_u64(0, low_, n, &low_);\r\n    _addcarry_u64(carry, high_, 0, &high_);\r\n    return *this;\r\n#  else\r\n    uint64_t sum = low_ + n;\r\n    high_ += (sum < low_ ? 1 : 0);\r\n    low_ = sum;\r\n    return *this;\r\n#  endif\r\n  }\r\n#endif\r\n};\r\n\r\n// Implementation of Dragonbox algorithm: https://github.com/jk-jeon/dragonbox.\r\nnamespace dragonbox {\r\n// Computes 128-bit result of multiplication of two 64-bit unsigned integers.\r\ninline uint128_wrapper umul128(uint64_t x, uint64_t y) FMT_NOEXCEPT {\r\n#if FMT_USE_INT128\r\n  return static_cast<uint128_t>(x) * static_cast<uint128_t>(y);\r\n#elif defined(_MSC_VER) && defined(_M_X64)\r\n  uint128_wrapper result;\r\n  result.low_ = _umul128(x, y, &result.high_);\r\n  return result;\r\n#else\r\n  const uint64_t mask = (uint64_t(1) << 32) - uint64_t(1);\r\n\r\n  uint64_t a = x >> 32;\r\n  uint64_t b = x & mask;\r\n  uint64_t c = y >> 32;\r\n  uint64_t d = y & mask;\r\n\r\n  uint64_t ac = a * c;\r\n  uint64_t bc = b * c;\r\n  uint64_t ad = a * d;\r\n  uint64_t bd = b * d;\r\n\r\n  uint64_t intermediate = (bd >> 32) + (ad & mask) + (bc & mask);\r\n\r\n  return {ac + (intermediate >> 32) + (ad >> 32) + (bc >> 32),\r\n          (intermediate << 32) + (bd & mask)};\r\n#endif\r\n}\r\n\r\n// Computes upper 64 bits of multiplication of two 64-bit unsigned integers.\r\ninline uint64_t umul128_upper64(uint64_t x, uint64_t y) FMT_NOEXCEPT {\r\n#if FMT_USE_INT128\r\n  auto p = static_cast<uint128_t>(x) * static_cast<uint128_t>(y);\r\n  return static_cast<uint64_t>(p >> 64);\r\n#elif defined(_MSC_VER) && defined(_M_X64)\r\n  return __umulh(x, y);\r\n#else\r\n  return umul128(x, y).high();\r\n#endif\r\n}\r\n\r\n// Computes upper 64 bits of multiplication of a 64-bit unsigned integer and a\r\n// 128-bit unsigned integer.\r\ninline uint64_t umul192_upper64(uint64_t x, uint128_wrapper y) FMT_NOEXCEPT {\r\n  uint128_wrapper g0 = umul128(x, y.high());\r\n  g0 += umul128_upper64(x, y.low());\r\n  return g0.high();\r\n}\r\n\r\n// Computes upper 32 bits of multiplication of a 32-bit unsigned integer and a\r\n// 64-bit unsigned integer.\r\ninline uint32_t umul96_upper32(uint32_t x, uint64_t y) FMT_NOEXCEPT {\r\n  return static_cast<uint32_t>(umul128_upper64(x, y));\r\n}\r\n\r\n// Computes middle 64 bits of multiplication of a 64-bit unsigned integer and a\r\n// 128-bit unsigned integer.\r\ninline uint64_t umul192_middle64(uint64_t x, uint128_wrapper y) FMT_NOEXCEPT {\r\n  uint64_t g01 = x * y.high();\r\n  uint64_t g10 = umul128_upper64(x, y.low());\r\n  return g01 + g10;\r\n}\r\n\r\n// Computes lower 64 bits of multiplication of a 32-bit unsigned integer and a\r\n// 64-bit unsigned integer.\r\ninline uint64_t umul96_lower64(uint32_t x, uint64_t y) FMT_NOEXCEPT {\r\n  return x * y;\r\n}\r\n\r\n// Computes floor(log10(pow(2, e))) for e in [-1700, 1700] using the method from\r\n// https://fmt.dev/papers/Grisu-Exact.pdf#page=5, section 3.4.\r\ninline int floor_log10_pow2(int e) FMT_NOEXCEPT {\r\n  FMT_ASSERT(e <= 1700 && e >= -1700, \"too large exponent\");\r\n  const int shift = 22;\r\n  return (e * static_cast<int>(log10_2_significand >> (64 - shift))) >> shift;\r\n}\r\n\r\n// Various fast log computations.\r\ninline int floor_log2_pow10(int e) FMT_NOEXCEPT {\r\n  FMT_ASSERT(e <= 1233 && e >= -1233, \"too large exponent\");\r\n  const uint64_t log2_10_integer_part = 3;\r\n  const uint64_t log2_10_fractional_digits = 0x5269e12f346e2bf9;\r\n  const int shift_amount = 19;\r\n  return (e * static_cast<int>(\r\n                  (log2_10_integer_part << shift_amount) |\r\n                  (log2_10_fractional_digits >> (64 - shift_amount)))) >>\r\n         shift_amount;\r\n}\r\ninline int floor_log10_pow2_minus_log10_4_over_3(int e) FMT_NOEXCEPT {\r\n  FMT_ASSERT(e <= 1700 && e >= -1700, \"too large exponent\");\r\n  const uint64_t log10_4_over_3_fractional_digits = 0x1ffbfc2bbc780375;\r\n  const int shift_amount = 22;\r\n  return (e * static_cast<int>(log10_2_significand >> (64 - shift_amount)) -\r\n          static_cast<int>(log10_4_over_3_fractional_digits >>\r\n                           (64 - shift_amount))) >>\r\n         shift_amount;\r\n}\r\n\r\n// Returns true iff x is divisible by pow(2, exp).\r\ninline bool divisible_by_power_of_2(uint32_t x, int exp) FMT_NOEXCEPT {\r\n  FMT_ASSERT(exp >= 1, \"\");\r\n  FMT_ASSERT(x != 0, \"\");\r\n#ifdef FMT_BUILTIN_CTZ\r\n  return FMT_BUILTIN_CTZ(x) >= exp;\r\n#else\r\n  return exp < num_bits<uint32_t>() && x == ((x >> exp) << exp);\r\n#endif\r\n}\r\ninline bool divisible_by_power_of_2(uint64_t x, int exp) FMT_NOEXCEPT {\r\n  FMT_ASSERT(exp >= 1, \"\");\r\n  FMT_ASSERT(x != 0, \"\");\r\n#ifdef FMT_BUILTIN_CTZLL\r\n  return FMT_BUILTIN_CTZLL(x) >= exp;\r\n#else\r\n  return exp < num_bits<uint64_t>() && x == ((x >> exp) << exp);\r\n#endif\r\n}\r\n\r\n// Table entry type for divisibility test.\r\ntemplate <typename T> struct divtest_table_entry {\r\n  T mod_inv;\r\n  T max_quotient;\r\n};\r\n\r\n// Returns true iff x is divisible by pow(5, exp).\r\ninline bool divisible_by_power_of_5(uint32_t x, int exp) FMT_NOEXCEPT {\r\n  FMT_ASSERT(exp <= 10, \"too large exponent\");\r\n  static constexpr const divtest_table_entry<uint32_t> divtest_table[] = {\r\n      {0x00000001, 0xffffffff}, {0xcccccccd, 0x33333333},\r\n      {0xc28f5c29, 0x0a3d70a3}, {0x26e978d5, 0x020c49ba},\r\n      {0x3afb7e91, 0x0068db8b}, {0x0bcbe61d, 0x0014f8b5},\r\n      {0x68c26139, 0x000431bd}, {0xae8d46a5, 0x0000d6bf},\r\n      {0x22e90e21, 0x00002af3}, {0x3a2e9c6d, 0x00000897},\r\n      {0x3ed61f49, 0x000001b7}};\r\n  return x * divtest_table[exp].mod_inv <= divtest_table[exp].max_quotient;\r\n}\r\ninline bool divisible_by_power_of_5(uint64_t x, int exp) FMT_NOEXCEPT {\r\n  FMT_ASSERT(exp <= 23, \"too large exponent\");\r\n  static constexpr const divtest_table_entry<uint64_t> divtest_table[] = {\r\n      {0x0000000000000001, 0xffffffffffffffff},\r\n      {0xcccccccccccccccd, 0x3333333333333333},\r\n      {0x8f5c28f5c28f5c29, 0x0a3d70a3d70a3d70},\r\n      {0x1cac083126e978d5, 0x020c49ba5e353f7c},\r\n      {0xd288ce703afb7e91, 0x0068db8bac710cb2},\r\n      {0x5d4e8fb00bcbe61d, 0x0014f8b588e368f0},\r\n      {0x790fb65668c26139, 0x000431bde82d7b63},\r\n      {0xe5032477ae8d46a5, 0x0000d6bf94d5e57a},\r\n      {0xc767074b22e90e21, 0x00002af31dc46118},\r\n      {0x8e47ce423a2e9c6d, 0x0000089705f4136b},\r\n      {0x4fa7f60d3ed61f49, 0x000001b7cdfd9d7b},\r\n      {0x0fee64690c913975, 0x00000057f5ff85e5},\r\n      {0x3662e0e1cf503eb1, 0x000000119799812d},\r\n      {0xa47a2cf9f6433fbd, 0x0000000384b84d09},\r\n      {0x54186f653140a659, 0x00000000b424dc35},\r\n      {0x7738164770402145, 0x0000000024075f3d},\r\n      {0xe4a4d1417cd9a041, 0x000000000734aca5},\r\n      {0xc75429d9e5c5200d, 0x000000000170ef54},\r\n      {0xc1773b91fac10669, 0x000000000049c977},\r\n      {0x26b172506559ce15, 0x00000000000ec1e4},\r\n      {0xd489e3a9addec2d1, 0x000000000002f394},\r\n      {0x90e860bb892c8d5d, 0x000000000000971d},\r\n      {0x502e79bf1b6f4f79, 0x0000000000001e39},\r\n      {0xdcd618596be30fe5, 0x000000000000060b}};\r\n  return x * divtest_table[exp].mod_inv <= divtest_table[exp].max_quotient;\r\n}\r\n\r\n// Replaces n by floor(n / pow(5, N)) returning true if and only if n is\r\n// divisible by pow(5, N).\r\n// Precondition: n <= 2 * pow(5, N + 1).\r\ntemplate <int N>\r\nbool check_divisibility_and_divide_by_pow5(uint32_t& n) FMT_NOEXCEPT {\r\n  static constexpr struct {\r\n    uint32_t magic_number;\r\n    int bits_for_comparison;\r\n    uint32_t threshold;\r\n    int shift_amount;\r\n  } infos[] = {{0xcccd, 16, 0x3333, 18}, {0xa429, 8, 0x0a, 20}};\r\n  constexpr auto info = infos[N - 1];\r\n  n *= info.magic_number;\r\n  const uint32_t comparison_mask = (1u << info.bits_for_comparison) - 1;\r\n  bool result = (n & comparison_mask) <= info.threshold;\r\n  n >>= info.shift_amount;\r\n  return result;\r\n}\r\n\r\n// Computes floor(n / pow(10, N)) for small n and N.\r\n// Precondition: n <= pow(10, N + 1).\r\ntemplate <int N> uint32_t small_division_by_pow10(uint32_t n) FMT_NOEXCEPT {\r\n  static constexpr struct {\r\n    uint32_t magic_number;\r\n    int shift_amount;\r\n    uint32_t divisor_times_10;\r\n  } infos[] = {{0xcccd, 19, 100}, {0xa3d8, 22, 1000}};\r\n  constexpr auto info = infos[N - 1];\r\n  FMT_ASSERT(n <= info.divisor_times_10, \"n is too large\");\r\n  return n * info.magic_number >> info.shift_amount;\r\n}\r\n\r\n// Computes floor(n / 10^(kappa + 1)) (float)\r\ninline uint32_t divide_by_10_to_kappa_plus_1(uint32_t n) FMT_NOEXCEPT {\r\n  return n / float_info<float>::big_divisor;\r\n}\r\n// Computes floor(n / 10^(kappa + 1)) (double)\r\ninline uint64_t divide_by_10_to_kappa_plus_1(uint64_t n) FMT_NOEXCEPT {\r\n  return umul128_upper64(n, 0x83126e978d4fdf3c) >> 9;\r\n}\r\n\r\n// Various subroutines using pow10 cache\r\ntemplate <class T> struct cache_accessor;\r\n\r\ntemplate <> struct cache_accessor<float> {\r\n  using carrier_uint = float_info<float>::carrier_uint;\r\n  using cache_entry_type = uint64_t;\r\n\r\n  static uint64_t get_cached_power(int k) FMT_NOEXCEPT {\r\n    FMT_ASSERT(k >= float_info<float>::min_k && k <= float_info<float>::max_k,\r\n               \"k is out of range\");\r\n    static constexpr const uint64_t pow10_significands[] = {\r\n        0x81ceb32c4b43fcf5, 0xa2425ff75e14fc32, 0xcad2f7f5359a3b3f,\r\n        0xfd87b5f28300ca0e, 0x9e74d1b791e07e49, 0xc612062576589ddb,\r\n        0xf79687aed3eec552, 0x9abe14cd44753b53, 0xc16d9a0095928a28,\r\n        0xf1c90080baf72cb2, 0x971da05074da7bef, 0xbce5086492111aeb,\r\n        0xec1e4a7db69561a6, 0x9392ee8e921d5d08, 0xb877aa3236a4b44a,\r\n        0xe69594bec44de15c, 0x901d7cf73ab0acda, 0xb424dc35095cd810,\r\n        0xe12e13424bb40e14, 0x8cbccc096f5088cc, 0xafebff0bcb24aaff,\r\n        0xdbe6fecebdedd5bf, 0x89705f4136b4a598, 0xabcc77118461cefd,\r\n        0xd6bf94d5e57a42bd, 0x8637bd05af6c69b6, 0xa7c5ac471b478424,\r\n        0xd1b71758e219652c, 0x83126e978d4fdf3c, 0xa3d70a3d70a3d70b,\r\n        0xcccccccccccccccd, 0x8000000000000000, 0xa000000000000000,\r\n        0xc800000000000000, 0xfa00000000000000, 0x9c40000000000000,\r\n        0xc350000000000000, 0xf424000000000000, 0x9896800000000000,\r\n        0xbebc200000000000, 0xee6b280000000000, 0x9502f90000000000,\r\n        0xba43b74000000000, 0xe8d4a51000000000, 0x9184e72a00000000,\r\n        0xb5e620f480000000, 0xe35fa931a0000000, 0x8e1bc9bf04000000,\r\n        0xb1a2bc2ec5000000, 0xde0b6b3a76400000, 0x8ac7230489e80000,\r\n        0xad78ebc5ac620000, 0xd8d726b7177a8000, 0x878678326eac9000,\r\n        0xa968163f0a57b400, 0xd3c21bcecceda100, 0x84595161401484a0,\r\n        0xa56fa5b99019a5c8, 0xcecb8f27f4200f3a, 0x813f3978f8940984,\r\n        0xa18f07d736b90be5, 0xc9f2c9cd04674ede, 0xfc6f7c4045812296,\r\n        0x9dc5ada82b70b59d, 0xc5371912364ce305, 0xf684df56c3e01bc6,\r\n        0x9a130b963a6c115c, 0xc097ce7bc90715b3, 0xf0bdc21abb48db20,\r\n        0x96769950b50d88f4, 0xbc143fa4e250eb31, 0xeb194f8e1ae525fd,\r\n        0x92efd1b8d0cf37be, 0xb7abc627050305ad, 0xe596b7b0c643c719,\r\n        0x8f7e32ce7bea5c6f, 0xb35dbf821ae4f38b, 0xe0352f62a19e306e};\r\n    return pow10_significands[k - float_info<float>::min_k];\r\n  }\r\n\r\n  static carrier_uint compute_mul(carrier_uint u,\r\n                                  const cache_entry_type& cache) FMT_NOEXCEPT {\r\n    return umul96_upper32(u, cache);\r\n  }\r\n\r\n  static uint32_t compute_delta(const cache_entry_type& cache,\r\n                                int beta_minus_1) FMT_NOEXCEPT {\r\n    return static_cast<uint32_t>(cache >> (64 - 1 - beta_minus_1));\r\n  }\r\n\r\n  static bool compute_mul_parity(carrier_uint two_f,\r\n                                 const cache_entry_type& cache,\r\n                                 int beta_minus_1) FMT_NOEXCEPT {\r\n    FMT_ASSERT(beta_minus_1 >= 1, \"\");\r\n    FMT_ASSERT(beta_minus_1 < 64, \"\");\r\n\r\n    return ((umul96_lower64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;\r\n  }\r\n\r\n  static carrier_uint compute_left_endpoint_for_shorter_interval_case(\r\n      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {\r\n    return static_cast<carrier_uint>(\r\n        (cache - (cache >> (float_info<float>::significand_bits + 2))) >>\r\n        (64 - float_info<float>::significand_bits - 1 - beta_minus_1));\r\n  }\r\n\r\n  static carrier_uint compute_right_endpoint_for_shorter_interval_case(\r\n      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {\r\n    return static_cast<carrier_uint>(\r\n        (cache + (cache >> (float_info<float>::significand_bits + 1))) >>\r\n        (64 - float_info<float>::significand_bits - 1 - beta_minus_1));\r\n  }\r\n\r\n  static carrier_uint compute_round_up_for_shorter_interval_case(\r\n      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {\r\n    return (static_cast<carrier_uint>(\r\n                cache >>\r\n                (64 - float_info<float>::significand_bits - 2 - beta_minus_1)) +\r\n            1) /\r\n           2;\r\n  }\r\n};\r\n\r\ntemplate <> struct cache_accessor<double> {\r\n  using carrier_uint = float_info<double>::carrier_uint;\r\n  using cache_entry_type = uint128_wrapper;\r\n\r\n  static uint128_wrapper get_cached_power(int k) FMT_NOEXCEPT {\r\n    FMT_ASSERT(k >= float_info<double>::min_k && k <= float_info<double>::max_k,\r\n               \"k is out of range\");\r\n\r\n    static constexpr const uint128_wrapper pow10_significands[] = {\r\n#if FMT_USE_FULL_CACHE_DRAGONBOX\r\n      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},\r\n      {0x9faacf3df73609b1, 0x77b191618c54e9ad},\r\n      {0xc795830d75038c1d, 0xd59df5b9ef6a2418},\r\n      {0xf97ae3d0d2446f25, 0x4b0573286b44ad1e},\r\n      {0x9becce62836ac577, 0x4ee367f9430aec33},\r\n      {0xc2e801fb244576d5, 0x229c41f793cda740},\r\n      {0xf3a20279ed56d48a, 0x6b43527578c11110},\r\n      {0x9845418c345644d6, 0x830a13896b78aaaa},\r\n      {0xbe5691ef416bd60c, 0x23cc986bc656d554},\r\n      {0xedec366b11c6cb8f, 0x2cbfbe86b7ec8aa9},\r\n      {0x94b3a202eb1c3f39, 0x7bf7d71432f3d6aa},\r\n      {0xb9e08a83a5e34f07, 0xdaf5ccd93fb0cc54},\r\n      {0xe858ad248f5c22c9, 0xd1b3400f8f9cff69},\r\n      {0x91376c36d99995be, 0x23100809b9c21fa2},\r\n      {0xb58547448ffffb2d, 0xabd40a0c2832a78b},\r\n      {0xe2e69915b3fff9f9, 0x16c90c8f323f516d},\r\n      {0x8dd01fad907ffc3b, 0xae3da7d97f6792e4},\r\n      {0xb1442798f49ffb4a, 0x99cd11cfdf41779d},\r\n      {0xdd95317f31c7fa1d, 0x40405643d711d584},\r\n      {0x8a7d3eef7f1cfc52, 0x482835ea666b2573},\r\n      {0xad1c8eab5ee43b66, 0xda3243650005eed0},\r\n      {0xd863b256369d4a40, 0x90bed43e40076a83},\r\n      {0x873e4f75e2224e68, 0x5a7744a6e804a292},\r\n      {0xa90de3535aaae202, 0x711515d0a205cb37},\r\n      {0xd3515c2831559a83, 0x0d5a5b44ca873e04},\r\n      {0x8412d9991ed58091, 0xe858790afe9486c3},\r\n      {0xa5178fff668ae0b6, 0x626e974dbe39a873},\r\n      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},\r\n      {0x80fa687f881c7f8e, 0x7ce66634bc9d0b9a},\r\n      {0xa139029f6a239f72, 0x1c1fffc1ebc44e81},\r\n      {0xc987434744ac874e, 0xa327ffb266b56221},\r\n      {0xfbe9141915d7a922, 0x4bf1ff9f0062baa9},\r\n      {0x9d71ac8fada6c9b5, 0x6f773fc3603db4aa},\r\n      {0xc4ce17b399107c22, 0xcb550fb4384d21d4},\r\n      {0xf6019da07f549b2b, 0x7e2a53a146606a49},\r\n      {0x99c102844f94e0fb, 0x2eda7444cbfc426e},\r\n      {0xc0314325637a1939, 0xfa911155fefb5309},\r\n      {0xf03d93eebc589f88, 0x793555ab7eba27cb},\r\n      {0x96267c7535b763b5, 0x4bc1558b2f3458df},\r\n      {0xbbb01b9283253ca2, 0x9eb1aaedfb016f17},\r\n      {0xea9c227723ee8bcb, 0x465e15a979c1cadd},\r\n      {0x92a1958a7675175f, 0x0bfacd89ec191eca},\r\n      {0xb749faed14125d36, 0xcef980ec671f667c},\r\n      {0xe51c79a85916f484, 0x82b7e12780e7401b},\r\n      {0x8f31cc0937ae58d2, 0xd1b2ecb8b0908811},\r\n      {0xb2fe3f0b8599ef07, 0x861fa7e6dcb4aa16},\r\n      {0xdfbdcece67006ac9, 0x67a791e093e1d49b},\r\n      {0x8bd6a141006042bd, 0xe0c8bb2c5c6d24e1},\r\n      {0xaecc49914078536d, 0x58fae9f773886e19},\r\n      {0xda7f5bf590966848, 0xaf39a475506a899f},\r\n      {0x888f99797a5e012d, 0x6d8406c952429604},\r\n      {0xaab37fd7d8f58178, 0xc8e5087ba6d33b84},\r\n      {0xd5605fcdcf32e1d6, 0xfb1e4a9a90880a65},\r\n      {0x855c3be0a17fcd26, 0x5cf2eea09a550680},\r\n      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},\r\n      {0xd0601d8efc57b08b, 0xf13b94daf124da27},\r\n      {0x823c12795db6ce57, 0x76c53d08d6b70859},\r\n      {0xa2cb1717b52481ed, 0x54768c4b0c64ca6f},\r\n      {0xcb7ddcdda26da268, 0xa9942f5dcf7dfd0a},\r\n      {0xfe5d54150b090b02, 0xd3f93b35435d7c4d},\r\n      {0x9efa548d26e5a6e1, 0xc47bc5014a1a6db0},\r\n      {0xc6b8e9b0709f109a, 0x359ab6419ca1091c},\r\n      {0xf867241c8cc6d4c0, 0xc30163d203c94b63},\r\n      {0x9b407691d7fc44f8, 0x79e0de63425dcf1e},\r\n      {0xc21094364dfb5636, 0x985915fc12f542e5},\r\n      {0xf294b943e17a2bc4, 0x3e6f5b7b17b2939e},\r\n      {0x979cf3ca6cec5b5a, 0xa705992ceecf9c43},\r\n      {0xbd8430bd08277231, 0x50c6ff782a838354},\r\n      {0xece53cec4a314ebd, 0xa4f8bf5635246429},\r\n      {0x940f4613ae5ed136, 0x871b7795e136be9a},\r\n      {0xb913179899f68584, 0x28e2557b59846e40},\r\n      {0xe757dd7ec07426e5, 0x331aeada2fe589d0},\r\n      {0x9096ea6f3848984f, 0x3ff0d2c85def7622},\r\n      {0xb4bca50b065abe63, 0x0fed077a756b53aa},\r\n      {0xe1ebce4dc7f16dfb, 0xd3e8495912c62895},\r\n      {0x8d3360f09cf6e4bd, 0x64712dd7abbbd95d},\r\n      {0xb080392cc4349dec, 0xbd8d794d96aacfb4},\r\n      {0xdca04777f541c567, 0xecf0d7a0fc5583a1},\r\n      {0x89e42caaf9491b60, 0xf41686c49db57245},\r\n      {0xac5d37d5b79b6239, 0x311c2875c522ced6},\r\n      {0xd77485cb25823ac7, 0x7d633293366b828c},\r\n      {0x86a8d39ef77164bc, 0xae5dff9c02033198},\r\n      {0xa8530886b54dbdeb, 0xd9f57f830283fdfd},\r\n      {0xd267caa862a12d66, 0xd072df63c324fd7c},\r\n      {0x8380dea93da4bc60, 0x4247cb9e59f71e6e},\r\n      {0xa46116538d0deb78, 0x52d9be85f074e609},\r\n      {0xcd795be870516656, 0x67902e276c921f8c},\r\n      {0x806bd9714632dff6, 0x00ba1cd8a3db53b7},\r\n      {0xa086cfcd97bf97f3, 0x80e8a40eccd228a5},\r\n      {0xc8a883c0fdaf7df0, 0x6122cd128006b2ce},\r\n      {0xfad2a4b13d1b5d6c, 0x796b805720085f82},\r\n      {0x9cc3a6eec6311a63, 0xcbe3303674053bb1},\r\n      {0xc3f490aa77bd60fc, 0xbedbfc4411068a9d},\r\n      {0xf4f1b4d515acb93b, 0xee92fb5515482d45},\r\n      {0x991711052d8bf3c5, 0x751bdd152d4d1c4b},\r\n      {0xbf5cd54678eef0b6, 0xd262d45a78a0635e},\r\n      {0xef340a98172aace4, 0x86fb897116c87c35},\r\n      {0x9580869f0e7aac0e, 0xd45d35e6ae3d4da1},\r\n      {0xbae0a846d2195712, 0x8974836059cca10a},\r\n      {0xe998d258869facd7, 0x2bd1a438703fc94c},\r\n      {0x91ff83775423cc06, 0x7b6306a34627ddd0},\r\n      {0xb67f6455292cbf08, 0x1a3bc84c17b1d543},\r\n      {0xe41f3d6a7377eeca, 0x20caba5f1d9e4a94},\r\n      {0x8e938662882af53e, 0x547eb47b7282ee9d},\r\n      {0xb23867fb2a35b28d, 0xe99e619a4f23aa44},\r\n      {0xdec681f9f4c31f31, 0x6405fa00e2ec94d5},\r\n      {0x8b3c113c38f9f37e, 0xde83bc408dd3dd05},\r\n      {0xae0b158b4738705e, 0x9624ab50b148d446},\r\n      {0xd98ddaee19068c76, 0x3badd624dd9b0958},\r\n      {0x87f8a8d4cfa417c9, 0xe54ca5d70a80e5d7},\r\n      {0xa9f6d30a038d1dbc, 0x5e9fcf4ccd211f4d},\r\n      {0xd47487cc8470652b, 0x7647c32000696720},\r\n      {0x84c8d4dfd2c63f3b, 0x29ecd9f40041e074},\r\n      {0xa5fb0a17c777cf09, 0xf468107100525891},\r\n      {0xcf79cc9db955c2cc, 0x7182148d4066eeb5},\r\n      {0x81ac1fe293d599bf, 0xc6f14cd848405531},\r\n      {0xa21727db38cb002f, 0xb8ada00e5a506a7d},\r\n      {0xca9cf1d206fdc03b, 0xa6d90811f0e4851d},\r\n      {0xfd442e4688bd304a, 0x908f4a166d1da664},\r\n      {0x9e4a9cec15763e2e, 0x9a598e4e043287ff},\r\n      {0xc5dd44271ad3cdba, 0x40eff1e1853f29fe},\r\n      {0xf7549530e188c128, 0xd12bee59e68ef47d},\r\n      {0x9a94dd3e8cf578b9, 0x82bb74f8301958cf},\r\n      {0xc13a148e3032d6e7, 0xe36a52363c1faf02},\r\n      {0xf18899b1bc3f8ca1, 0xdc44e6c3cb279ac2},\r\n      {0x96f5600f15a7b7e5, 0x29ab103a5ef8c0ba},\r\n      {0xbcb2b812db11a5de, 0x7415d448f6b6f0e8},\r\n      {0xebdf661791d60f56, 0x111b495b3464ad22},\r\n      {0x936b9fcebb25c995, 0xcab10dd900beec35},\r\n      {0xb84687c269ef3bfb, 0x3d5d514f40eea743},\r\n      {0xe65829b3046b0afa, 0x0cb4a5a3112a5113},\r\n      {0x8ff71a0fe2c2e6dc, 0x47f0e785eaba72ac},\r\n      {0xb3f4e093db73a093, 0x59ed216765690f57},\r\n      {0xe0f218b8d25088b8, 0x306869c13ec3532d},\r\n      {0x8c974f7383725573, 0x1e414218c73a13fc},\r\n      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},\r\n      {0xdbac6c247d62a583, 0xdf45f746b74abf3a},\r\n      {0x894bc396ce5da772, 0x6b8bba8c328eb784},\r\n      {0xab9eb47c81f5114f, 0x066ea92f3f326565},\r\n      {0xd686619ba27255a2, 0xc80a537b0efefebe},\r\n      {0x8613fd0145877585, 0xbd06742ce95f5f37},\r\n      {0xa798fc4196e952e7, 0x2c48113823b73705},\r\n      {0xd17f3b51fca3a7a0, 0xf75a15862ca504c6},\r\n      {0x82ef85133de648c4, 0x9a984d73dbe722fc},\r\n      {0xa3ab66580d5fdaf5, 0xc13e60d0d2e0ebbb},\r\n      {0xcc963fee10b7d1b3, 0x318df905079926a9},\r\n      {0xffbbcfe994e5c61f, 0xfdf17746497f7053},\r\n      {0x9fd561f1fd0f9bd3, 0xfeb6ea8bedefa634},\r\n      {0xc7caba6e7c5382c8, 0xfe64a52ee96b8fc1},\r\n      {0xf9bd690a1b68637b, 0x3dfdce7aa3c673b1},\r\n      {0x9c1661a651213e2d, 0x06bea10ca65c084f},\r\n      {0xc31bfa0fe5698db8, 0x486e494fcff30a63},\r\n      {0xf3e2f893dec3f126, 0x5a89dba3c3efccfb},\r\n      {0x986ddb5c6b3a76b7, 0xf89629465a75e01d},\r\n      {0xbe89523386091465, 0xf6bbb397f1135824},\r\n      {0xee2ba6c0678b597f, 0x746aa07ded582e2d},\r\n      {0x94db483840b717ef, 0xa8c2a44eb4571cdd},\r\n      {0xba121a4650e4ddeb, 0x92f34d62616ce414},\r\n      {0xe896a0d7e51e1566, 0x77b020baf9c81d18},\r\n      {0x915e2486ef32cd60, 0x0ace1474dc1d122f},\r\n      {0xb5b5ada8aaff80b8, 0x0d819992132456bb},\r\n      {0xe3231912d5bf60e6, 0x10e1fff697ed6c6a},\r\n      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},\r\n      {0xb1736b96b6fd83b3, 0xbd308ff8a6b17cb3},\r\n      {0xddd0467c64bce4a0, 0xac7cb3f6d05ddbdf},\r\n      {0x8aa22c0dbef60ee4, 0x6bcdf07a423aa96c},\r\n      {0xad4ab7112eb3929d, 0x86c16c98d2c953c7},\r\n      {0xd89d64d57a607744, 0xe871c7bf077ba8b8},\r\n      {0x87625f056c7c4a8b, 0x11471cd764ad4973},\r\n      {0xa93af6c6c79b5d2d, 0xd598e40d3dd89bd0},\r\n      {0xd389b47879823479, 0x4aff1d108d4ec2c4},\r\n      {0x843610cb4bf160cb, 0xcedf722a585139bb},\r\n      {0xa54394fe1eedb8fe, 0xc2974eb4ee658829},\r\n      {0xce947a3da6a9273e, 0x733d226229feea33},\r\n      {0x811ccc668829b887, 0x0806357d5a3f5260},\r\n      {0xa163ff802a3426a8, 0xca07c2dcb0cf26f8},\r\n      {0xc9bcff6034c13052, 0xfc89b393dd02f0b6},\r\n      {0xfc2c3f3841f17c67, 0xbbac2078d443ace3},\r\n      {0x9d9ba7832936edc0, 0xd54b944b84aa4c0e},\r\n      {0xc5029163f384a931, 0x0a9e795e65d4df12},\r\n      {0xf64335bcf065d37d, 0x4d4617b5ff4a16d6},\r\n      {0x99ea0196163fa42e, 0x504bced1bf8e4e46},\r\n      {0xc06481fb9bcf8d39, 0xe45ec2862f71e1d7},\r\n      {0xf07da27a82c37088, 0x5d767327bb4e5a4d},\r\n      {0x964e858c91ba2655, 0x3a6a07f8d510f870},\r\n      {0xbbe226efb628afea, 0x890489f70a55368c},\r\n      {0xeadab0aba3b2dbe5, 0x2b45ac74ccea842f},\r\n      {0x92c8ae6b464fc96f, 0x3b0b8bc90012929e},\r\n      {0xb77ada0617e3bbcb, 0x09ce6ebb40173745},\r\n      {0xe55990879ddcaabd, 0xcc420a6a101d0516},\r\n      {0x8f57fa54c2a9eab6, 0x9fa946824a12232e},\r\n      {0xb32df8e9f3546564, 0x47939822dc96abfa},\r\n      {0xdff9772470297ebd, 0x59787e2b93bc56f8},\r\n      {0x8bfbea76c619ef36, 0x57eb4edb3c55b65b},\r\n      {0xaefae51477a06b03, 0xede622920b6b23f2},\r\n      {0xdab99e59958885c4, 0xe95fab368e45ecee},\r\n      {0x88b402f7fd75539b, 0x11dbcb0218ebb415},\r\n      {0xaae103b5fcd2a881, 0xd652bdc29f26a11a},\r\n      {0xd59944a37c0752a2, 0x4be76d3346f04960},\r\n      {0x857fcae62d8493a5, 0x6f70a4400c562ddc},\r\n      {0xa6dfbd9fb8e5b88e, 0xcb4ccd500f6bb953},\r\n      {0xd097ad07a71f26b2, 0x7e2000a41346a7a8},\r\n      {0x825ecc24c873782f, 0x8ed400668c0c28c9},\r\n      {0xa2f67f2dfa90563b, 0x728900802f0f32fb},\r\n      {0xcbb41ef979346bca, 0x4f2b40a03ad2ffba},\r\n      {0xfea126b7d78186bc, 0xe2f610c84987bfa9},\r\n      {0x9f24b832e6b0f436, 0x0dd9ca7d2df4d7ca},\r\n      {0xc6ede63fa05d3143, 0x91503d1c79720dbc},\r\n      {0xf8a95fcf88747d94, 0x75a44c6397ce912b},\r\n      {0x9b69dbe1b548ce7c, 0xc986afbe3ee11abb},\r\n      {0xc24452da229b021b, 0xfbe85badce996169},\r\n      {0xf2d56790ab41c2a2, 0xfae27299423fb9c4},\r\n      {0x97c560ba6b0919a5, 0xdccd879fc967d41b},\r\n      {0xbdb6b8e905cb600f, 0x5400e987bbc1c921},\r\n      {0xed246723473e3813, 0x290123e9aab23b69},\r\n      {0x9436c0760c86e30b, 0xf9a0b6720aaf6522},\r\n      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},\r\n      {0xe7958cb87392c2c2, 0xb60b1d1230b20e05},\r\n      {0x90bd77f3483bb9b9, 0xb1c6f22b5e6f48c3},\r\n      {0xb4ecd5f01a4aa828, 0x1e38aeb6360b1af4},\r\n      {0xe2280b6c20dd5232, 0x25c6da63c38de1b1},\r\n      {0x8d590723948a535f, 0x579c487e5a38ad0f},\r\n      {0xb0af48ec79ace837, 0x2d835a9df0c6d852},\r\n      {0xdcdb1b2798182244, 0xf8e431456cf88e66},\r\n      {0x8a08f0f8bf0f156b, 0x1b8e9ecb641b5900},\r\n      {0xac8b2d36eed2dac5, 0xe272467e3d222f40},\r\n      {0xd7adf884aa879177, 0x5b0ed81dcc6abb10},\r\n      {0x86ccbb52ea94baea, 0x98e947129fc2b4ea},\r\n      {0xa87fea27a539e9a5, 0x3f2398d747b36225},\r\n      {0xd29fe4b18e88640e, 0x8eec7f0d19a03aae},\r\n      {0x83a3eeeef9153e89, 0x1953cf68300424ad},\r\n      {0xa48ceaaab75a8e2b, 0x5fa8c3423c052dd8},\r\n      {0xcdb02555653131b6, 0x3792f412cb06794e},\r\n      {0x808e17555f3ebf11, 0xe2bbd88bbee40bd1},\r\n      {0xa0b19d2ab70e6ed6, 0x5b6aceaeae9d0ec5},\r\n      {0xc8de047564d20a8b, 0xf245825a5a445276},\r\n      {0xfb158592be068d2e, 0xeed6e2f0f0d56713},\r\n      {0x9ced737bb6c4183d, 0x55464dd69685606c},\r\n      {0xc428d05aa4751e4c, 0xaa97e14c3c26b887},\r\n      {0xf53304714d9265df, 0xd53dd99f4b3066a9},\r\n      {0x993fe2c6d07b7fab, 0xe546a8038efe402a},\r\n      {0xbf8fdb78849a5f96, 0xde98520472bdd034},\r\n      {0xef73d256a5c0f77c, 0x963e66858f6d4441},\r\n      {0x95a8637627989aad, 0xdde7001379a44aa9},\r\n      {0xbb127c53b17ec159, 0x5560c018580d5d53},\r\n      {0xe9d71b689dde71af, 0xaab8f01e6e10b4a7},\r\n      {0x9226712162ab070d, 0xcab3961304ca70e9},\r\n      {0xb6b00d69bb55c8d1, 0x3d607b97c5fd0d23},\r\n      {0xe45c10c42a2b3b05, 0x8cb89a7db77c506b},\r\n      {0x8eb98a7a9a5b04e3, 0x77f3608e92adb243},\r\n      {0xb267ed1940f1c61c, 0x55f038b237591ed4},\r\n      {0xdf01e85f912e37a3, 0x6b6c46dec52f6689},\r\n      {0x8b61313bbabce2c6, 0x2323ac4b3b3da016},\r\n      {0xae397d8aa96c1b77, 0xabec975e0a0d081b},\r\n      {0xd9c7dced53c72255, 0x96e7bd358c904a22},\r\n      {0x881cea14545c7575, 0x7e50d64177da2e55},\r\n      {0xaa242499697392d2, 0xdde50bd1d5d0b9ea},\r\n      {0xd4ad2dbfc3d07787, 0x955e4ec64b44e865},\r\n      {0x84ec3c97da624ab4, 0xbd5af13bef0b113f},\r\n      {0xa6274bbdd0fadd61, 0xecb1ad8aeacdd58f},\r\n      {0xcfb11ead453994ba, 0x67de18eda5814af3},\r\n      {0x81ceb32c4b43fcf4, 0x80eacf948770ced8},\r\n      {0xa2425ff75e14fc31, 0xa1258379a94d028e},\r\n      {0xcad2f7f5359a3b3e, 0x096ee45813a04331},\r\n      {0xfd87b5f28300ca0d, 0x8bca9d6e188853fd},\r\n      {0x9e74d1b791e07e48, 0x775ea264cf55347e},\r\n      {0xc612062576589dda, 0x95364afe032a819e},\r\n      {0xf79687aed3eec551, 0x3a83ddbd83f52205},\r\n      {0x9abe14cd44753b52, 0xc4926a9672793543},\r\n      {0xc16d9a0095928a27, 0x75b7053c0f178294},\r\n      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},\r\n      {0x971da05074da7bee, 0xd3f6fc16ebca5e04},\r\n      {0xbce5086492111aea, 0x88f4bb1ca6bcf585},\r\n      {0xec1e4a7db69561a5, 0x2b31e9e3d06c32e6},\r\n      {0x9392ee8e921d5d07, 0x3aff322e62439fd0},\r\n      {0xb877aa3236a4b449, 0x09befeb9fad487c3},\r\n      {0xe69594bec44de15b, 0x4c2ebe687989a9b4},\r\n      {0x901d7cf73ab0acd9, 0x0f9d37014bf60a11},\r\n      {0xb424dc35095cd80f, 0x538484c19ef38c95},\r\n      {0xe12e13424bb40e13, 0x2865a5f206b06fba},\r\n      {0x8cbccc096f5088cb, 0xf93f87b7442e45d4},\r\n      {0xafebff0bcb24aafe, 0xf78f69a51539d749},\r\n      {0xdbe6fecebdedd5be, 0xb573440e5a884d1c},\r\n      {0x89705f4136b4a597, 0x31680a88f8953031},\r\n      {0xabcc77118461cefc, 0xfdc20d2b36ba7c3e},\r\n      {0xd6bf94d5e57a42bc, 0x3d32907604691b4d},\r\n      {0x8637bd05af6c69b5, 0xa63f9a49c2c1b110},\r\n      {0xa7c5ac471b478423, 0x0fcf80dc33721d54},\r\n      {0xd1b71758e219652b, 0xd3c36113404ea4a9},\r\n      {0x83126e978d4fdf3b, 0x645a1cac083126ea},\r\n      {0xa3d70a3d70a3d70a, 0x3d70a3d70a3d70a4},\r\n      {0xcccccccccccccccc, 0xcccccccccccccccd},\r\n      {0x8000000000000000, 0x0000000000000000},\r\n      {0xa000000000000000, 0x0000000000000000},\r\n      {0xc800000000000000, 0x0000000000000000},\r\n      {0xfa00000000000000, 0x0000000000000000},\r\n      {0x9c40000000000000, 0x0000000000000000},\r\n      {0xc350000000000000, 0x0000000000000000},\r\n      {0xf424000000000000, 0x0000000000000000},\r\n      {0x9896800000000000, 0x0000000000000000},\r\n      {0xbebc200000000000, 0x0000000000000000},\r\n      {0xee6b280000000000, 0x0000000000000000},\r\n      {0x9502f90000000000, 0x0000000000000000},\r\n      {0xba43b74000000000, 0x0000000000000000},\r\n      {0xe8d4a51000000000, 0x0000000000000000},\r\n      {0x9184e72a00000000, 0x0000000000000000},\r\n      {0xb5e620f480000000, 0x0000000000000000},\r\n      {0xe35fa931a0000000, 0x0000000000000000},\r\n      {0x8e1bc9bf04000000, 0x0000000000000000},\r\n      {0xb1a2bc2ec5000000, 0x0000000000000000},\r\n      {0xde0b6b3a76400000, 0x0000000000000000},\r\n      {0x8ac7230489e80000, 0x0000000000000000},\r\n      {0xad78ebc5ac620000, 0x0000000000000000},\r\n      {0xd8d726b7177a8000, 0x0000000000000000},\r\n      {0x878678326eac9000, 0x0000000000000000},\r\n      {0xa968163f0a57b400, 0x0000000000000000},\r\n      {0xd3c21bcecceda100, 0x0000000000000000},\r\n      {0x84595161401484a0, 0x0000000000000000},\r\n      {0xa56fa5b99019a5c8, 0x0000000000000000},\r\n      {0xcecb8f27f4200f3a, 0x0000000000000000},\r\n      {0x813f3978f8940984, 0x4000000000000000},\r\n      {0xa18f07d736b90be5, 0x5000000000000000},\r\n      {0xc9f2c9cd04674ede, 0xa400000000000000},\r\n      {0xfc6f7c4045812296, 0x4d00000000000000},\r\n      {0x9dc5ada82b70b59d, 0xf020000000000000},\r\n      {0xc5371912364ce305, 0x6c28000000000000},\r\n      {0xf684df56c3e01bc6, 0xc732000000000000},\r\n      {0x9a130b963a6c115c, 0x3c7f400000000000},\r\n      {0xc097ce7bc90715b3, 0x4b9f100000000000},\r\n      {0xf0bdc21abb48db20, 0x1e86d40000000000},\r\n      {0x96769950b50d88f4, 0x1314448000000000},\r\n      {0xbc143fa4e250eb31, 0x17d955a000000000},\r\n      {0xeb194f8e1ae525fd, 0x5dcfab0800000000},\r\n      {0x92efd1b8d0cf37be, 0x5aa1cae500000000},\r\n      {0xb7abc627050305ad, 0xf14a3d9e40000000},\r\n      {0xe596b7b0c643c719, 0x6d9ccd05d0000000},\r\n      {0x8f7e32ce7bea5c6f, 0xe4820023a2000000},\r\n      {0xb35dbf821ae4f38b, 0xdda2802c8a800000},\r\n      {0xe0352f62a19e306e, 0xd50b2037ad200000},\r\n      {0x8c213d9da502de45, 0x4526f422cc340000},\r\n      {0xaf298d050e4395d6, 0x9670b12b7f410000},\r\n      {0xdaf3f04651d47b4c, 0x3c0cdd765f114000},\r\n      {0x88d8762bf324cd0f, 0xa5880a69fb6ac800},\r\n      {0xab0e93b6efee0053, 0x8eea0d047a457a00},\r\n      {0xd5d238a4abe98068, 0x72a4904598d6d880},\r\n      {0x85a36366eb71f041, 0x47a6da2b7f864750},\r\n      {0xa70c3c40a64e6c51, 0x999090b65f67d924},\r\n      {0xd0cf4b50cfe20765, 0xfff4b4e3f741cf6d},\r\n      {0x82818f1281ed449f, 0xbff8f10e7a8921a4},\r\n      {0xa321f2d7226895c7, 0xaff72d52192b6a0d},\r\n      {0xcbea6f8ceb02bb39, 0x9bf4f8a69f764490},\r\n      {0xfee50b7025c36a08, 0x02f236d04753d5b4},\r\n      {0x9f4f2726179a2245, 0x01d762422c946590},\r\n      {0xc722f0ef9d80aad6, 0x424d3ad2b7b97ef5},\r\n      {0xf8ebad2b84e0d58b, 0xd2e0898765a7deb2},\r\n      {0x9b934c3b330c8577, 0x63cc55f49f88eb2f},\r\n      {0xc2781f49ffcfa6d5, 0x3cbf6b71c76b25fb},\r\n      {0xf316271c7fc3908a, 0x8bef464e3945ef7a},\r\n      {0x97edd871cfda3a56, 0x97758bf0e3cbb5ac},\r\n      {0xbde94e8e43d0c8ec, 0x3d52eeed1cbea317},\r\n      {0xed63a231d4c4fb27, 0x4ca7aaa863ee4bdd},\r\n      {0x945e455f24fb1cf8, 0x8fe8caa93e74ef6a},\r\n      {0xb975d6b6ee39e436, 0xb3e2fd538e122b44},\r\n      {0xe7d34c64a9c85d44, 0x60dbbca87196b616},\r\n      {0x90e40fbeea1d3a4a, 0xbc8955e946fe31cd},\r\n      {0xb51d13aea4a488dd, 0x6babab6398bdbe41},\r\n      {0xe264589a4dcdab14, 0xc696963c7eed2dd1},\r\n      {0x8d7eb76070a08aec, 0xfc1e1de5cf543ca2},\r\n      {0xb0de65388cc8ada8, 0x3b25a55f43294bcb},\r\n      {0xdd15fe86affad912, 0x49ef0eb713f39ebe},\r\n      {0x8a2dbf142dfcc7ab, 0x6e3569326c784337},\r\n      {0xacb92ed9397bf996, 0x49c2c37f07965404},\r\n      {0xd7e77a8f87daf7fb, 0xdc33745ec97be906},\r\n      {0x86f0ac99b4e8dafd, 0x69a028bb3ded71a3},\r\n      {0xa8acd7c0222311bc, 0xc40832ea0d68ce0c},\r\n      {0xd2d80db02aabd62b, 0xf50a3fa490c30190},\r\n      {0x83c7088e1aab65db, 0x792667c6da79e0fa},\r\n      {0xa4b8cab1a1563f52, 0x577001b891185938},\r\n      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},\r\n      {0x80b05e5ac60b6178, 0x544f8158315b05b4},\r\n      {0xa0dc75f1778e39d6, 0x696361ae3db1c721},\r\n      {0xc913936dd571c84c, 0x03bc3a19cd1e38e9},\r\n      {0xfb5878494ace3a5f, 0x04ab48a04065c723},\r\n      {0x9d174b2dcec0e47b, 0x62eb0d64283f9c76},\r\n      {0xc45d1df942711d9a, 0x3ba5d0bd324f8394},\r\n      {0xf5746577930d6500, 0xca8f44ec7ee36479},\r\n      {0x9968bf6abbe85f20, 0x7e998b13cf4e1ecb},\r\n      {0xbfc2ef456ae276e8, 0x9e3fedd8c321a67e},\r\n      {0xefb3ab16c59b14a2, 0xc5cfe94ef3ea101e},\r\n      {0x95d04aee3b80ece5, 0xbba1f1d158724a12},\r\n      {0xbb445da9ca61281f, 0x2a8a6e45ae8edc97},\r\n      {0xea1575143cf97226, 0xf52d09d71a3293bd},\r\n      {0x924d692ca61be758, 0x593c2626705f9c56},\r\n      {0xb6e0c377cfa2e12e, 0x6f8b2fb00c77836c},\r\n      {0xe498f455c38b997a, 0x0b6dfb9c0f956447},\r\n      {0x8edf98b59a373fec, 0x4724bd4189bd5eac},\r\n      {0xb2977ee300c50fe7, 0x58edec91ec2cb657},\r\n      {0xdf3d5e9bc0f653e1, 0x2f2967b66737e3ed},\r\n      {0x8b865b215899f46c, 0xbd79e0d20082ee74},\r\n      {0xae67f1e9aec07187, 0xecd8590680a3aa11},\r\n      {0xda01ee641a708de9, 0xe80e6f4820cc9495},\r\n      {0x884134fe908658b2, 0x3109058d147fdcdd},\r\n      {0xaa51823e34a7eede, 0xbd4b46f0599fd415},\r\n      {0xd4e5e2cdc1d1ea96, 0x6c9e18ac7007c91a},\r\n      {0x850fadc09923329e, 0x03e2cf6bc604ddb0},\r\n      {0xa6539930bf6bff45, 0x84db8346b786151c},\r\n      {0xcfe87f7cef46ff16, 0xe612641865679a63},\r\n      {0x81f14fae158c5f6e, 0x4fcb7e8f3f60c07e},\r\n      {0xa26da3999aef7749, 0xe3be5e330f38f09d},\r\n      {0xcb090c8001ab551c, 0x5cadf5bfd3072cc5},\r\n      {0xfdcb4fa002162a63, 0x73d9732fc7c8f7f6},\r\n      {0x9e9f11c4014dda7e, 0x2867e7fddcdd9afa},\r\n      {0xc646d63501a1511d, 0xb281e1fd541501b8},\r\n      {0xf7d88bc24209a565, 0x1f225a7ca91a4226},\r\n      {0x9ae757596946075f, 0x3375788de9b06958},\r\n      {0xc1a12d2fc3978937, 0x0052d6b1641c83ae},\r\n      {0xf209787bb47d6b84, 0xc0678c5dbd23a49a},\r\n      {0x9745eb4d50ce6332, 0xf840b7ba963646e0},\r\n      {0xbd176620a501fbff, 0xb650e5a93bc3d898},\r\n      {0xec5d3fa8ce427aff, 0xa3e51f138ab4cebe},\r\n      {0x93ba47c980e98cdf, 0xc66f336c36b10137},\r\n      {0xb8a8d9bbe123f017, 0xb80b0047445d4184},\r\n      {0xe6d3102ad96cec1d, 0xa60dc059157491e5},\r\n      {0x9043ea1ac7e41392, 0x87c89837ad68db2f},\r\n      {0xb454e4a179dd1877, 0x29babe4598c311fb},\r\n      {0xe16a1dc9d8545e94, 0xf4296dd6fef3d67a},\r\n      {0x8ce2529e2734bb1d, 0x1899e4a65f58660c},\r\n      {0xb01ae745b101e9e4, 0x5ec05dcff72e7f8f},\r\n      {0xdc21a1171d42645d, 0x76707543f4fa1f73},\r\n      {0x899504ae72497eba, 0x6a06494a791c53a8},\r\n      {0xabfa45da0edbde69, 0x0487db9d17636892},\r\n      {0xd6f8d7509292d603, 0x45a9d2845d3c42b6},\r\n      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},\r\n      {0xa7f26836f282b732, 0x8e6cac7768d7141e},\r\n      {0xd1ef0244af2364ff, 0x3207d795430cd926},\r\n      {0x8335616aed761f1f, 0x7f44e6bd49e807b8},\r\n      {0xa402b9c5a8d3a6e7, 0x5f16206c9c6209a6},\r\n      {0xcd036837130890a1, 0x36dba887c37a8c0f},\r\n      {0x802221226be55a64, 0xc2494954da2c9789},\r\n      {0xa02aa96b06deb0fd, 0xf2db9baa10b7bd6c},\r\n      {0xc83553c5c8965d3d, 0x6f92829494e5acc7},\r\n      {0xfa42a8b73abbf48c, 0xcb772339ba1f17f9},\r\n      {0x9c69a97284b578d7, 0xff2a760414536efb},\r\n      {0xc38413cf25e2d70d, 0xfef5138519684aba},\r\n      {0xf46518c2ef5b8cd1, 0x7eb258665fc25d69},\r\n      {0x98bf2f79d5993802, 0xef2f773ffbd97a61},\r\n      {0xbeeefb584aff8603, 0xaafb550ffacfd8fa},\r\n      {0xeeaaba2e5dbf6784, 0x95ba2a53f983cf38},\r\n      {0x952ab45cfa97a0b2, 0xdd945a747bf26183},\r\n      {0xba756174393d88df, 0x94f971119aeef9e4},\r\n      {0xe912b9d1478ceb17, 0x7a37cd5601aab85d},\r\n      {0x91abb422ccb812ee, 0xac62e055c10ab33a},\r\n      {0xb616a12b7fe617aa, 0x577b986b314d6009},\r\n      {0xe39c49765fdf9d94, 0xed5a7e85fda0b80b},\r\n      {0x8e41ade9fbebc27d, 0x14588f13be847307},\r\n      {0xb1d219647ae6b31c, 0x596eb2d8ae258fc8},\r\n      {0xde469fbd99a05fe3, 0x6fca5f8ed9aef3bb},\r\n      {0x8aec23d680043bee, 0x25de7bb9480d5854},\r\n      {0xada72ccc20054ae9, 0xaf561aa79a10ae6a},\r\n      {0xd910f7ff28069da4, 0x1b2ba1518094da04},\r\n      {0x87aa9aff79042286, 0x90fb44d2f05d0842},\r\n      {0xa99541bf57452b28, 0x353a1607ac744a53},\r\n      {0xd3fa922f2d1675f2, 0x42889b8997915ce8},\r\n      {0x847c9b5d7c2e09b7, 0x69956135febada11},\r\n      {0xa59bc234db398c25, 0x43fab9837e699095},\r\n      {0xcf02b2c21207ef2e, 0x94f967e45e03f4bb},\r\n      {0x8161afb94b44f57d, 0x1d1be0eebac278f5},\r\n      {0xa1ba1ba79e1632dc, 0x6462d92a69731732},\r\n      {0xca28a291859bbf93, 0x7d7b8f7503cfdcfe},\r\n      {0xfcb2cb35e702af78, 0x5cda735244c3d43e},\r\n      {0x9defbf01b061adab, 0x3a0888136afa64a7},\r\n      {0xc56baec21c7a1916, 0x088aaa1845b8fdd0},\r\n      {0xf6c69a72a3989f5b, 0x8aad549e57273d45},\r\n      {0x9a3c2087a63f6399, 0x36ac54e2f678864b},\r\n      {0xc0cb28a98fcf3c7f, 0x84576a1bb416a7dd},\r\n      {0xf0fdf2d3f3c30b9f, 0x656d44a2a11c51d5},\r\n      {0x969eb7c47859e743, 0x9f644ae5a4b1b325},\r\n      {0xbc4665b596706114, 0x873d5d9f0dde1fee},\r\n      {0xeb57ff22fc0c7959, 0xa90cb506d155a7ea},\r\n      {0x9316ff75dd87cbd8, 0x09a7f12442d588f2},\r\n      {0xb7dcbf5354e9bece, 0x0c11ed6d538aeb2f},\r\n      {0xe5d3ef282a242e81, 0x8f1668c8a86da5fa},\r\n      {0x8fa475791a569d10, 0xf96e017d694487bc},\r\n      {0xb38d92d760ec4455, 0x37c981dcc395a9ac},\r\n      {0xe070f78d3927556a, 0x85bbe253f47b1417},\r\n      {0x8c469ab843b89562, 0x93956d7478ccec8e},\r\n      {0xaf58416654a6babb, 0x387ac8d1970027b2},\r\n      {0xdb2e51bfe9d0696a, 0x06997b05fcc0319e},\r\n      {0x88fcf317f22241e2, 0x441fece3bdf81f03},\r\n      {0xab3c2fddeeaad25a, 0xd527e81cad7626c3},\r\n      {0xd60b3bd56a5586f1, 0x8a71e223d8d3b074},\r\n      {0x85c7056562757456, 0xf6872d5667844e49},\r\n      {0xa738c6bebb12d16c, 0xb428f8ac016561db},\r\n      {0xd106f86e69d785c7, 0xe13336d701beba52},\r\n      {0x82a45b450226b39c, 0xecc0024661173473},\r\n      {0xa34d721642b06084, 0x27f002d7f95d0190},\r\n      {0xcc20ce9bd35c78a5, 0x31ec038df7b441f4},\r\n      {0xff290242c83396ce, 0x7e67047175a15271},\r\n      {0x9f79a169bd203e41, 0x0f0062c6e984d386},\r\n      {0xc75809c42c684dd1, 0x52c07b78a3e60868},\r\n      {0xf92e0c3537826145, 0xa7709a56ccdf8a82},\r\n      {0x9bbcc7a142b17ccb, 0x88a66076400bb691},\r\n      {0xc2abf989935ddbfe, 0x6acff893d00ea435},\r\n      {0xf356f7ebf83552fe, 0x0583f6b8c4124d43},\r\n      {0x98165af37b2153de, 0xc3727a337a8b704a},\r\n      {0xbe1bf1b059e9a8d6, 0x744f18c0592e4c5c},\r\n      {0xeda2ee1c7064130c, 0x1162def06f79df73},\r\n      {0x9485d4d1c63e8be7, 0x8addcb5645ac2ba8},\r\n      {0xb9a74a0637ce2ee1, 0x6d953e2bd7173692},\r\n      {0xe8111c87c5c1ba99, 0xc8fa8db6ccdd0437},\r\n      {0x910ab1d4db9914a0, 0x1d9c9892400a22a2},\r\n      {0xb54d5e4a127f59c8, 0x2503beb6d00cab4b},\r\n      {0xe2a0b5dc971f303a, 0x2e44ae64840fd61d},\r\n      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},\r\n      {0xb10d8e1456105dad, 0x7425a83e872c5f47},\r\n      {0xdd50f1996b947518, 0xd12f124e28f77719},\r\n      {0x8a5296ffe33cc92f, 0x82bd6b70d99aaa6f},\r\n      {0xace73cbfdc0bfb7b, 0x636cc64d1001550b},\r\n      {0xd8210befd30efa5a, 0x3c47f7e05401aa4e},\r\n      {0x8714a775e3e95c78, 0x65acfaec34810a71},\r\n      {0xa8d9d1535ce3b396, 0x7f1839a741a14d0d},\r\n      {0xd31045a8341ca07c, 0x1ede48111209a050},\r\n      {0x83ea2b892091e44d, 0x934aed0aab460432},\r\n      {0xa4e4b66b68b65d60, 0xf81da84d5617853f},\r\n      {0xce1de40642e3f4b9, 0x36251260ab9d668e},\r\n      {0x80d2ae83e9ce78f3, 0xc1d72b7c6b426019},\r\n      {0xa1075a24e4421730, 0xb24cf65b8612f81f},\r\n      {0xc94930ae1d529cfc, 0xdee033f26797b627},\r\n      {0xfb9b7cd9a4a7443c, 0x169840ef017da3b1},\r\n      {0x9d412e0806e88aa5, 0x8e1f289560ee864e},\r\n      {0xc491798a08a2ad4e, 0xf1a6f2bab92a27e2},\r\n      {0xf5b5d7ec8acb58a2, 0xae10af696774b1db},\r\n      {0x9991a6f3d6bf1765, 0xacca6da1e0a8ef29},\r\n      {0xbff610b0cc6edd3f, 0x17fd090a58d32af3},\r\n      {0xeff394dcff8a948e, 0xddfc4b4cef07f5b0},\r\n      {0x95f83d0a1fb69cd9, 0x4abdaf101564f98e},\r\n      {0xbb764c4ca7a4440f, 0x9d6d1ad41abe37f1},\r\n      {0xea53df5fd18d5513, 0x84c86189216dc5ed},\r\n      {0x92746b9be2f8552c, 0x32fd3cf5b4e49bb4},\r\n      {0xb7118682dbb66a77, 0x3fbc8c33221dc2a1},\r\n      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},\r\n      {0x8f05b1163ba6832d, 0x29cb4d87f2a7400e},\r\n      {0xb2c71d5bca9023f8, 0x743e20e9ef511012},\r\n      {0xdf78e4b2bd342cf6, 0x914da9246b255416},\r\n      {0x8bab8eefb6409c1a, 0x1ad089b6c2f7548e},\r\n      {0xae9672aba3d0c320, 0xa184ac2473b529b1},\r\n      {0xda3c0f568cc4f3e8, 0xc9e5d72d90a2741e},\r\n      {0x8865899617fb1871, 0x7e2fa67c7a658892},\r\n      {0xaa7eebfb9df9de8d, 0xddbb901b98feeab7},\r\n      {0xd51ea6fa85785631, 0x552a74227f3ea565},\r\n      {0x8533285c936b35de, 0xd53a88958f87275f},\r\n      {0xa67ff273b8460356, 0x8a892abaf368f137},\r\n      {0xd01fef10a657842c, 0x2d2b7569b0432d85},\r\n      {0x8213f56a67f6b29b, 0x9c3b29620e29fc73},\r\n      {0xa298f2c501f45f42, 0x8349f3ba91b47b8f},\r\n      {0xcb3f2f7642717713, 0x241c70a936219a73},\r\n      {0xfe0efb53d30dd4d7, 0xed238cd383aa0110},\r\n      {0x9ec95d1463e8a506, 0xf4363804324a40aa},\r\n      {0xc67bb4597ce2ce48, 0xb143c6053edcd0d5},\r\n      {0xf81aa16fdc1b81da, 0xdd94b7868e94050a},\r\n      {0x9b10a4e5e9913128, 0xca7cf2b4191c8326},\r\n      {0xc1d4ce1f63f57d72, 0xfd1c2f611f63a3f0},\r\n      {0xf24a01a73cf2dccf, 0xbc633b39673c8cec},\r\n      {0x976e41088617ca01, 0xd5be0503e085d813},\r\n      {0xbd49d14aa79dbc82, 0x4b2d8644d8a74e18},\r\n      {0xec9c459d51852ba2, 0xddf8e7d60ed1219e},\r\n      {0x93e1ab8252f33b45, 0xcabb90e5c942b503},\r\n      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},\r\n      {0xe7109bfba19c0c9d, 0x0cc512670a783ad4},\r\n      {0x906a617d450187e2, 0x27fb2b80668b24c5},\r\n      {0xb484f9dc9641e9da, 0xb1f9f660802dedf6},\r\n      {0xe1a63853bbd26451, 0x5e7873f8a0396973},\r\n      {0x8d07e33455637eb2, 0xdb0b487b6423e1e8},\r\n      {0xb049dc016abc5e5f, 0x91ce1a9a3d2cda62},\r\n      {0xdc5c5301c56b75f7, 0x7641a140cc7810fb},\r\n      {0x89b9b3e11b6329ba, 0xa9e904c87fcb0a9d},\r\n      {0xac2820d9623bf429, 0x546345fa9fbdcd44},\r\n      {0xd732290fbacaf133, 0xa97c177947ad4095},\r\n      {0x867f59a9d4bed6c0, 0x49ed8eabcccc485d},\r\n      {0xa81f301449ee8c70, 0x5c68f256bfff5a74},\r\n      {0xd226fc195c6a2f8c, 0x73832eec6fff3111},\r\n      {0x83585d8fd9c25db7, 0xc831fd53c5ff7eab},\r\n      {0xa42e74f3d032f525, 0xba3e7ca8b77f5e55},\r\n      {0xcd3a1230c43fb26f, 0x28ce1bd2e55f35eb},\r\n      {0x80444b5e7aa7cf85, 0x7980d163cf5b81b3},\r\n      {0xa0555e361951c366, 0xd7e105bcc332621f},\r\n      {0xc86ab5c39fa63440, 0x8dd9472bf3fefaa7},\r\n      {0xfa856334878fc150, 0xb14f98f6f0feb951},\r\n      {0x9c935e00d4b9d8d2, 0x6ed1bf9a569f33d3},\r\n      {0xc3b8358109e84f07, 0x0a862f80ec4700c8},\r\n      {0xf4a642e14c6262c8, 0xcd27bb612758c0fa},\r\n      {0x98e7e9cccfbd7dbd, 0x8038d51cb897789c},\r\n      {0xbf21e44003acdd2c, 0xe0470a63e6bd56c3},\r\n      {0xeeea5d5004981478, 0x1858ccfce06cac74},\r\n      {0x95527a5202df0ccb, 0x0f37801e0c43ebc8},\r\n      {0xbaa718e68396cffd, 0xd30560258f54e6ba},\r\n      {0xe950df20247c83fd, 0x47c6b82ef32a2069},\r\n      {0x91d28b7416cdd27e, 0x4cdc331d57fa5441},\r\n      {0xb6472e511c81471d, 0xe0133fe4adf8e952},\r\n      {0xe3d8f9e563a198e5, 0x58180fddd97723a6},\r\n      {0x8e679c2f5e44ff8f, 0x570f09eaa7ea7648},\r\n      {0xb201833b35d63f73, 0x2cd2cc6551e513da},\r\n      {0xde81e40a034bcf4f, 0xf8077f7ea65e58d1},\r\n      {0x8b112e86420f6191, 0xfb04afaf27faf782},\r\n      {0xadd57a27d29339f6, 0x79c5db9af1f9b563},\r\n      {0xd94ad8b1c7380874, 0x18375281ae7822bc},\r\n      {0x87cec76f1c830548, 0x8f2293910d0b15b5},\r\n      {0xa9c2794ae3a3c69a, 0xb2eb3875504ddb22},\r\n      {0xd433179d9c8cb841, 0x5fa60692a46151eb},\r\n      {0x849feec281d7f328, 0xdbc7c41ba6bcd333},\r\n      {0xa5c7ea73224deff3, 0x12b9b522906c0800},\r\n      {0xcf39e50feae16bef, 0xd768226b34870a00},\r\n      {0x81842f29f2cce375, 0xe6a1158300d46640},\r\n      {0xa1e53af46f801c53, 0x60495ae3c1097fd0},\r\n      {0xca5e89b18b602368, 0x385bb19cb14bdfc4},\r\n      {0xfcf62c1dee382c42, 0x46729e03dd9ed7b5},\r\n      {0x9e19db92b4e31ba9, 0x6c07a2c26a8346d1},\r\n      {0xc5a05277621be293, 0xc7098b7305241885},\r\n      { 0xf70867153aa2db38,\r\n        0xb8cbee4fc66d1ea7 }\r\n#else\r\n      {0xff77b1fcbebcdc4f, 0x25e8e89c13bb0f7b},\r\n      {0xce5d73ff402d98e3, 0xfb0a3d212dc81290},\r\n      {0xa6b34ad8c9dfc06f, 0xf42faa48c0ea481f},\r\n      {0x86a8d39ef77164bc, 0xae5dff9c02033198},\r\n      {0xd98ddaee19068c76, 0x3badd624dd9b0958},\r\n      {0xafbd2350644eeacf, 0xe5d1929ef90898fb},\r\n      {0x8df5efabc5979c8f, 0xca8d3ffa1ef463c2},\r\n      {0xe55990879ddcaabd, 0xcc420a6a101d0516},\r\n      {0xb94470938fa89bce, 0xf808e40e8d5b3e6a},\r\n      {0x95a8637627989aad, 0xdde7001379a44aa9},\r\n      {0xf1c90080baf72cb1, 0x5324c68b12dd6339},\r\n      {0xc350000000000000, 0x0000000000000000},\r\n      {0x9dc5ada82b70b59d, 0xf020000000000000},\r\n      {0xfee50b7025c36a08, 0x02f236d04753d5b4},\r\n      {0xcde6fd5e09abcf26, 0xed4c0226b55e6f86},\r\n      {0xa6539930bf6bff45, 0x84db8346b786151c},\r\n      {0x865b86925b9bc5c2, 0x0b8a2392ba45a9b2},\r\n      {0xd910f7ff28069da4, 0x1b2ba1518094da04},\r\n      {0xaf58416654a6babb, 0x387ac8d1970027b2},\r\n      {0x8da471a9de737e24, 0x5ceaecfed289e5d2},\r\n      {0xe4d5e82392a40515, 0x0fabaf3feaa5334a},\r\n      {0xb8da1662e7b00a17, 0x3d6a751f3b936243},\r\n      { 0x95527a5202df0ccb,\r\n        0x0f37801e0c43ebc8 }\r\n#endif\r\n    };\r\n\r\n#if FMT_USE_FULL_CACHE_DRAGONBOX\r\n    return pow10_significands[k - float_info<double>::min_k];\r\n#else\r\n    static constexpr const uint64_t powers_of_5_64[] = {\r\n        0x0000000000000001, 0x0000000000000005, 0x0000000000000019,\r\n        0x000000000000007d, 0x0000000000000271, 0x0000000000000c35,\r\n        0x0000000000003d09, 0x000000000001312d, 0x000000000005f5e1,\r\n        0x00000000001dcd65, 0x00000000009502f9, 0x0000000002e90edd,\r\n        0x000000000e8d4a51, 0x0000000048c27395, 0x000000016bcc41e9,\r\n        0x000000071afd498d, 0x0000002386f26fc1, 0x000000b1a2bc2ec5,\r\n        0x000003782dace9d9, 0x00001158e460913d, 0x000056bc75e2d631,\r\n        0x0001b1ae4d6e2ef5, 0x000878678326eac9, 0x002a5a058fc295ed,\r\n        0x00d3c21bcecceda1, 0x0422ca8b0a00a425, 0x14adf4b7320334b9};\r\n\r\n    static constexpr const uint32_t pow10_recovery_errors[] = {\r\n        0x50001400, 0x54044100, 0x54014555, 0x55954415, 0x54115555, 0x00000001,\r\n        0x50000000, 0x00104000, 0x54010004, 0x05004001, 0x55555544, 0x41545555,\r\n        0x54040551, 0x15445545, 0x51555514, 0x10000015, 0x00101100, 0x01100015,\r\n        0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x04450514, 0x45414110,\r\n        0x55555145, 0x50544050, 0x15040155, 0x11054140, 0x50111514, 0x11451454,\r\n        0x00400541, 0x00000000, 0x55555450, 0x10056551, 0x10054011, 0x55551014,\r\n        0x69514555, 0x05151109, 0x00155555};\r\n\r\n    static const int compression_ratio = 27;\r\n\r\n    // Compute base index.\r\n    int cache_index = (k - float_info<double>::min_k) / compression_ratio;\r\n    int kb = cache_index * compression_ratio + float_info<double>::min_k;\r\n    int offset = k - kb;\r\n\r\n    // Get base cache.\r\n    uint128_wrapper base_cache = pow10_significands[cache_index];\r\n    if (offset == 0) return base_cache;\r\n\r\n    // Compute the required amount of bit-shift.\r\n    int alpha = floor_log2_pow10(kb + offset) - floor_log2_pow10(kb) - offset;\r\n    FMT_ASSERT(alpha > 0 && alpha < 64, \"shifting error detected\");\r\n\r\n    // Try to recover the real cache.\r\n    uint64_t pow5 = powers_of_5_64[offset];\r\n    uint128_wrapper recovered_cache = umul128(base_cache.high(), pow5);\r\n    uint128_wrapper middle_low =\r\n        umul128(base_cache.low() - (kb < 0 ? 1u : 0u), pow5);\r\n\r\n    recovered_cache += middle_low.high();\r\n\r\n    uint64_t high_to_middle = recovered_cache.high() << (64 - alpha);\r\n    uint64_t middle_to_low = recovered_cache.low() << (64 - alpha);\r\n\r\n    recovered_cache =\r\n        uint128_wrapper{(recovered_cache.low() >> alpha) | high_to_middle,\r\n                        ((middle_low.low() >> alpha) | middle_to_low)};\r\n\r\n    if (kb < 0) recovered_cache += 1;\r\n\r\n    // Get error.\r\n    int error_idx = (k - float_info<double>::min_k) / 16;\r\n    uint32_t error = (pow10_recovery_errors[error_idx] >>\r\n                      ((k - float_info<double>::min_k) % 16) * 2) &\r\n                     0x3;\r\n\r\n    // Add the error back.\r\n    FMT_ASSERT(recovered_cache.low() + error >= recovered_cache.low(), \"\");\r\n    return {recovered_cache.high(), recovered_cache.low() + error};\r\n#endif\r\n  }\r\n\r\n  static carrier_uint compute_mul(carrier_uint u,\r\n                                  const cache_entry_type& cache) FMT_NOEXCEPT {\r\n    return umul192_upper64(u, cache);\r\n  }\r\n\r\n  static uint32_t compute_delta(cache_entry_type const& cache,\r\n                                int beta_minus_1) FMT_NOEXCEPT {\r\n    return static_cast<uint32_t>(cache.high() >> (64 - 1 - beta_minus_1));\r\n  }\r\n\r\n  static bool compute_mul_parity(carrier_uint two_f,\r\n                                 const cache_entry_type& cache,\r\n                                 int beta_minus_1) FMT_NOEXCEPT {\r\n    FMT_ASSERT(beta_minus_1 >= 1, \"\");\r\n    FMT_ASSERT(beta_minus_1 < 64, \"\");\r\n\r\n    return ((umul192_middle64(two_f, cache) >> (64 - beta_minus_1)) & 1) != 0;\r\n  }\r\n\r\n  static carrier_uint compute_left_endpoint_for_shorter_interval_case(\r\n      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {\r\n    return (cache.high() -\r\n            (cache.high() >> (float_info<double>::significand_bits + 2))) >>\r\n           (64 - float_info<double>::significand_bits - 1 - beta_minus_1);\r\n  }\r\n\r\n  static carrier_uint compute_right_endpoint_for_shorter_interval_case(\r\n      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {\r\n    return (cache.high() +\r\n            (cache.high() >> (float_info<double>::significand_bits + 1))) >>\r\n           (64 - float_info<double>::significand_bits - 1 - beta_minus_1);\r\n  }\r\n\r\n  static carrier_uint compute_round_up_for_shorter_interval_case(\r\n      const cache_entry_type& cache, int beta_minus_1) FMT_NOEXCEPT {\r\n    return ((cache.high() >>\r\n             (64 - float_info<double>::significand_bits - 2 - beta_minus_1)) +\r\n            1) /\r\n           2;\r\n  }\r\n};\r\n\r\n// Various integer checks\r\ntemplate <class T>\r\nbool is_left_endpoint_integer_shorter_interval(int exponent) FMT_NOEXCEPT {\r\n  return exponent >=\r\n             float_info<\r\n                 T>::case_shorter_interval_left_endpoint_lower_threshold &&\r\n         exponent <=\r\n             float_info<T>::case_shorter_interval_left_endpoint_upper_threshold;\r\n}\r\ntemplate <class T>\r\nbool is_endpoint_integer(typename float_info<T>::carrier_uint two_f,\r\n                         int exponent, int minus_k) FMT_NOEXCEPT {\r\n  if (exponent < float_info<T>::case_fc_pm_half_lower_threshold) return false;\r\n  // For k >= 0.\r\n  if (exponent <= float_info<T>::case_fc_pm_half_upper_threshold) return true;\r\n  // For k < 0.\r\n  if (exponent > float_info<T>::divisibility_check_by_5_threshold) return false;\r\n  return divisible_by_power_of_5(two_f, minus_k);\r\n}\r\n\r\ntemplate <class T>\r\nbool is_center_integer(typename float_info<T>::carrier_uint two_f, int exponent,\r\n                       int minus_k) FMT_NOEXCEPT {\r\n  // Exponent for 5 is negative.\r\n  if (exponent > float_info<T>::divisibility_check_by_5_threshold) return false;\r\n  if (exponent > float_info<T>::case_fc_upper_threshold)\r\n    return divisible_by_power_of_5(two_f, minus_k);\r\n  // Both exponents are nonnegative.\r\n  if (exponent >= float_info<T>::case_fc_lower_threshold) return true;\r\n  // Exponent for 2 is negative.\r\n  return divisible_by_power_of_2(two_f, minus_k - exponent + 1);\r\n}\r\n\r\n// Remove trailing zeros from n and return the number of zeros removed (float)\r\nFMT_INLINE int remove_trailing_zeros(uint32_t& n) FMT_NOEXCEPT {\r\n#ifdef FMT_BUILTIN_CTZ\r\n  int t = FMT_BUILTIN_CTZ(n);\r\n#else\r\n  int t = ctz(n);\r\n#endif\r\n  if (t > float_info<float>::max_trailing_zeros)\r\n    t = float_info<float>::max_trailing_zeros;\r\n\r\n  const uint32_t mod_inv1 = 0xcccccccd;\r\n  const uint32_t max_quotient1 = 0x33333333;\r\n  const uint32_t mod_inv2 = 0xc28f5c29;\r\n  const uint32_t max_quotient2 = 0x0a3d70a3;\r\n\r\n  int s = 0;\r\n  for (; s < t - 1; s += 2) {\r\n    if (n * mod_inv2 > max_quotient2) break;\r\n    n *= mod_inv2;\r\n  }\r\n  if (s < t && n * mod_inv1 <= max_quotient1) {\r\n    n *= mod_inv1;\r\n    ++s;\r\n  }\r\n  n >>= s;\r\n  return s;\r\n}\r\n\r\n// Removes trailing zeros and returns the number of zeros removed (double)\r\nFMT_INLINE int remove_trailing_zeros(uint64_t& n) FMT_NOEXCEPT {\r\n#ifdef FMT_BUILTIN_CTZLL\r\n  int t = FMT_BUILTIN_CTZLL(n);\r\n#else\r\n  int t = ctzll(n);\r\n#endif\r\n  if (t > float_info<double>::max_trailing_zeros)\r\n    t = float_info<double>::max_trailing_zeros;\r\n  // Divide by 10^8 and reduce to 32-bits\r\n  // Since ret_value.significand <= (2^64 - 1) / 1000 < 10^17,\r\n  // both of the quotient and the r should fit in 32-bits\r\n\r\n  const uint32_t mod_inv1 = 0xcccccccd;\r\n  const uint32_t max_quotient1 = 0x33333333;\r\n  const uint64_t mod_inv8 = 0xc767074b22e90e21;\r\n  const uint64_t max_quotient8 = 0x00002af31dc46118;\r\n\r\n  // If the number is divisible by 1'0000'0000, work with the quotient\r\n  if (t >= 8) {\r\n    auto quotient_candidate = n * mod_inv8;\r\n\r\n    if (quotient_candidate <= max_quotient8) {\r\n      auto quotient = static_cast<uint32_t>(quotient_candidate >> 8);\r\n\r\n      int s = 8;\r\n      for (; s < t; ++s) {\r\n        if (quotient * mod_inv1 > max_quotient1) break;\r\n        quotient *= mod_inv1;\r\n      }\r\n      quotient >>= (s - 8);\r\n      n = quotient;\r\n      return s;\r\n    }\r\n  }\r\n\r\n  // Otherwise, work with the remainder\r\n  auto quotient = static_cast<uint32_t>(n / 100000000);\r\n  auto remainder = static_cast<uint32_t>(n - 100000000 * quotient);\r\n\r\n  if (t == 0 || remainder * mod_inv1 > max_quotient1) {\r\n    return 0;\r\n  }\r\n  remainder *= mod_inv1;\r\n\r\n  if (t == 1 || remainder * mod_inv1 > max_quotient1) {\r\n    n = (remainder >> 1) + quotient * 10000000ull;\r\n    return 1;\r\n  }\r\n  remainder *= mod_inv1;\r\n\r\n  if (t == 2 || remainder * mod_inv1 > max_quotient1) {\r\n    n = (remainder >> 2) + quotient * 1000000ull;\r\n    return 2;\r\n  }\r\n  remainder *= mod_inv1;\r\n\r\n  if (t == 3 || remainder * mod_inv1 > max_quotient1) {\r\n    n = (remainder >> 3) + quotient * 100000ull;\r\n    return 3;\r\n  }\r\n  remainder *= mod_inv1;\r\n\r\n  if (t == 4 || remainder * mod_inv1 > max_quotient1) {\r\n    n = (remainder >> 4) + quotient * 10000ull;\r\n    return 4;\r\n  }\r\n  remainder *= mod_inv1;\r\n\r\n  if (t == 5 || remainder * mod_inv1 > max_quotient1) {\r\n    n = (remainder >> 5) + quotient * 1000ull;\r\n    return 5;\r\n  }\r\n  remainder *= mod_inv1;\r\n\r\n  if (t == 6 || remainder * mod_inv1 > max_quotient1) {\r\n    n = (remainder >> 6) + quotient * 100ull;\r\n    return 6;\r\n  }\r\n  remainder *= mod_inv1;\r\n\r\n  n = (remainder >> 7) + quotient * 10ull;\r\n  return 7;\r\n}\r\n\r\n// The main algorithm for shorter interval case\r\ntemplate <class T>\r\nFMT_INLINE decimal_fp<T> shorter_interval_case(int exponent) FMT_NOEXCEPT {\r\n  decimal_fp<T> ret_value;\r\n  // Compute k and beta\r\n  const int minus_k = floor_log10_pow2_minus_log10_4_over_3(exponent);\r\n  const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);\r\n\r\n  // Compute xi and zi\r\n  using cache_entry_type = typename cache_accessor<T>::cache_entry_type;\r\n  const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);\r\n\r\n  auto xi = cache_accessor<T>::compute_left_endpoint_for_shorter_interval_case(\r\n      cache, beta_minus_1);\r\n  auto zi = cache_accessor<T>::compute_right_endpoint_for_shorter_interval_case(\r\n      cache, beta_minus_1);\r\n\r\n  // If the left endpoint is not an integer, increase it\r\n  if (!is_left_endpoint_integer_shorter_interval<T>(exponent)) ++xi;\r\n\r\n  // Try bigger divisor\r\n  ret_value.significand = zi / 10;\r\n\r\n  // If succeed, remove trailing zeros if necessary and return\r\n  if (ret_value.significand * 10 >= xi) {\r\n    ret_value.exponent = minus_k + 1;\r\n    ret_value.exponent += remove_trailing_zeros(ret_value.significand);\r\n    return ret_value;\r\n  }\r\n\r\n  // Otherwise, compute the round-up of y\r\n  ret_value.significand =\r\n      cache_accessor<T>::compute_round_up_for_shorter_interval_case(\r\n          cache, beta_minus_1);\r\n  ret_value.exponent = minus_k;\r\n\r\n  // When tie occurs, choose one of them according to the rule\r\n  if (exponent >= float_info<T>::shorter_interval_tie_lower_threshold &&\r\n      exponent <= float_info<T>::shorter_interval_tie_upper_threshold) {\r\n    ret_value.significand = ret_value.significand % 2 == 0\r\n                                ? ret_value.significand\r\n                                : ret_value.significand - 1;\r\n  } else if (ret_value.significand < xi) {\r\n    ++ret_value.significand;\r\n  }\r\n  return ret_value;\r\n}\r\n\r\ntemplate <typename T> decimal_fp<T> to_decimal(T x) FMT_NOEXCEPT {\r\n  // Step 1: integer promotion & Schubfach multiplier calculation.\r\n\r\n  using carrier_uint = typename float_info<T>::carrier_uint;\r\n  using cache_entry_type = typename cache_accessor<T>::cache_entry_type;\r\n  auto br = bit_cast<carrier_uint>(x);\r\n\r\n  // Extract significand bits and exponent bits.\r\n  const carrier_uint significand_mask =\r\n      (static_cast<carrier_uint>(1) << float_info<T>::significand_bits) - 1;\r\n  carrier_uint significand = (br & significand_mask);\r\n  int exponent = static_cast<int>((br & exponent_mask<T>()) >>\r\n                                  float_info<T>::significand_bits);\r\n\r\n  if (exponent != 0) {  // Check if normal.\r\n    exponent += float_info<T>::exponent_bias - float_info<T>::significand_bits;\r\n\r\n    // Shorter interval case; proceed like Schubfach.\r\n    if (significand == 0) return shorter_interval_case<T>(exponent);\r\n\r\n    significand |=\r\n        (static_cast<carrier_uint>(1) << float_info<T>::significand_bits);\r\n  } else {\r\n    // Subnormal case; the interval is always regular.\r\n    if (significand == 0) return {0, 0};\r\n    exponent = float_info<T>::min_exponent - float_info<T>::significand_bits;\r\n  }\r\n\r\n  const bool include_left_endpoint = (significand % 2 == 0);\r\n  const bool include_right_endpoint = include_left_endpoint;\r\n\r\n  // Compute k and beta.\r\n  const int minus_k = floor_log10_pow2(exponent) - float_info<T>::kappa;\r\n  const cache_entry_type cache = cache_accessor<T>::get_cached_power(-minus_k);\r\n  const int beta_minus_1 = exponent + floor_log2_pow10(-minus_k);\r\n\r\n  // Compute zi and deltai\r\n  // 10^kappa <= deltai < 10^(kappa + 1)\r\n  const uint32_t deltai = cache_accessor<T>::compute_delta(cache, beta_minus_1);\r\n  const carrier_uint two_fc = significand << 1;\r\n  const carrier_uint two_fr = two_fc | 1;\r\n  const carrier_uint zi =\r\n      cache_accessor<T>::compute_mul(two_fr << beta_minus_1, cache);\r\n\r\n  // Step 2: Try larger divisor; remove trailing zeros if necessary\r\n\r\n  // Using an upper bound on zi, we might be able to optimize the division\r\n  // better than the compiler; we are computing zi / big_divisor here\r\n  decimal_fp<T> ret_value;\r\n  ret_value.significand = divide_by_10_to_kappa_plus_1(zi);\r\n  uint32_t r = static_cast<uint32_t>(zi - float_info<T>::big_divisor *\r\n                                              ret_value.significand);\r\n\r\n  if (r > deltai) {\r\n    goto small_divisor_case_label;\r\n  } else if (r < deltai) {\r\n    // Exclude the right endpoint if necessary\r\n    if (r == 0 && !include_right_endpoint &&\r\n        is_endpoint_integer<T>(two_fr, exponent, minus_k)) {\r\n      --ret_value.significand;\r\n      r = float_info<T>::big_divisor;\r\n      goto small_divisor_case_label;\r\n    }\r\n  } else {\r\n    // r == deltai; compare fractional parts\r\n    // Check conditions in the order different from the paper\r\n    // to take advantage of short-circuiting\r\n    const carrier_uint two_fl = two_fc - 1;\r\n    if ((!include_left_endpoint ||\r\n         !is_endpoint_integer<T>(two_fl, exponent, minus_k)) &&\r\n        !cache_accessor<T>::compute_mul_parity(two_fl, cache, beta_minus_1)) {\r\n      goto small_divisor_case_label;\r\n    }\r\n  }\r\n  ret_value.exponent = minus_k + float_info<T>::kappa + 1;\r\n\r\n  // We may need to remove trailing zeros\r\n  ret_value.exponent += remove_trailing_zeros(ret_value.significand);\r\n  return ret_value;\r\n\r\n  // Step 3: Find the significand with the smaller divisor\r\n\r\nsmall_divisor_case_label:\r\n  ret_value.significand *= 10;\r\n  ret_value.exponent = minus_k + float_info<T>::kappa;\r\n\r\n  const uint32_t mask = (1u << float_info<T>::kappa) - 1;\r\n  auto dist = r - (deltai / 2) + (float_info<T>::small_divisor / 2);\r\n\r\n  // Is dist divisible by 2^kappa?\r\n  if ((dist & mask) == 0) {\r\n    const bool approx_y_parity =\r\n        ((dist ^ (float_info<T>::small_divisor / 2)) & 1) != 0;\r\n    dist >>= float_info<T>::kappa;\r\n\r\n    // Is dist divisible by 5^kappa?\r\n    if (check_divisibility_and_divide_by_pow5<float_info<T>::kappa>(dist)) {\r\n      ret_value.significand += dist;\r\n\r\n      // Check z^(f) >= epsilon^(f)\r\n      // We have either yi == zi - epsiloni or yi == (zi - epsiloni) - 1,\r\n      // where yi == zi - epsiloni if and only if z^(f) >= epsilon^(f)\r\n      // Since there are only 2 possibilities, we only need to care about the\r\n      // parity. Also, zi and r should have the same parity since the divisor\r\n      // is an even number\r\n      if (cache_accessor<T>::compute_mul_parity(two_fc, cache, beta_minus_1) !=\r\n          approx_y_parity) {\r\n        --ret_value.significand;\r\n      } else {\r\n        // If z^(f) >= epsilon^(f), we might have a tie\r\n        // when z^(f) == epsilon^(f), or equivalently, when y is an integer\r\n        if (is_center_integer<T>(two_fc, exponent, minus_k)) {\r\n          ret_value.significand = ret_value.significand % 2 == 0\r\n                                      ? ret_value.significand\r\n                                      : ret_value.significand - 1;\r\n        }\r\n      }\r\n    }\r\n    // Is dist not divisible by 5^kappa?\r\n    else {\r\n      ret_value.significand += dist;\r\n    }\r\n  }\r\n  // Is dist not divisible by 2^kappa?\r\n  else {\r\n    // Since we know dist is small, we might be able to optimize the division\r\n    // better than the compiler; we are computing dist / small_divisor here\r\n    ret_value.significand +=\r\n        small_division_by_pow10<float_info<T>::kappa>(dist);\r\n  }\r\n  return ret_value;\r\n}\r\n}  // namespace dragonbox\r\n\r\n// Formats a floating-point number using a variation of the Fixed-Precision\r\n// Positive Floating-Point Printout ((FPP)^2) algorithm by Steele & White:\r\n// https://fmt.dev/papers/p372-steele.pdf.\r\nFMT_CONSTEXPR20 inline void format_dragon(fp value, bool is_predecessor_closer,\r\n                                          int num_digits, buffer<char>& buf,\r\n                                          int& exp10) {\r\n  bigint numerator;    // 2 * R in (FPP)^2.\r\n  bigint denominator;  // 2 * S in (FPP)^2.\r\n  // lower and upper are differences between value and corresponding boundaries.\r\n  bigint lower;             // (M^- in (FPP)^2).\r\n  bigint upper_store;       // upper's value if different from lower.\r\n  bigint* upper = nullptr;  // (M^+ in (FPP)^2).\r\n  // Shift numerator and denominator by an extra bit or two (if lower boundary\r\n  // is closer) to make lower and upper integers. This eliminates multiplication\r\n  // by 2 during later computations.\r\n  int shift = is_predecessor_closer ? 2 : 1;\r\n  uint64_t significand = value.f << shift;\r\n  if (value.e >= 0) {\r\n    numerator.assign(significand);\r\n    numerator <<= value.e;\r\n    lower.assign(1);\r\n    lower <<= value.e;\r\n    if (shift != 1) {\r\n      upper_store.assign(1);\r\n      upper_store <<= value.e + 1;\r\n      upper = &upper_store;\r\n    }\r\n    denominator.assign_pow10(exp10);\r\n    denominator <<= shift;\r\n  } else if (exp10 < 0) {\r\n    numerator.assign_pow10(-exp10);\r\n    lower.assign(numerator);\r\n    if (shift != 1) {\r\n      upper_store.assign(numerator);\r\n      upper_store <<= 1;\r\n      upper = &upper_store;\r\n    }\r\n    numerator *= significand;\r\n    denominator.assign(1);\r\n    denominator <<= shift - value.e;\r\n  } else {\r\n    numerator.assign(significand);\r\n    denominator.assign_pow10(exp10);\r\n    denominator <<= shift - value.e;\r\n    lower.assign(1);\r\n    if (shift != 1) {\r\n      upper_store.assign(1ULL << 1);\r\n      upper = &upper_store;\r\n    }\r\n  }\r\n  // Invariant: value == (numerator / denominator) * pow(10, exp10).\r\n  if (num_digits < 0) {\r\n    // Generate the shortest representation.\r\n    if (!upper) upper = &lower;\r\n    bool even = (value.f & 1) == 0;\r\n    num_digits = 0;\r\n    char* data = buf.data();\r\n    for (;;) {\r\n      int digit = numerator.divmod_assign(denominator);\r\n      bool low = compare(numerator, lower) - even < 0;  // numerator <[=] lower.\r\n      // numerator + upper >[=] pow10:\r\n      bool high = add_compare(numerator, *upper, denominator) + even > 0;\r\n      data[num_digits++] = static_cast<char>('0' + digit);\r\n      if (low || high) {\r\n        if (!low) {\r\n          ++data[num_digits - 1];\r\n        } else if (high) {\r\n          int result = add_compare(numerator, numerator, denominator);\r\n          // Round half to even.\r\n          if (result > 0 || (result == 0 && (digit % 2) != 0))\r\n            ++data[num_digits - 1];\r\n        }\r\n        buf.try_resize(to_unsigned(num_digits));\r\n        exp10 -= num_digits - 1;\r\n        return;\r\n      }\r\n      numerator *= 10;\r\n      lower *= 10;\r\n      if (upper != &lower) *upper *= 10;\r\n    }\r\n  }\r\n  // Generate the given number of digits.\r\n  exp10 -= num_digits - 1;\r\n  if (num_digits == 0) {\r\n    denominator *= 10;\r\n    auto digit = add_compare(numerator, numerator, denominator) > 0 ? '1' : '0';\r\n    buf.push_back(digit);\r\n    return;\r\n  }\r\n  buf.try_resize(to_unsigned(num_digits));\r\n  for (int i = 0; i < num_digits - 1; ++i) {\r\n    int digit = numerator.divmod_assign(denominator);\r\n    buf[i] = static_cast<char>('0' + digit);\r\n    numerator *= 10;\r\n  }\r\n  int digit = numerator.divmod_assign(denominator);\r\n  auto result = add_compare(numerator, numerator, denominator);\r\n  if (result > 0 || (result == 0 && (digit % 2) != 0)) {\r\n    if (digit == 9) {\r\n      const auto overflow = '0' + 10;\r\n      buf[num_digits - 1] = overflow;\r\n      // Propagate the carry.\r\n      for (int i = num_digits - 1; i > 0 && buf[i] == overflow; --i) {\r\n        buf[i] = '0';\r\n        ++buf[i - 1];\r\n      }\r\n      if (buf[0] == overflow) {\r\n        buf[0] = '1';\r\n        ++exp10;\r\n      }\r\n      return;\r\n    }\r\n    ++digit;\r\n  }\r\n  buf[num_digits - 1] = static_cast<char>('0' + digit);\r\n}\r\n\r\ntemplate <typename Float>\r\nFMT_HEADER_ONLY_CONSTEXPR20 int format_float(Float value, int precision,\r\n                                             float_specs specs,\r\n                                             buffer<char>& buf) {\r\n  // float is passed as double to reduce the number of instantiations.\r\n  static_assert(!std::is_same<Float, float>::value, \"\");\r\n  FMT_ASSERT(value >= 0, \"value is negative\");\r\n\r\n  const bool fixed = specs.format == float_format::fixed;\r\n  if (value <= 0) {  // <= instead of == to silence a warning.\r\n    if (precision <= 0 || !fixed) {\r\n      buf.push_back('0');\r\n      return 0;\r\n    }\r\n    buf.try_resize(to_unsigned(precision));\r\n    fill_n(buf.data(), precision, '0');\r\n    return -precision;\r\n  }\r\n\r\n  if (specs.fallback) return snprintf_float(value, precision, specs, buf);\r\n\r\n  if (!is_constant_evaluated() && precision < 0) {\r\n    // Use Dragonbox for the shortest format.\r\n    if (specs.binary32) {\r\n      auto dec = dragonbox::to_decimal(static_cast<float>(value));\r\n      write<char>(buffer_appender<char>(buf), dec.significand);\r\n      return dec.exponent;\r\n    }\r\n    auto dec = dragonbox::to_decimal(static_cast<double>(value));\r\n    write<char>(buffer_appender<char>(buf), dec.significand);\r\n    return dec.exponent;\r\n  }\r\n\r\n  int exp = 0;\r\n  bool use_dragon = true;\r\n  if (is_fast_float<Float>()) {\r\n    // Use Grisu + Dragon4 for the given precision:\r\n    // https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf.\r\n    const int min_exp = -60;  // alpha in Grisu.\r\n    int cached_exp10 = 0;     // K in Grisu.\r\n    fp normalized = normalize(fp(value));\r\n    const auto cached_pow = get_cached_power(\r\n        min_exp - (normalized.e + fp::num_significand_bits), cached_exp10);\r\n    normalized = normalized * cached_pow;\r\n    gen_digits_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};\r\n    if (grisu_gen_digits(normalized, 1, exp, handler) != digits::error &&\r\n        !is_constant_evaluated()) {\r\n      exp += handler.exp10;\r\n      buf.try_resize(to_unsigned(handler.size));\r\n      use_dragon = false;\r\n    } else {\r\n      exp += handler.size - cached_exp10 - 1;\r\n      precision = handler.precision;\r\n    }\r\n  }\r\n  if (use_dragon) {\r\n    auto f = fp();\r\n    bool is_predecessor_closer =\r\n        specs.binary32 ? f.assign(static_cast<float>(value)) : f.assign(value);\r\n    // Limit precision to the maximum possible number of significant digits in\r\n    // an IEEE754 double because we don't need to generate zeros.\r\n    const int max_double_digits = 767;\r\n    if (precision > max_double_digits) precision = max_double_digits;\r\n    format_dragon(f, is_predecessor_closer, precision, buf, exp);\r\n  }\r\n  if (!fixed && !specs.showpoint) {\r\n    // Remove trailing zeros.\r\n    auto num_digits = buf.size();\r\n    while (num_digits > 0 && buf[num_digits - 1] == '0') {\r\n      --num_digits;\r\n      ++exp;\r\n    }\r\n    buf.try_resize(num_digits);\r\n  }\r\n  return exp;\r\n}\r\n\r\ntemplate <typename T>\r\nint snprintf_float(T value, int precision, float_specs specs,\r\n                   buffer<char>& buf) {\r\n  // Buffer capacity must be non-zero, otherwise MSVC's vsnprintf_s will fail.\r\n  FMT_ASSERT(buf.capacity() > buf.size(), \"empty buffer\");\r\n  static_assert(!std::is_same<T, float>::value, \"\");\r\n\r\n  // Subtract 1 to account for the difference in precision since we use %e for\r\n  // both general and exponent format.\r\n  if (specs.format == float_format::general ||\r\n      specs.format == float_format::exp)\r\n    precision = (precision >= 0 ? precision : 6) - 1;\r\n\r\n  // Build the format string.\r\n  enum { max_format_size = 7 };  // The longest format is \"%#.*Le\".\r\n  char format[max_format_size];\r\n  char* format_ptr = format;\r\n  *format_ptr++ = '%';\r\n  if (specs.showpoint && specs.format == float_format::hex) *format_ptr++ = '#';\r\n  if (precision >= 0) {\r\n    *format_ptr++ = '.';\r\n    *format_ptr++ = '*';\r\n  }\r\n  if (std::is_same<T, long double>()) *format_ptr++ = 'L';\r\n  *format_ptr++ = specs.format != float_format::hex\r\n                      ? (specs.format == float_format::fixed ? 'f' : 'e')\r\n                      : (specs.upper ? 'A' : 'a');\r\n  *format_ptr = '\\0';\r\n\r\n  // Format using snprintf.\r\n  auto offset = buf.size();\r\n  for (;;) {\r\n    auto begin = buf.data() + offset;\r\n    auto capacity = buf.capacity() - offset;\r\n#ifdef FMT_FUZZ\r\n    if (precision > 100000)\r\n      throw std::runtime_error(\r\n          \"fuzz mode - avoid large allocation inside snprintf\");\r\n#endif\r\n    // Suppress the warning about a nonliteral format string.\r\n    // Cannot use auto because of a bug in MinGW (#1532).\r\n    int (*snprintf_ptr)(char*, size_t, const char*, ...) = FMT_SNPRINTF;\r\n    int result = precision >= 0\r\n                     ? snprintf_ptr(begin, capacity, format, precision, value)\r\n                     : snprintf_ptr(begin, capacity, format, value);\r\n    if (result < 0) {\r\n      // The buffer will grow exponentially.\r\n      buf.try_reserve(buf.capacity() + 1);\r\n      continue;\r\n    }\r\n    auto size = to_unsigned(result);\r\n    // Size equal to capacity means that the last character was truncated.\r\n    if (size >= capacity) {\r\n      buf.try_reserve(size + offset + 1);  // Add 1 for the terminating '\\0'.\r\n      continue;\r\n    }\r\n    auto is_digit = [](char c) { return c >= '0' && c <= '9'; };\r\n    if (specs.format == float_format::fixed) {\r\n      if (precision == 0) {\r\n        buf.try_resize(size);\r\n        return 0;\r\n      }\r\n      // Find and remove the decimal point.\r\n      auto end = begin + size, p = end;\r\n      do {\r\n        --p;\r\n      } while (is_digit(*p));\r\n      int fraction_size = static_cast<int>(end - p - 1);\r\n      std::memmove(p, p + 1, to_unsigned(fraction_size));\r\n      buf.try_resize(size - 1);\r\n      return -fraction_size;\r\n    }\r\n    if (specs.format == float_format::hex) {\r\n      buf.try_resize(size + offset);\r\n      return 0;\r\n    }\r\n    // Find and parse the exponent.\r\n    auto end = begin + size, exp_pos = end;\r\n    do {\r\n      --exp_pos;\r\n    } while (*exp_pos != 'e');\r\n    char sign = exp_pos[1];\r\n    FMT_ASSERT(sign == '+' || sign == '-', \"\");\r\n    int exp = 0;\r\n    auto p = exp_pos + 2;  // Skip 'e' and sign.\r\n    do {\r\n      FMT_ASSERT(is_digit(*p), \"\");\r\n      exp = exp * 10 + (*p++ - '0');\r\n    } while (p != end);\r\n    if (sign == '-') exp = -exp;\r\n    int fraction_size = 0;\r\n    if (exp_pos != begin + 1) {\r\n      // Remove trailing zeros.\r\n      auto fraction_end = exp_pos - 1;\r\n      while (*fraction_end == '0') --fraction_end;\r\n      // Move the fractional part left to get rid of the decimal point.\r\n      fraction_size = static_cast<int>(fraction_end - begin - 1);\r\n      std::memmove(begin + 1, begin + 2, to_unsigned(fraction_size));\r\n    }\r\n    buf.try_resize(to_unsigned(fraction_size) + offset + 1);\r\n    return exp - fraction_size;\r\n  }\r\n}\r\n}  // namespace detail\r\n\r\ntemplate <> struct formatter<detail::bigint> {\r\n  FMT_CONSTEXPR format_parse_context::iterator parse(\r\n      format_parse_context& ctx) {\r\n    return ctx.begin();\r\n  }\r\n\r\n  format_context::iterator format(const detail::bigint& n,\r\n                                  format_context& ctx) {\r\n    auto out = ctx.out();\r\n    bool first = true;\r\n    for (auto i = n.bigits_.size(); i > 0; --i) {\r\n      auto value = n.bigits_[i - 1u];\r\n      if (first) {\r\n        out = format_to(out, FMT_STRING(\"{:x}\"), value);\r\n        first = false;\r\n        continue;\r\n      }\r\n      out = format_to(out, FMT_STRING(\"{:08x}\"), value);\r\n    }\r\n    if (n.exp_ > 0)\r\n      out = format_to(out, FMT_STRING(\"p{}\"),\r\n                      n.exp_ * detail::bigint::bigit_bits);\r\n    return out;\r\n  }\r\n};\r\n\r\nFMT_FUNC detail::utf8_to_utf16::utf8_to_utf16(string_view s) {\r\n  for_each_codepoint(s, [this](uint32_t cp, string_view) {\r\n    if (cp == invalid_code_point) FMT_THROW(std::runtime_error(\"invalid utf8\"));\r\n    if (cp <= 0xFFFF) {\r\n      buffer_.push_back(static_cast<wchar_t>(cp));\r\n    } else {\r\n      cp -= 0x10000;\r\n      buffer_.push_back(static_cast<wchar_t>(0xD800 + (cp >> 10)));\r\n      buffer_.push_back(static_cast<wchar_t>(0xDC00 + (cp & 0x3FF)));\r\n    }\r\n    return true;\r\n  });\r\n  buffer_.push_back(0);\r\n}\r\n\r\nFMT_FUNC void format_system_error(detail::buffer<char>& out, int error_code,\r\n                                  const char* message) FMT_NOEXCEPT {\r\n  FMT_TRY {\r\n    auto ec = std::error_code(error_code, std::generic_category());\r\n    write(std::back_inserter(out), std::system_error(ec, message).what());\r\n    return;\r\n  }\r\n  FMT_CATCH(...) {}\r\n  format_error_code(out, error_code, message);\r\n}\r\n\r\nFMT_FUNC void report_system_error(int error_code,\r\n                                  const char* message) FMT_NOEXCEPT {\r\n  report_error(format_system_error, error_code, message);\r\n}\r\n\r\n// DEPRECATED!\r\n// This function is defined here and not inline for ABI compatiblity.\r\nFMT_FUNC void detail::error_handler::on_error(const char* message) {\r\n  throw_format_error(message);\r\n}\r\n\r\nFMT_FUNC std::string vformat(string_view fmt, format_args args) {\r\n  // Don't optimize the \"{}\" case to keep the binary size small and because it\r\n  // can be better optimized in fmt::format anyway.\r\n  auto buffer = memory_buffer();\r\n  detail::vformat_to(buffer, fmt, args);\r\n  return to_string(buffer);\r\n}\r\n\r\n#ifdef _WIN32\r\nnamespace detail {\r\nusing dword = conditional_t<sizeof(long) == 4, unsigned long, unsigned>;\r\nextern \"C\" __declspec(dllimport) int __stdcall WriteConsoleW(  //\r\n    void*, const void*, dword, dword*, void*);\r\n}  // namespace detail\r\n#endif\r\n\r\nnamespace detail {\r\nFMT_FUNC void print(std::FILE* f, string_view text) {\r\n#ifdef _WIN32\r\n  auto fd = _fileno(f);\r\n  if (_isatty(fd)) {\r\n    detail::utf8_to_utf16 u16(string_view(text.data(), text.size()));\r\n    auto written = detail::dword();\r\n    if (detail::WriteConsoleW(reinterpret_cast<void*>(_get_osfhandle(fd)),\r\n                              u16.c_str(), static_cast<uint32_t>(u16.size()),\r\n                              &written, nullptr)) {\r\n      return;\r\n    }\r\n    // Fallback to fwrite on failure. It can happen if the output has been\r\n    // redirected to NUL.\r\n  }\r\n#endif\r\n  detail::fwrite_fully(text.data(), 1, text.size(), f);\r\n}\r\n}  // namespace detail\r\n\r\nFMT_FUNC void vprint(std::FILE* f, string_view format_str, format_args args) {\r\n  memory_buffer buffer;\r\n  detail::vformat_to(buffer, format_str, args);\r\n  detail::print(f, {buffer.data(), buffer.size()});\r\n}\r\n\r\n#ifdef _WIN32\r\n// Print assuming legacy (non-Unicode) encoding.\r\nFMT_FUNC void detail::vprint_mojibake(std::FILE* f, string_view format_str,\r\n                                      format_args args) {\r\n  memory_buffer buffer;\r\n  detail::vformat_to(buffer, format_str,\r\n                     basic_format_args<buffer_context<char>>(args));\r\n  fwrite_fully(buffer.data(), 1, buffer.size(), f);\r\n}\r\n#endif\r\n\r\nFMT_FUNC void vprint(string_view format_str, format_args args) {\r\n  vprint(stdout, format_str, args);\r\n}\r\n\r\nFMT_END_NAMESPACE\r\n\r\n#endif  // FMT_FORMAT_INL_H_\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format-inl.h b/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format-inl.h
--- a/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format-inl.h	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format-inl.h	(date 1720344409035)
@@ -326,13 +326,13 @@
 }
 
 // Returns a cached power of 10 `c_k = c_k.f * pow(2, c_k.e)` such that its
-// (binary) exponent satisfies `min_exponent <= c_k.e <= min_exponent + 28`.
-FMT_CONSTEXPR inline fp get_cached_power(int min_exponent,
+// (binary) exponent satisfies `min_EXPonent <= c_k.e <= min_EXPonent + 28`.
+FMT_CONSTEXPR inline fp get_cached_power(int min_EXPonent,
                                          int& pow10_exponent) {
   const int shift = 32;
   const auto significand = static_cast<int64_t>(log10_2_significand);
   int index = static_cast<int>(
-      ((min_exponent + fp::num_significand_bits - 1) * (significand >> shift) +
+      ((min_EXPonent + fp::num_significand_bits - 1) * (significand >> shift) +
        ((int64_t(1) << shift) - 1))  // ceil
       >> 32                          // arithmetic shift
   );
@@ -522,8 +522,8 @@
       return i >= n.exp_ && i < n.num_bigits() ? n[i - n.exp_] : 0;
     };
     double_bigit borrow = 0;
-    int min_exp = (std::min)((std::min)(lhs1.exp_, lhs2.exp_), rhs.exp_);
-    for (int i = num_rhs_bigits - 1; i >= min_exp; --i) {
+    int min_EXP = (std::min)((std::min)(lhs1.exp_, lhs2.exp_), rhs.exp_);
+    for (int i = num_rhs_bigits - 1; i >= min_EXP; --i) {
       double_bigit sum =
           static_cast<double_bigit>(get_bigit(lhs1, i)) + get_bigit(lhs2, i);
       bigit rhs_bigit = get_bigit(rhs, i);
@@ -2110,7 +2110,7 @@
   } else {
     // Subnormal case; the interval is always regular.
     if (significand == 0) return {0, 0};
-    exponent = float_info<T>::min_exponent - float_info<T>::significand_bits;
+    exponent = float_info<T>::min_EXPonent - float_info<T>::significand_bits;
   }
 
   const bool include_left_endpoint = (significand % 2 == 0);
@@ -2374,11 +2374,11 @@
   if (is_fast_float<Float>()) {
     // Use Grisu + Dragon4 for the given precision:
     // https://www.cs.tufts.edu/~nr/cs257/archive/florian-loitsch/printf.pdf.
-    const int min_exp = -60;  // alpha in Grisu.
+    const int min_EXP = -60;  // alpha in Grisu.
     int cached_exp10 = 0;     // K in Grisu.
     fp normalized = normalize(fp(value));
     const auto cached_pow = get_cached_power(
-        min_exp - (normalized.e + fp::num_significand_bits), cached_exp10);
+        min_EXP - (normalized.e + fp::num_significand_bits), cached_exp10);
     normalized = normalized * cached_pow;
     gen_digits_handler handler{buf.data(), 0, precision, -cached_exp10, fixed};
     if (grisu_gen_digits(normalized, 1, exp, handler) != digits::error &&
Index: Config/DefaultInput.ini
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n\r\n[/Script/Engine.InputSettings]\r\n-AxisConfig=(AxisKeyName=\"Gamepad_LeftX\",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))\r\n-AxisConfig=(AxisKeyName=\"Gamepad_LeftY\",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))\r\n-AxisConfig=(AxisKeyName=\"Gamepad_RightX\",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))\r\n-AxisConfig=(AxisKeyName=\"Gamepad_RightY\",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))\r\n-AxisConfig=(AxisKeyName=\"MouseX\",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))\r\n-AxisConfig=(AxisKeyName=\"MouseY\",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))\r\n-AxisConfig=(AxisKeyName=\"Mouse2D\",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))\r\n+AxisConfig=(AxisKeyName=\"MouseY\",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MouseWheelAxis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Gamepad_LeftTriggerAxis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Gamepad_RightTriggerAxis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Gamepad_Special_Left_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Gamepad_Special_Left_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Mouse2D\",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Gamepad_LeftX\",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Gamepad_LeftY\",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Gamepad_RightX\",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Gamepad_RightY\",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MouseX\",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Vive_Left_Trigger_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Vive_Left_Trackpad_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Vive_Left_Trackpad_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Vive_Right_Trigger_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Vive_Right_Trackpad_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"Vive_Right_Trackpad_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MixedReality_Left_Trigger_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MixedReality_Left_Thumbstick_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MixedReality_Left_Thumbstick_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MixedReality_Left_Trackpad_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MixedReality_Left_Trackpad_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MixedReality_Right_Trigger_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MixedReality_Right_Thumbstick_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MixedReality_Right_Thumbstick_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MixedReality_Right_Trackpad_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"MixedReality_Right_Trackpad_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"OculusTouch_Left_Grip_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"OculusTouch_Left_Trigger_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"OculusTouch_Left_Thumbstick_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"OculusTouch_Left_Thumbstick_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"OculusTouch_Right_Grip_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"OculusTouch_Right_Trigger_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"OculusTouch_Right_Thumbstick_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"OculusTouch_Right_Thumbstick_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Left_Grip_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Left_Grip_Force\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Left_Trigger_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Left_Thumbstick_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Left_Thumbstick_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Left_Trackpad_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Left_Trackpad_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Left_Trackpad_Force\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Left_Trackpad_Touch\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Right_Grip_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Right_Grip_Force\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Right_Trigger_Axis\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Right_Thumbstick_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Right_Thumbstick_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Right_Trackpad_X\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Right_Trackpad_Y\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\n+AxisConfig=(AxisKeyName=\"ValveIndex_Right_Trackpad_Force\",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))\r\nbAltEnterTogglesFullscreen=True\r\nbF11TogglesFullscreen=True\r\nbUseMouseForTouch=False\r\nbEnableMouseSmoothing=True\r\nbEnableFOVScaling=True\r\nbCaptureMouseOnLaunch=True\r\nbEnableLegacyInputScales=True\r\nbEnableMotionControls=True\r\nbFilterInputByPlatformUser=False\r\nbShouldFlushPressedKeysOnViewportFocusLost=True\r\nbEnableDynamicComponentInputBinding=True\r\nbAlwaysShowTouchInterface=False\r\nbShowConsoleOnFourFingerTap=True\r\nbEnableGestureRecognizer=False\r\nbUseAutocorrect=False\r\nDefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown\r\nDefaultViewportMouseLockMode=LockOnCapture\r\nFOVScale=0.011110\r\nDoubleClickTime=0.200000\r\n+ActionMappings=(ActionName=\"Jump\",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=SpaceBar)\r\n+ActionMappings=(ActionName=\"Jump\",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Gamepad_FaceButton_Bottom)\r\n+ActionMappings=(ActionName=\"Dash\",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftShift)\r\n+ActionMappings=(ActionName=\"CombatMode\",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Tab)\r\n+ActionMappings=(ActionName=\"NormlaAttack\",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftMouseButton)\r\n+ActionMappings=(ActionName=\"Blocking\",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=Q)\r\n+ActionMappings=(ActionName=\"Sprint\",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=R)\r\n+ActionMappings=(ActionName=\"ReverseTime\",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=E)\r\n+ActionMappings=(ActionName=\"ForwardTime\",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=F)\r\n+ActionMappings=(ActionName=\"Interact\",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=E)\r\n+AxisMappings=(AxisName=\"Move Forward / Backward\",Scale=1.000000,Key=W)\r\n+AxisMappings=(AxisName=\"Move Forward / Backward\",Scale=-1.000000,Key=S)\r\n+AxisMappings=(AxisName=\"Move Forward / Backward\",Scale=1.000000,Key=Gamepad_LeftY)\r\n+AxisMappings=(AxisName=\"Move Right / Left\",Scale=-1.000000,Key=A)\r\n+AxisMappings=(AxisName=\"Move Right / Left\",Scale=1.000000,Key=D)\r\n+AxisMappings=(AxisName=\"Move Right / Left\",Scale=1.000000,Key=Gamepad_LeftX)\r\n+AxisMappings=(AxisName=\"Turn Right / Left Gamepad\",Scale=1.000000,Key=Gamepad_RightX)\r\n+AxisMappings=(AxisName=\"Turn Right / Left Mouse\",Scale=1.000000,Key=MouseX)\r\n+AxisMappings=(AxisName=\"Look Up / Down Gamepad\",Scale=1.000000,Key=Gamepad_RightY)\r\n+AxisMappings=(AxisName=\"Look Up / Down Mouse\",Scale=-1.000000,Key=MouseY)\r\nDefaultPlayerInputClass=/Script/EnhancedInput.EnhancedPlayerInput\r\nDefaultInputComponentClass=/Script/EnhancedInput.EnhancedInputComponent\r\nDefaultTouchInterface=/Engine/MobileResources/HUD/DefaultVirtualJoysticks.DefaultVirtualJoysticks\r\n-ConsoleKeys=Tilde\r\n+ConsoleKeys=Tilde\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Config/DefaultInput.ini b/Config/DefaultInput.ini
--- a/Config/DefaultInput.ini	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Config/DefaultInput.ini	(date 1722677812382)
@@ -70,6 +70,7 @@
 bEnableLegacyInputScales=True
 bEnableMotionControls=True
 bFilterInputByPlatformUser=False
+bEnableInputDeviceSubsystem=True
 bShouldFlushPressedKeysOnViewportFocusLost=True
 bEnableDynamicComponentInputBinding=True
 bAlwaysShowTouchInterface=False
@@ -90,6 +91,12 @@
 +ActionMappings=(ActionName="ReverseTime",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=E)
 +ActionMappings=(ActionName="ForwardTime",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=F)
 +ActionMappings=(ActionName="Interact",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=E)
++ActionMappings=(ActionName="Devour",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=E)
++ActionMappings=(ActionName="PossessMonster",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=F)
++ActionMappings=(ActionName="ToggleSkillWindow",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=K)
++ActionMappings=(ActionName="SpiralDash",bShift=True,bCtrl=False,bAlt=False,bCmd=False,Key=F)
++ActionMappings=(ActionName="JumpAttack",bShift=True,bCtrl=False,bAlt=False,bCmd=False,Key=LeftMouseButton)
++ActionMappings=(ActionName="AirNormalAttack",bShift=False,bCtrl=False,bAlt=False,bCmd=False,Key=LeftMouseButton)
 +AxisMappings=(AxisName="Move Forward / Backward",Scale=1.000000,Key=W)
 +AxisMappings=(AxisName="Move Forward / Backward",Scale=-1.000000,Key=S)
 +AxisMappings=(AxisName="Move Forward / Backward",Scale=1.000000,Key=Gamepad_LeftY)
Index: Config/DefaultGame.ini
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[/Script/EngineSettings.GeneralProjectSettings]\r\nProjectID=9B8B78F143F14941F702E1B0EDA63030\r\nProjectName=Third Person Game Template\r\nDescription=FIM\r\n\r\n[StartupActions]\r\nbAddPacks=True\r\nInsertPack=(PackSource=\"StarterContent.upack\",PackName=\"StarterContent\")\r\n\r\n[/Script/Engine.AssetManagerSettings]\r\n-PrimaryAssetTypesToScan=(PrimaryAssetType=\"Map\",AssetBaseClass=/Script/Engine.World,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path=\"/Game/Maps\")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))\r\n-PrimaryAssetTypesToScan=(PrimaryAssetType=\"PrimaryAssetLabel\",AssetBaseClass=/Script/Engine.PrimaryAssetLabel,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path=\"/Game\")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))\r\n+PrimaryAssetTypesToScan=(PrimaryAssetType=\"Map\",AssetBaseClass=\"/Script/Engine.World\",bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path=\"/Game/Maps\")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))\r\n+PrimaryAssetTypesToScan=(PrimaryAssetType=\"PrimaryAssetLabel\",AssetBaseClass=\"/Script/Engine.PrimaryAssetLabel\",bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path=\"/Game\")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))\r\n+PrimaryAssetTypesToScan=(PrimaryAssetType=\"GameFeatureData\",AssetBaseClass=\"/Script/GameFeatures.GameFeatureData\",bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=((Path=\"/Game/Unused\")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=AlwaysCook))\r\nbOnlyCookProductionAssets=False\r\nbShouldManagerDetermineTypeAndName=False\r\nbShouldGuessTypeAndNameInEditor=True\r\nbShouldAcquireMissingChunksOnLoad=False\r\nbShouldWarnAboutInvalidAssets=True\r\nMetaDataTagsForAssetRegistry=()\r\n\r\n[/Script/UnrealEd.ProjectPackagingSettings]\r\nBuildConfiguration=PPBC_Shipping\r\nbCookMapsOnly=False\r\nFullRebuild=False\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Config/DefaultGame.ini b/Config/DefaultGame.ini
--- a/Config/DefaultGame.ini	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Config/DefaultGame.ini	(date 1720720014582)
@@ -7,14 +7,14 @@
 bAddPacks=True
 InsertPack=(PackSource="StarterContent.upack",PackName="StarterContent")
 
-[/Script/Engine.AssetManagerSettings]
+[/Script/Engine.Assetn_BASIC_MPgerSettings]
 -PrimaryAssetTypesToScan=(PrimaryAssetType="Map",AssetBaseClass=/Script/Engine.World,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game/Maps")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
 -PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryAssetLabel",AssetBaseClass=/Script/Engine.PrimaryAssetLabel,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
 +PrimaryAssetTypesToScan=(PrimaryAssetType="Map",AssetBaseClass="/Script/Engine.World",bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game/Maps")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
 +PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryAssetLabel",AssetBaseClass="/Script/Engine.PrimaryAssetLabel",bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
 +PrimaryAssetTypesToScan=(PrimaryAssetType="GameFeatureData",AssetBaseClass="/Script/GameFeatures.GameFeatureData",bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=((Path="/Game/Unused")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=AlwaysCook))
 bOnlyCookProductionAssets=False
-bShouldManagerDetermineTypeAndName=False
+bShouldn_BASIC_MPgerDetermineTypeAndName=False
 bShouldGuessTypeAndNameInEditor=True
 bShouldAcquireMissingChunksOnLoad=False
 bShouldWarnAboutInvalidAssets=True
@@ -25,3 +25,16 @@
 bCookMapsOnly=False
 FullRebuild=False
 
+[/Script/Engine.AssetManagerSettings]
+-PrimaryAssetTypesToScan=(PrimaryAssetType="Map",AssetBaseClass=/Script/Engine.World,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game/Maps")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
+-PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryAssetLabel",AssetBaseClass=/Script/Engine.PrimaryAssetLabel,bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
++PrimaryAssetTypesToScan=(PrimaryAssetType="Map",AssetBaseClass="/Script/Engine.World",bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game/Maps")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
++PrimaryAssetTypesToScan=(PrimaryAssetType="PrimaryAssetLabel",AssetBaseClass="/Script/Engine.PrimaryAssetLabel",bHasBlueprintClasses=False,bIsEditorOnly=True,Directories=((Path="/Game")),SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=Unknown))
++PrimaryAssetTypesToScan=(PrimaryAssetType="GameFeatureData",AssetBaseClass="/Script/GameFeatures.GameFeatureData",bHasBlueprintClasses=False,bIsEditorOnly=False,Directories=,SpecificAssets=,Rules=(Priority=-1,ChunkId=-1,bApplyRecursively=True,CookRule=AlwaysCook))
+bOnlyCookProductionAssets=False
+bShouldManagerDetermineTypeAndName=False
+bShouldGuessTypeAndNameInEditor=True
+bShouldAcquireMissingChunksOnLoad=False
+bShouldWarnAboutInvalidAssets=True
+MetaDataTagsForAssetRegistry=()
+
Index: Config/DefaultGameplayTags.ini
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[/Script/GameplayTags.GameplayTagsSettings]\r\nImportTagsFromConfig=True\r\nWarnOnInvalidTags=True\r\nClearInvalidTags=False\r\nFastReplication=False\r\nInvalidTagCharacters=\"\\\"\\',\"\r\nNumBitsForContainerSize=6\r\nNetIndexFirstBitSegment=16\r\n+GameplayTagList=(Tag=\"Char.Skill.Melee.Cooldown\",DevComment=\"\")\r\n+GameplayTagList=(Tag=\"Char.Skill.Melee.DamageEffect\",DevComment=\"\")\r\n+GameplayTagList=(Tag=\"Char.Skill.Melee.DealDamage\",DevComment=\"\")\r\n+GameplayTagList=(Tag=\"Char.Skill.Melee.Defense\",DevComment=\"\")\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Config/DefaultGameplayTags.ini b/Config/DefaultGameplayTags.ini
--- a/Config/DefaultGameplayTags.ini	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Config/DefaultGameplayTags.ini	(date 1722089905118)
@@ -2,12 +2,18 @@
 ImportTagsFromConfig=True
 WarnOnInvalidTags=True
 ClearInvalidTags=False
+AllowEditorTagUnloading=True
+AllowGameTagUnloading=False
 FastReplication=False
 InvalidTagCharacters="\"\',"
 NumBitsForContainerSize=6
 NetIndexFirstBitSegment=16
++GameplayTagList=(Tag="Char.n_LV",DevComment="AddXP")
++GameplayTagList=(Tag="Char.n_LV.AddXP",DevComment="")
++GameplayTagList=(Tag="Char.Skill.Devour.Addn_BAISC_DP",DevComment="")
 +GameplayTagList=(Tag="Char.Skill.Melee.Cooldown",DevComment="")
 +GameplayTagList=(Tag="Char.Skill.Melee.DamageEffect",DevComment="")
 +GameplayTagList=(Tag="Char.Skill.Melee.DealDamage",DevComment="")
 +GameplayTagList=(Tag="Char.Skill.Melee.Defense",DevComment="")
++GameplayTagList=(Tag="Char.Skill.Melee.SkillDamage",DevComment="")
 
Index: Plugins/Developer/RiderLink/Source/RD/thirdparty/optional/tl/optional.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n///\r\n// optional - An implementation of std::optional with extensions\r\n// Written in 2017 by Simon Brand (tartanllama@gmail.com, @TartanLlama)\r\n//\r\n// To the extent possible under law, the author(s) have dedicated all\r\n// copyright and related and neighboring rights to this software to the\r\n// public domain worldwide. This software is distributed without any warranty.\r\n//\r\n// You should have received a copy of the CC0 Public Domain Dedication\r\n// along with this software. If not, see\r\n// <http://creativecommons.org/publicdomain/zero/1.0/>.\r\n///\r\n\r\n#ifndef TL_OPTIONAL_HPP\r\n#define TL_OPTIONAL_HPP\r\n\r\n#define TL_OPTIONAL_VERSION_MAJOR 0\r\n#define TL_OPTIONAL_VERSION_MINOR 5\r\n\r\n#include <exception>\r\n#include <functional>\r\n#include <new>\r\n#include <type_traits>\r\n#include <utility>\r\n\r\n#if (defined(_MSC_VER) && _MSC_VER == 1900)\r\n#define TL_OPTIONAL_MSVC2015\r\n#endif\r\n\r\n#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \\\r\n     !defined(__clang__))\r\n#define TL_OPTIONAL_GCC49\r\n#endif\r\n\r\n#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 4 &&              \\\r\n     !defined(__clang__))\r\n#define TL_OPTIONAL_GCC54\r\n#endif\r\n\r\n#if (defined(__GNUC__) && __GNUC__ == 5 && __GNUC_MINOR__ <= 5 &&              \\\r\n     !defined(__clang__))\r\n#define TL_OPTIONAL_GCC55\r\n#endif\r\n\r\n#if (defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ <= 9 &&              \\\r\n     !defined(__clang__))\r\n// GCC < 5 doesn't support overloading on const&& for member functions\r\n#define TL_OPTIONAL_NO_CONSTRR\r\n\r\n// GCC < 5 doesn't support some standard C++11 type traits\r\n#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                                     \\\r\n  std::has_trivial_copy_constructor<T>::value\r\n#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T) std::has_trivial_copy_assign<T>::value\r\n\r\n// This one will be different for GCC 5.7 if it's ever supported\r\n#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T) std::is_trivially_destructible<T>::value\r\n\r\n// GCC 5 < v < 8 has an issue in is_trivially_copy_constructible which breaks std::vector\r\n// for non-copyable types\r\n#elif (defined(__GNUC__) && __GNUC__ < 8 &&                                                \\\r\n     !defined(__clang__))\r\n#ifndef TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX\r\n#define TL_GCC_LESS_8_TRIVIALLY_COPY_CONSTRUCTIBLE_MUTEX\r\nnamespace tl {\r\n  namespace detail {\r\n      template<class T>\r\n      struct is_trivially_copy_constructible : std::is_trivially_copy_constructible<T>{};\r\n#ifdef _GLIBCXX_VECTOR\r\n      template<class T, class A>\r\n      struct is_trivially_copy_constructible<std::vector<T,A>>\r\n          : std::is_trivially_copy_constructible<T>{};\r\n#endif      \r\n  }\r\n}\r\n#endif\r\n\r\n#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                                     \\\r\n    tl::detail::is_trivially_copy_constructible<T>::value\r\n#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                                        \\\r\n  std::is_trivially_copy_assignable<T>::value\r\n#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T) std::is_trivially_destructible<T>::value\r\n#else\r\n#define TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)                                     \\\r\n  std::is_trivially_copy_constructible<T>::value\r\n#define TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T)                                        \\\r\n  std::is_trivially_copy_assignable<T>::value\r\n#define TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T) std::is_trivially_destructible<T>::value\r\n#endif\r\n\r\n#if __cplusplus > 201103L\r\n#define TL_OPTIONAL_CXX14\r\n#endif\r\n\r\n// constexpr implies const in C++11, not C++14\r\n#if (__cplusplus == 201103L || defined(TL_OPTIONAL_MSVC2015) ||                \\\r\n     defined(TL_OPTIONAL_GCC49))\r\n/// \\exclude\r\n#define TL_OPTIONAL_11_CONSTEXPR\r\n#else\r\n/// \\exclude\r\n#define TL_OPTIONAL_11_CONSTEXPR constexpr\r\n#endif\r\n\r\nnamespace tl {\r\n#ifndef TL_MONOSTATE_INPLACE_MUTEX\r\n#define TL_MONOSTATE_INPLACE_MUTEX\r\n/// \\brief Used to represent an optional with no data; essentially a bool\r\nclass monostate {};\r\n\r\n/// \\brief A tag type to tell optional to construct its value in-place\r\nstruct in_place_t {\r\n  explicit in_place_t() = default;\r\n};\r\n/// \\brief A tag to tell optional to construct its value in-place\r\nstatic constexpr in_place_t in_place{};\r\n#endif\r\n\r\ntemplate <class T> class optional;\r\n\r\n/// \\exclude\r\nnamespace detail {\r\n#ifndef TL_TRAITS_MUTEX\r\n#define TL_TRAITS_MUTEX\r\n// C++14-style aliases for brevity\r\ntemplate <class T> using remove_const_t = typename std::remove_const<T>::type;\r\ntemplate <class T>\r\nusing remove_reference_t = typename std::remove_reference<T>::type;\r\ntemplate <class T> using decay_t = typename std::decay<T>::type;\r\ntemplate <bool E, class T = void>\r\nusing enable_if_t = typename std::enable_if<E, T>::type;\r\ntemplate <bool B, class T, class F>\r\nusing conditional_t = typename std::conditional<B, T, F>::type;\r\n\r\n// std::conjunction from C++17\r\ntemplate <class...> struct conjunction : std::true_type {};\r\ntemplate <class B> struct conjunction<B> : B {};\r\ntemplate <class B, class... Bs>\r\nstruct conjunction<B, Bs...>\r\n    : std::conditional<bool(B::value), conjunction<Bs...>, B>::type {};\r\n\r\n#if defined(_LIBCPP_VERSION) && __cplusplus == 201103L\r\n#define TL_OPTIONAL_LIBCXX_MEM_FN_WORKAROUND\r\n#endif\r\n\r\n// In C++11 mode, there's an issue in libc++'s std::mem_fn\r\n// which results in a hard-error when using it in a noexcept expression\r\n// in some cases. This is a check to workaround the common failing case.\r\n#ifdef TL_OPTIONAL_LIBCXX_MEM_FN_WORKAROUND\r\ntemplate <class T> struct is_pointer_to_non_const_member_func : std::false_type{};\r\ntemplate <class T, class Ret, class... Args>\r\nstruct is_pointer_to_non_const_member_func<Ret (T::*) (Args...)> : std::true_type{};\r\ntemplate <class T, class Ret, class... Args>\r\nstruct is_pointer_to_non_const_member_func<Ret (T::*) (Args...)&> : std::true_type{};\r\ntemplate <class T, class Ret, class... Args>\r\nstruct is_pointer_to_non_const_member_func<Ret (T::*) (Args...)&&> : std::true_type{};        \r\ntemplate <class T, class Ret, class... Args>\r\nstruct is_pointer_to_non_const_member_func<Ret (T::*) (Args...) volatile> : std::true_type{};\r\ntemplate <class T, class Ret, class... Args>\r\nstruct is_pointer_to_non_const_member_func<Ret (T::*) (Args...) volatile&> : std::true_type{};\r\ntemplate <class T, class Ret, class... Args>\r\nstruct is_pointer_to_non_const_member_func<Ret (T::*) (Args...) volatile&&> : std::true_type{};        \r\n\r\ntemplate <class T> struct is_const_or_const_ref : std::false_type{};\r\ntemplate <class T> struct is_const_or_const_ref<T const&> : std::true_type{};\r\ntemplate <class T> struct is_const_or_const_ref<T const> : std::true_type{};    \r\n#endif\r\n\r\n// std::invoke from C++17\r\n// https://stackoverflow.com/questions/38288042/c11-14-invoke-workaround\r\ntemplate <typename Fn, typename... Args,\r\n#ifdef TL_OPTIONAL_LIBCXX_MEM_FN_WORKAROUND\r\n          typename = enable_if_t<!(is_pointer_to_non_const_member_func<Fn>::value \r\n                                 && is_const_or_const_ref<Args...>::value)>, \r\n#endif\r\n          typename = enable_if_t<std::is_member_pointer<decay_t<Fn>>::value>,\r\n          int = 0>\r\nconstexpr auto invoke(Fn &&f, Args &&... args) noexcept(\r\n    noexcept(std::mem_fn(f)(std::forward<Args>(args)...)))\r\n    -> decltype(std::mem_fn(f)(std::forward<Args>(args)...)) {\r\n  return std::mem_fn(f)(std::forward<Args>(args)...);\r\n}\r\n\r\ntemplate <typename Fn, typename... Args,\r\n          typename = enable_if_t<!std::is_member_pointer<decay_t<Fn>>::value>>\r\nconstexpr auto invoke(Fn &&f, Args &&... args) noexcept(\r\n    noexcept(std::forward<Fn>(f)(std::forward<Args>(args)...)))\r\n    -> decltype(std::forward<Fn>(f)(std::forward<Args>(args)...)) {\r\n  return std::forward<Fn>(f)(std::forward<Args>(args)...);\r\n}\r\n\r\n// std::invoke_result from C++17\r\ntemplate <class F, class, class... Us> struct invoke_result_impl;\r\n\r\ntemplate <class F, class... Us>\r\nstruct invoke_result_impl<\r\n    F, decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...), void()),\r\n    Us...> {\r\n  using type = decltype(detail::invoke(std::declval<F>(), std::declval<Us>()...));\r\n};\r\n\r\ntemplate <class F, class... Us>\r\nusing invoke_result = invoke_result_impl<F, void, Us...>;\r\n\r\ntemplate <class F, class... Us>\r\nusing invoke_result_t = typename invoke_result<F, Us...>::type;\r\n#endif\r\n\r\n// std::void_t from C++17\r\ntemplate <class...> struct voider { using type = void; };\r\ntemplate <class... Ts> using void_t = typename voider<Ts...>::type;\r\n\r\n// Trait for checking if a type is a tl::optional\r\ntemplate <class T> struct is_optional_impl : std::false_type {};\r\ntemplate <class T> struct is_optional_impl<optional<T>> : std::true_type {};\r\ntemplate <class T> using is_optional = is_optional_impl<decay_t<T>>;\r\n\r\n// Change void to tl::monostate\r\ntemplate <class U>\r\nusing fixup_void = conditional_t<std::is_void<U>::value, monostate, U>;\r\n\r\ntemplate <class F, class U, class = invoke_result_t<F, U>>\r\nusing get_map_return = optional<fixup_void<invoke_result_t<F, U>>>;\r\n\r\n// Check if invoking F for some Us returns void\r\ntemplate <class F, class = void, class... U> struct returns_void_impl;\r\ntemplate <class F, class... U>\r\nstruct returns_void_impl<F, void_t<invoke_result_t<F, U...>>, U...>\r\n    : std::is_void<invoke_result_t<F, U...>> {};\r\ntemplate <class F, class... U>\r\nusing returns_void = returns_void_impl<F, void, U...>;\r\n\r\ntemplate <class T, class... U>\r\nusing enable_if_ret_void = enable_if_t<returns_void<T &&, U...>::value>;\r\n\r\ntemplate <class T, class... U>\r\nusing disable_if_ret_void = enable_if_t<!returns_void<T &&, U...>::value>;\r\n\r\ntemplate <class T, class U>\r\nusing enable_forward_value =\r\n    detail::enable_if_t<std::is_constructible<T, U &&>::value &&\r\n                        !std::is_same<detail::decay_t<U>, in_place_t>::value &&\r\n                        !std::is_same<optional<T>, detail::decay_t<U>>::value>;\r\n\r\ntemplate <class T, class U, class Other>\r\nusing enable_from_other = detail::enable_if_t<\r\n    std::is_constructible<T, Other>::value &&\r\n    !std::is_constructible<T, optional<U> &>::value &&\r\n    !std::is_constructible<T, optional<U> &&>::value &&\r\n    !std::is_constructible<T, const optional<U> &>::value &&\r\n    !std::is_constructible<T, const optional<U> &&>::value &&\r\n    !std::is_convertible<optional<U> &, T>::value &&\r\n    !std::is_convertible<optional<U> &&, T>::value &&\r\n    !std::is_convertible<const optional<U> &, T>::value &&\r\n    !std::is_convertible<const optional<U> &&, T>::value>;\r\n\r\ntemplate <class T, class U>\r\nusing enable_assign_forward = detail::enable_if_t<\r\n    !std::is_same<optional<T>, detail::decay_t<U>>::value &&\r\n    !detail::conjunction<std::is_scalar<T>,\r\n                         std::is_same<T, detail::decay_t<U>>>::value &&\r\n    std::is_constructible<T, U>::value && std::is_assignable<T &, U>::value>;\r\n\r\ntemplate <class T, class U, class Other>\r\nusing enable_assign_from_other = detail::enable_if_t<\r\n    std::is_constructible<T, Other>::value &&\r\n    std::is_assignable<T &, Other>::value &&\r\n    !std::is_constructible<T, optional<U> &>::value &&\r\n    !std::is_constructible<T, optional<U> &&>::value &&\r\n    !std::is_constructible<T, const optional<U> &>::value &&\r\n    !std::is_constructible<T, const optional<U> &&>::value &&\r\n    !std::is_convertible<optional<U> &, T>::value &&\r\n    !std::is_convertible<optional<U> &&, T>::value &&\r\n    !std::is_convertible<const optional<U> &, T>::value &&\r\n    !std::is_convertible<const optional<U> &&, T>::value &&\r\n    !std::is_assignable<T &, optional<U> &>::value &&\r\n    !std::is_assignable<T &, optional<U> &&>::value &&\r\n    !std::is_assignable<T &, const optional<U> &>::value &&\r\n    !std::is_assignable<T &, const optional<U> &&>::value>;\r\n\r\n#ifdef _MSC_VER\r\n// TO-DO make a version which works with MSVC\r\ntemplate <class T, class U = T> struct is_swappable : std::true_type {};\r\n\r\ntemplate <class T, class U = T> struct is_nothrow_swappable : std::true_type {};\r\n#else\r\n// https://stackoverflow.com/questions/26744589/what-is-a-proper-way-to-implement-is-swappable-to-test-for-the-swappable-concept\r\nnamespace swap_adl_tests {\r\n// if swap ADL finds this then it would call std::swap otherwise (same\r\n// signature)\r\nstruct tag {};\r\n\r\ntemplate <class T> tag swap(T &, T &);\r\ntemplate <class T, std::size_t N> tag swap(T (&a)[N], T (&b)[N]);\r\n\r\n// helper functions to test if an unqualified swap is possible, and if it\r\n// becomes std::swap\r\ntemplate <class, class> std::false_type can_swap(...) noexcept(false);\r\ntemplate <class T, class U,\r\n          class = decltype(swap(std::declval<T &>(), std::declval<U &>()))>\r\nstd::true_type can_swap(int) noexcept(noexcept(swap(std::declval<T &>(),\r\n                                                    std::declval<U &>())));\r\n\r\ntemplate <class, class> std::false_type uses_std(...);\r\ntemplate <class T, class U>\r\nstd::is_same<decltype(swap(std::declval<T &>(), std::declval<U &>())), tag>\r\nuses_std(int);\r\n\r\ntemplate <class T>\r\nstruct is_std_swap_noexcept\r\n    : std::integral_constant<bool,\r\n                             std::is_nothrow_move_constructible<T>::value &&\r\n                                 std::is_nothrow_move_assignable<T>::value> {};\r\n\r\ntemplate <class T, std::size_t N>\r\nstruct is_std_swap_noexcept<T[N]> : is_std_swap_noexcept<T> {};\r\n\r\ntemplate <class T, class U>\r\nstruct is_adl_swap_noexcept\r\n    : std::integral_constant<bool, noexcept(can_swap<T, U>(0))> {};\r\n} // namespace swap_adl_tests\r\n\r\ntemplate <class T, class U = T>\r\nstruct is_swappable\r\n    : std::integral_constant<\r\n          bool,\r\n          decltype(detail::swap_adl_tests::can_swap<T, U>(0))::value &&\r\n              (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value ||\r\n               (std::is_move_assignable<T>::value &&\r\n                std::is_move_constructible<T>::value))> {};\r\n\r\ntemplate <class T, std::size_t N>\r\nstruct is_swappable<T[N], T[N]>\r\n    : std::integral_constant<\r\n          bool,\r\n          decltype(detail::swap_adl_tests::can_swap<T[N], T[N]>(0))::value &&\r\n              (!decltype(\r\n                   detail::swap_adl_tests::uses_std<T[N], T[N]>(0))::value ||\r\n               is_swappable<T, T>::value)> {};\r\n\r\ntemplate <class T, class U = T>\r\nstruct is_nothrow_swappable\r\n    : std::integral_constant<\r\n          bool,\r\n          is_swappable<T, U>::value &&\r\n              ((decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value\r\n                    &&detail::swap_adl_tests::is_std_swap_noexcept<T>::value) ||\r\n               (!decltype(detail::swap_adl_tests::uses_std<T, U>(0))::value &&\r\n                    detail::swap_adl_tests::is_adl_swap_noexcept<T,\r\n                                                                 U>::value))> {\r\n};\r\n#endif\r\n\r\n// The storage base manages the actual storage, and correctly propagates\r\n// trivial destruction from T. This case is for when T is not trivially\r\n// destructible.\r\ntemplate <class T, bool = ::std::is_trivially_destructible<T>::value>\r\nstruct optional_storage_base {\r\n  TL_OPTIONAL_11_CONSTEXPR optional_storage_base() noexcept\r\n      : m_dummy(), m_has_value(false) {}\r\n\r\n  template <class... U>\r\n  TL_OPTIONAL_11_CONSTEXPR optional_storage_base(in_place_t, U &&... u)\r\n      : m_value(std::forward<U>(u)...), m_has_value(true) {}\r\n\r\n  ~optional_storage_base() {\r\n    if (m_has_value) {\r\n      m_value.~T();\r\n      m_has_value = false;\r\n    }\r\n  }\r\n\r\n  struct dummy {};\r\n  union {\r\n    dummy m_dummy;\r\n    T m_value;\r\n  };\r\n\r\n  bool m_has_value;\r\n};\r\n\r\n// This case is for when T is trivially destructible.\r\ntemplate <class T> struct optional_storage_base<T, true> {\r\n  TL_OPTIONAL_11_CONSTEXPR optional_storage_base() noexcept\r\n      : m_dummy(), m_has_value(false) {}\r\n\r\n  template <class... U>\r\n  TL_OPTIONAL_11_CONSTEXPR optional_storage_base(in_place_t, U &&... u)\r\n      : m_value(std::forward<U>(u)...), m_has_value(true) {}\r\n\r\n  // No destructor, so this class is trivially destructible\r\n\r\n  struct dummy {};\r\n  union {\r\n    dummy m_dummy;\r\n    T m_value;\r\n  };\r\n\r\n  bool m_has_value = false;\r\n};\r\n\r\n// This base class provides some handy member functions which can be used in\r\n// further derived classes\r\ntemplate <class T> struct optional_operations_base : optional_storage_base<T> {\r\n  using optional_storage_base<T>::optional_storage_base;\r\n\r\n  void hard_reset() noexcept {\r\n    get().~T();\r\n    this->m_has_value = false;\r\n  }\r\n\r\n  template <class... Args> void construct(Args &&... args) noexcept {\r\n    new (std::addressof(this->m_value)) T(std::forward<Args>(args)...);\r\n    this->m_has_value = true;\r\n  }\r\n\r\n  template <class Opt> void assign(Opt &&rhs) {\r\n    if (this->has_value()) {\r\n      if (rhs.has_value()) {\r\n        this->m_value = std::forward<Opt>(rhs).get();\r\n      } else {\r\n        this->m_value.~T();\r\n        this->m_has_value = false;\r\n      }\r\n    }\r\n\r\n    else if (rhs.has_value()) {\r\n      construct(std::forward<Opt>(rhs).get());\r\n    }\r\n  }\r\n\r\n  bool has_value() const { return this->m_has_value; }\r\n\r\n  TL_OPTIONAL_11_CONSTEXPR T &get() & { return this->m_value; }\r\n  TL_OPTIONAL_11_CONSTEXPR const T &get() const & { return this->m_value; }\r\n  TL_OPTIONAL_11_CONSTEXPR T &&get() && { return std::move(this->m_value); }\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  constexpr const T &&get() const && { return std::move(this->m_value); }\r\n#endif\r\n};\r\n\r\n// This class manages conditionally having a trivial copy constructor\r\n// This specialization is for when T is trivially copy constructible\r\ntemplate <class T, bool = TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)>\r\nstruct optional_copy_base : optional_operations_base<T> {\r\n  using optional_operations_base<T>::optional_operations_base;\r\n};\r\n\r\n// This specialization is for when T is not trivially copy constructible\r\ntemplate <class T>\r\nstruct optional_copy_base<T, false> : optional_operations_base<T> {\r\n  using optional_operations_base<T>::optional_operations_base;\r\n\r\n  optional_copy_base() = default;\r\n  optional_copy_base(const optional_copy_base &rhs) {\r\n    if (rhs.has_value()) {\r\n      this->construct(rhs.get());\r\n    } else {\r\n      this->m_has_value = false;\r\n    }\r\n  }\r\n\r\n  optional_copy_base(optional_copy_base &&rhs) = default;\r\n  optional_copy_base &operator=(const optional_copy_base &rhs) = default;\r\n  optional_copy_base &operator=(optional_copy_base &&rhs) = default;\r\n};\r\n\r\n// This class manages conditionally having a trivial move constructor\r\n// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it\r\n// doesn't implement an analogue to std::is_trivially_move_constructible. We\r\n// have to make do with a non-trivial move constructor even if T is trivially\r\n// move constructible\r\n#ifndef TL_OPTIONAL_GCC49\r\ntemplate <class T, bool = std::is_trivially_move_constructible<T>::value>\r\nstruct optional_move_base : optional_copy_base<T> {\r\n  using optional_copy_base<T>::optional_copy_base;\r\n};\r\n#else\r\ntemplate <class T, bool = false> struct optional_move_base;\r\n#endif\r\ntemplate <class T> struct optional_move_base<T, false> : optional_copy_base<T> {\r\n  using optional_copy_base<T>::optional_copy_base;\r\n\r\n  optional_move_base() = default;\r\n  optional_move_base(const optional_move_base &rhs) = default;\r\n\r\n  optional_move_base(optional_move_base &&rhs) noexcept(\r\n      std::is_nothrow_move_constructible<T>::value) {\r\n    if (rhs.has_value()) {\r\n      this->construct(std::move(rhs.get()));\r\n    } else {\r\n      this->m_has_value = false;\r\n    }\r\n  }\r\n  optional_move_base &operator=(const optional_move_base &rhs) = default;\r\n  optional_move_base &operator=(optional_move_base &&rhs) = default;\r\n};\r\n\r\n// This class manages conditionally having a trivial copy assignment operator\r\ntemplate <class T, bool = TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T) &&\r\n                          TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T) &&\r\n                          TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T)>\r\nstruct optional_copy_assign_base : optional_move_base<T> {\r\n  using optional_move_base<T>::optional_move_base;\r\n};\r\n\r\ntemplate <class T>\r\nstruct optional_copy_assign_base<T, false> : optional_move_base<T> {\r\n  using optional_move_base<T>::optional_move_base;\r\n\r\n  optional_copy_assign_base() = default;\r\n  optional_copy_assign_base(const optional_copy_assign_base &rhs) = default;\r\n\r\n  optional_copy_assign_base(optional_copy_assign_base &&rhs) = default;\r\n  optional_copy_assign_base &operator=(const optional_copy_assign_base &rhs) {\r\n    this->assign(rhs);\r\n    return *this;\r\n  }\r\n  optional_copy_assign_base &\r\n  operator=(optional_copy_assign_base &&rhs) = default;\r\n};\r\n\r\n// This class manages conditionally having a trivial move assignment operator\r\n// Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it\r\n// doesn't implement an analogue to std::is_trivially_move_assignable. We have\r\n// to make do with a non-trivial move assignment operator even if T is trivially\r\n// move assignable\r\n#ifndef TL_OPTIONAL_GCC49\r\ntemplate <class T, bool = std::is_trivially_destructible<T>::value\r\n                       &&std::is_trivially_move_constructible<T>::value\r\n                           &&std::is_trivially_move_assignable<T>::value>\r\nstruct optional_move_assign_base : optional_copy_assign_base<T> {\r\n  using optional_copy_assign_base<T>::optional_copy_assign_base;\r\n};\r\n#else\r\ntemplate <class T, bool = false> struct optional_move_assign_base;\r\n#endif\r\n\r\ntemplate <class T>\r\nstruct optional_move_assign_base<T, false> : optional_copy_assign_base<T> {\r\n  using optional_copy_assign_base<T>::optional_copy_assign_base;\r\n\r\n  optional_move_assign_base() = default;\r\n  optional_move_assign_base(const optional_move_assign_base &rhs) = default;\r\n\r\n  optional_move_assign_base(optional_move_assign_base &&rhs) = default;\r\n\r\n  optional_move_assign_base &\r\n  operator=(const optional_move_assign_base &rhs) = default;\r\n\r\n  optional_move_assign_base &\r\n  operator=(optional_move_assign_base &&rhs) noexcept(\r\n      std::is_nothrow_move_constructible<T>::value\r\n          &&std::is_nothrow_move_assignable<T>::value) {\r\n    this->assign(std::move(rhs));\r\n    return *this;\r\n  }\r\n};\r\n\r\n// optional_delete_ctor_base will conditionally delete copy and move\r\n// constructors depending on whether T is copy/move constructible\r\ntemplate <class T, bool EnableCopy = std::is_copy_constructible<T>::value,\r\n          bool EnableMove = std::is_move_constructible<T>::value>\r\nstruct optional_delete_ctor_base {\r\n  optional_delete_ctor_base() = default;\r\n  optional_delete_ctor_base(const optional_delete_ctor_base &) = default;\r\n  optional_delete_ctor_base(optional_delete_ctor_base &&) noexcept = default;\r\n  optional_delete_ctor_base &\r\n  operator=(const optional_delete_ctor_base &) = default;\r\n  optional_delete_ctor_base &\r\n  operator=(optional_delete_ctor_base &&) noexcept = default;\r\n};\r\n\r\ntemplate <class T> struct optional_delete_ctor_base<T, true, false> {\r\n  optional_delete_ctor_base() = default;\r\n  optional_delete_ctor_base(const optional_delete_ctor_base &) = default;\r\n  optional_delete_ctor_base(optional_delete_ctor_base &&) noexcept = delete;\r\n  optional_delete_ctor_base &\r\n  operator=(const optional_delete_ctor_base &) = default;\r\n  optional_delete_ctor_base &\r\n  operator=(optional_delete_ctor_base &&) noexcept = default;\r\n};\r\n\r\ntemplate <class T> struct optional_delete_ctor_base<T, false, true> {\r\n  optional_delete_ctor_base() = default;\r\n  optional_delete_ctor_base(const optional_delete_ctor_base &) = delete;\r\n  optional_delete_ctor_base(optional_delete_ctor_base &&) noexcept = default;\r\n  optional_delete_ctor_base &\r\n  operator=(const optional_delete_ctor_base &) = default;\r\n  optional_delete_ctor_base &\r\n  operator=(optional_delete_ctor_base &&) noexcept = default;\r\n};\r\n\r\ntemplate <class T> struct optional_delete_ctor_base<T, false, false> {\r\n  optional_delete_ctor_base() = default;\r\n  optional_delete_ctor_base(const optional_delete_ctor_base &) = delete;\r\n  optional_delete_ctor_base(optional_delete_ctor_base &&) noexcept = delete;\r\n  optional_delete_ctor_base &\r\n  operator=(const optional_delete_ctor_base &) = default;\r\n  optional_delete_ctor_base &\r\n  operator=(optional_delete_ctor_base &&) noexcept = default;\r\n};\r\n\r\n// optional_delete_assign_base will conditionally delete copy and move\r\n// constructors depending on whether T is copy/move constructible + assignable\r\ntemplate <class T,\r\n          bool EnableCopy = (std::is_copy_constructible<T>::value &&\r\n                             std::is_copy_assignable<T>::value),\r\n          bool EnableMove = (std::is_move_constructible<T>::value &&\r\n                             std::is_move_assignable<T>::value)>\r\nstruct optional_delete_assign_base {\r\n  optional_delete_assign_base() = default;\r\n  optional_delete_assign_base(const optional_delete_assign_base &) = default;\r\n  optional_delete_assign_base(optional_delete_assign_base &&) noexcept =\r\n      default;\r\n  optional_delete_assign_base &\r\n  operator=(const optional_delete_assign_base &) = default;\r\n  optional_delete_assign_base &\r\n  operator=(optional_delete_assign_base &&) noexcept = default;\r\n};\r\n\r\ntemplate <class T> struct optional_delete_assign_base<T, true, false> {\r\n  optional_delete_assign_base() = default;\r\n  optional_delete_assign_base(const optional_delete_assign_base &) = default;\r\n  optional_delete_assign_base(optional_delete_assign_base &&) noexcept =\r\n      default;\r\n  optional_delete_assign_base &\r\n  operator=(const optional_delete_assign_base &) = default;\r\n  optional_delete_assign_base &\r\n  operator=(optional_delete_assign_base &&) noexcept = delete;\r\n};\r\n\r\ntemplate <class T> struct optional_delete_assign_base<T, false, true> {\r\n  optional_delete_assign_base() = default;\r\n  optional_delete_assign_base(const optional_delete_assign_base &) = default;\r\n  optional_delete_assign_base(optional_delete_assign_base &&) noexcept =\r\n      default;\r\n  optional_delete_assign_base &\r\n  operator=(const optional_delete_assign_base &) = delete;\r\n  optional_delete_assign_base &\r\n  operator=(optional_delete_assign_base &&) noexcept = default;\r\n};\r\n\r\ntemplate <class T> struct optional_delete_assign_base<T, false, false> {\r\n  optional_delete_assign_base() = default;\r\n  optional_delete_assign_base(const optional_delete_assign_base &) = default;\r\n  optional_delete_assign_base(optional_delete_assign_base &&) noexcept =\r\n      default;\r\n  optional_delete_assign_base &\r\n  operator=(const optional_delete_assign_base &) = delete;\r\n  optional_delete_assign_base &\r\n  operator=(optional_delete_assign_base &&) noexcept = delete;\r\n};\r\n\r\n} // namespace detail\r\n\r\n/// \\brief A tag type to represent an empty optional\r\nstruct nullopt_t {\r\n  struct do_not_use {};\r\n  constexpr explicit nullopt_t(do_not_use, do_not_use) noexcept {}\r\n};\r\n/// \\brief Represents an empty optional\r\n/// \\synopsis static constexpr nullopt_t nullopt;\r\n///\r\n/// *Examples*:\r\n/// ```\r\n/// tl::optional<int> a = tl::nullopt;\r\n/// void foo (tl::optional<int>);\r\n/// foo(tl::nullopt); //pass an empty optional\r\n/// ```\r\nstatic constexpr nullopt_t nullopt{nullopt_t::do_not_use{},\r\n                                   nullopt_t::do_not_use{}};\r\n\r\nclass bad_optional_access : public std::exception {\r\npublic:\r\n  bad_optional_access() = default;\r\n  const char *what() const noexcept { return \"Optional has no value\"; }\r\n};\r\n\r\n/// An optional object is an object that contains the storage for another\r\n/// object and manages the lifetime of this contained object, if any. The\r\n/// contained object may be initialized after the optional object has been\r\n/// initialized, and may be destroyed before the optional object has been\r\n/// destroyed. The initialization state of the contained object is tracked by\r\n/// the optional object.\r\ntemplate <class T>\r\nclass optional : private detail::optional_move_assign_base<T>,\r\n                 private detail::optional_delete_ctor_base<T>,\r\n                 private detail::optional_delete_assign_base<T> {\r\n  using base = detail::optional_move_assign_base<T>;\r\n\r\n  static_assert(!std::is_same<T, in_place_t>::value,\r\n                \"instantiation of optional with in_place_t is ill-formed\");\r\n  static_assert(!std::is_same<detail::decay_t<T>, nullopt_t>::value,\r\n                \"instantiation of optional with nullopt_t is ill-formed\");\r\n\r\npublic:\r\n// The different versions for C++14 and 11 are needed because deduced return\r\n// types are not SFINAE-safe. This provides better support for things like\r\n// generic lambdas. C.f.\r\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0826r0.html\r\n#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \\\r\n    !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)\r\n  /// \\group and_then\r\n  /// Carries out some operation which returns an optional on the stored\r\n  /// object if there is one. \\requires `std::invoke(std::forward<F>(f),\r\n  /// value())` returns a `std::optional<U>` for some `U`. \\returns Let `U` be\r\n  /// the result of `std::invoke(std::forward<F>(f), value())`. Returns a\r\n  /// `std::optional<U>`. The return value is empty if `*this` is empty,\r\n  /// otherwise the return value of `std::invoke(std::forward<F>(f), value())`\r\n  /// is returned.\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) &;\r\n  template <class F> TL_OPTIONAL_11_CONSTEXPR auto and_then(F &&f) & {\r\n    using result = detail::invoke_result_t<F, T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) &&;\r\n  template <class F> TL_OPTIONAL_11_CONSTEXPR auto and_then(F &&f) && {\r\n    using result = detail::invoke_result_t<F, T &&>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : result(nullopt);\r\n  }\r\n\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) const &;\r\n  template <class F> constexpr auto and_then(F &&f) const & {\r\n    using result = detail::invoke_result_t<F, const T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) const &&;\r\n  template <class F> constexpr auto and_then(F &&f) const && {\r\n    using result = detail::invoke_result_t<F, const T &&>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : result(nullopt);\r\n  }\r\n#endif\r\n#else\r\n  /// \\group and_then\r\n  /// Carries out some operation which returns an optional on the stored\r\n  /// object if there is one. \\requires `std::invoke(std::forward<F>(f),\r\n  /// value())` returns a `std::optional<U>` for some `U`.\r\n  /// \\returns Let `U` be the result of `std::invoke(std::forward<F>(f),\r\n  /// value())`. Returns a `std::optional<U>`. The return value is empty if\r\n  /// `*this` is empty, otherwise the return value of\r\n  /// `std::invoke(std::forward<F>(f), value())` is returned.\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) &;\r\n  template <class F>\r\n  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T &> and_then(F &&f) & {\r\n    using result = detail::invoke_result_t<F, T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) &&;\r\n  template <class F>\r\n  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T &&> and_then(F &&f) && {\r\n    using result = detail::invoke_result_t<F, T &&>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : result(nullopt);\r\n  }\r\n\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) const &;\r\n  template <class F>\r\n  constexpr detail::invoke_result_t<F, const T &> and_then(F &&f) const & {\r\n    using result = detail::invoke_result_t<F, const T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) const &&;\r\n  template <class F>\r\n  constexpr detail::invoke_result_t<F, const T &&> and_then(F &&f) const && {\r\n    using result = detail::invoke_result_t<F, const T &&>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : result(nullopt);\r\n  }\r\n#endif\r\n#endif\r\n\r\n#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \\\r\n    !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)\r\n  /// \\brief Carries out some operation on the stored object if there is one.\r\n  /// \\returns Let `U` be the result of `std::invoke(std::forward<F>(f),\r\n  /// value())`. Returns a `std::optional<U>`. The return value is empty if\r\n  /// `*this` is empty, otherwise an `optional<U>` is constructed from the\r\n  /// return value of `std::invoke(std::forward<F>(f), value())` and is\r\n  /// returned.\r\n  ///\r\n  /// \\group map\r\n  /// \\synopsis template <class F> constexpr auto map(F &&f) &;\r\n  template <class F> TL_OPTIONAL_11_CONSTEXPR auto map(F &&f) & {\r\n    return optional_map_impl(*this, std::forward<F>(f));\r\n  }\r\n\r\n  /// \\group map\r\n  /// \\synopsis template <class F> constexpr auto map(F &&f) &&;\r\n  template <class F> TL_OPTIONAL_11_CONSTEXPR auto map(F &&f) && {\r\n    return optional_map_impl(std::move(*this), std::forward<F>(f));\r\n  }\r\n\r\n  /// \\group map\r\n  /// \\synopsis template <class F> constexpr auto map(F &&f) const&;\r\n  template <class F> constexpr auto map(F &&f) const & {\r\n    return optional_map_impl(*this, std::forward<F>(f));\r\n  }\r\n\r\n  /// \\group map\r\n  /// \\synopsis template <class F> constexpr auto map(F &&f) const&&;\r\n  template <class F> constexpr auto map(F &&f) const && {\r\n    return optional_map_impl(std::move(*this), std::forward<F>(f));\r\n  }\r\n#else\r\n  /// \\brief Carries out some operation on the stored object if there is one.\r\n  /// \\returns Let `U` be the result of `std::invoke(std::forward<F>(f),\r\n  /// value())`. Returns a `std::optional<U>`. The return value is empty if\r\n  /// `*this` is empty, otherwise an `optional<U>` is constructed from the\r\n  /// return value of `std::invoke(std::forward<F>(f), value())` and is\r\n  /// returned.\r\n  ///\r\n  /// \\group map\r\n  /// \\synopsis template <class F> auto map(F &&f) &;\r\n  template <class F>\r\n  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(std::declval<optional &>(),\r\n                                             std::declval<F &&>()))\r\n  map(F &&f) & {\r\n    return optional_map_impl(*this, std::forward<F>(f));\r\n  }\r\n\r\n  /// \\group map\r\n  /// \\synopsis template <class F> auto map(F &&f) &&;\r\n  template <class F>\r\n  TL_OPTIONAL_11_CONSTEXPR decltype(optional_map_impl(std::declval<optional &&>(),\r\n                                             std::declval<F &&>()))\r\n  map(F &&f) && {\r\n    return optional_map_impl(std::move(*this), std::forward<F>(f));\r\n  }\r\n\r\n  /// \\group map\r\n  /// \\synopsis template <class F> auto map(F &&f) const&;\r\n  template <class F>\r\n  constexpr decltype(optional_map_impl(std::declval<const optional &>(),\r\n                              std::declval<F &&>()))\r\n  map(F &&f) const & {\r\n    return optional_map_impl(*this, std::forward<F>(f));\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group map\r\n  /// \\synopsis template <class F> auto map(F &&f) const&&;\r\n  template <class F>\r\n  constexpr decltype(optional_map_impl(std::declval<const optional &&>(),\r\n                              std::declval<F &&>()))\r\n  map(F &&f) const && {\r\n    return optional_map_impl(std::move(*this), std::forward<F>(f));\r\n  }\r\n#endif\r\n#endif\r\n\r\n  /// \\brief Calls `f` if the optional is empty\r\n  /// \\requires `std::invoke_result_t<F>` must be void or convertible to\r\n  /// `optional<T>`.\r\n  /// \\effects If `*this` has a value, returns `*this`.\r\n  /// Otherwise, if `f` returns `void`, calls `std::forward<F>(f)` and returns\r\n  /// `std::nullopt`. Otherwise, returns `std::forward<F>(f)()`.\r\n  ///\r\n  /// \\group or_else\r\n  /// \\synopsis template <class F> optional<T> or_else (F &&f) &;\r\n  template <class F, detail::enable_if_ret_void<F> * = nullptr>\r\n  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) & {\r\n    if (has_value())\r\n      return *this;\r\n\r\n    std::forward<F>(f)();\r\n    return nullopt;\r\n  }\r\n\r\n  /// \\exclude\r\n  template <class F, detail::disable_if_ret_void<F> * = nullptr>\r\n  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) & {\r\n    return has_value() ? *this : std::forward<F>(f)();\r\n  }\r\n\r\n  /// \\group or_else\r\n  /// \\synopsis template <class F> optional<T> or_else (F &&f) &&;\r\n  template <class F, detail::enable_if_ret_void<F> * = nullptr>\r\n  optional<T> or_else(F &&f) && {\r\n    if (has_value())\r\n      return std::move(*this);\r\n\r\n    std::forward<F>(f)();\r\n    return nullopt;\r\n  }\r\n\r\n  /// \\exclude\r\n  template <class F, detail::disable_if_ret_void<F> * = nullptr>\r\n  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) && {\r\n    return has_value() ? std::move(*this) : std::forward<F>(f)();\r\n  }\r\n\r\n  /// \\group or_else\r\n  /// \\synopsis template <class F> optional<T> or_else (F &&f) const &;\r\n  template <class F, detail::enable_if_ret_void<F> * = nullptr>\r\n  optional<T> or_else(F &&f) const & {\r\n    if (has_value())\r\n      return *this;\r\n\r\n    std::forward<F>(f)();\r\n    return nullopt;\r\n  }\r\n\r\n  /// \\exclude\r\n  template <class F, detail::disable_if_ret_void<F> * = nullptr>\r\n  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) const & {\r\n    return has_value() ? *this : std::forward<F>(f)();\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\exclude\r\n  template <class F, detail::enable_if_ret_void<F> * = nullptr>\r\n  optional<T> or_else(F &&f) const && {\r\n    if (has_value())\r\n      return std::move(*this);\r\n\r\n    std::forward<F>(f)();\r\n    return nullopt;\r\n  }\r\n\r\n  /// \\exclude\r\n  template <class F, detail::disable_if_ret_void<F> * = nullptr>\r\n  optional<T> or_else(F &&f) const && {\r\n    return has_value() ? std::move(*this) : std::forward<F>(f)();\r\n  }\r\n#endif\r\n\r\n  /// \\brief Maps the stored value with `f` if there is one, otherwise returns\r\n  /// `u`.\r\n  ///\r\n  /// \\details If there is a value stored, then `f` is called with `**this`\r\n  /// and the value is returned. Otherwise `u` is returned.\r\n  ///\r\n  /// \\group map_or\r\n  template <class F, class U> U map_or(F &&f, U &&u) & {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : std::forward<U>(u);\r\n  }\r\n\r\n  /// \\group map_or\r\n  template <class F, class U> U map_or(F &&f, U &&u) && {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : std::forward<U>(u);\r\n  }\r\n\r\n  /// \\group map_or\r\n  template <class F, class U> U map_or(F &&f, U &&u) const & {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : std::forward<U>(u);\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group map_or\r\n  template <class F, class U> U map_or(F &&f, U &&u) const && {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : std::forward<U>(u);\r\n  }\r\n#endif\r\n\r\n  /// \\brief Maps the stored value with `f` if there is one, otherwise calls\r\n  /// `u` and returns the result.\r\n  ///\r\n  /// \\details If there is a value stored, then `f` is\r\n  /// called with `**this` and the value is returned. Otherwise\r\n  /// `std::forward<U>(u)()` is returned.\r\n  ///\r\n  /// \\group map_or_else\r\n  /// \\synopsis template <class F, class U>\\nauto map_or_else(F &&f, U &&u) &;\r\n  template <class F, class U>\r\n  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) & {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : std::forward<U>(u)();\r\n  }\r\n\r\n  /// \\group map_or_else\r\n  /// \\synopsis template <class F, class U>\\nauto map_or_else(F &&f, U &&u)\r\n  /// &&;\r\n  template <class F, class U>\r\n  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) && {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : std::forward<U>(u)();\r\n  }\r\n\r\n  /// \\group map_or_else\r\n  /// \\synopsis template <class F, class U>\\nauto map_or_else(F &&f, U &&u)\r\n  /// const &;\r\n  template <class F, class U>\r\n  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) const & {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : std::forward<U>(u)();\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group map_or_else\r\n  /// \\synopsis template <class F, class U>\\nauto map_or_else(F &&f, U &&u)\r\n  /// const &&;\r\n  template <class F, class U>\r\n  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) const && {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : std::forward<U>(u)();\r\n  }\r\n#endif\r\n\r\n  /// \\returns `u` if `*this` has a value, otherwise an empty optional.\r\n  template <class U>\r\n  constexpr optional<typename std::decay<U>::type> conjunction(U &&u) const {\r\n    using result = optional<detail::decay_t<U>>;\r\n    return has_value() ? result{u} : result{nullopt};\r\n  }\r\n\r\n  /// \\returns `rhs` if `*this` is empty, otherwise the current value.\r\n  /// \\group disjunction\r\n  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional &rhs) & {\r\n    return has_value() ? *this : rhs;\r\n  }\r\n\r\n  /// \\group disjunction\r\n  constexpr optional disjunction(const optional &rhs) const & {\r\n    return has_value() ? *this : rhs;\r\n  }\r\n\r\n  /// \\group disjunction\r\n  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional &rhs) && {\r\n    return has_value() ? std::move(*this) : rhs;\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group disjunction\r\n  constexpr optional disjunction(const optional &rhs) const && {\r\n    return has_value() ? std::move(*this) : rhs;\r\n  }\r\n#endif\r\n\r\n  /// \\group disjunction\r\n  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional &&rhs) & {\r\n    return has_value() ? *this : std::move(rhs);\r\n  }\r\n\r\n  /// \\group disjunction\r\n  constexpr optional disjunction(optional &&rhs) const & {\r\n    return has_value() ? *this : std::move(rhs);\r\n  }\r\n\r\n  /// \\group disjunction\r\n  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional &&rhs) && {\r\n    return has_value() ? std::move(*this) : std::move(rhs);\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group disjunction\r\n  constexpr optional disjunction(optional &&rhs) const && {\r\n    return has_value() ? std::move(*this) : std::move(rhs);\r\n  }\r\n#endif\r\n\r\n  /// Takes the value out of the optional, leaving it empty\r\n  /// \\group take\r\n  optional take() & {\r\n    optional ret = *this;\r\n    reset();\r\n    return ret;\r\n  }\r\n\r\n  /// \\group take\r\n  optional take() const & {\r\n    optional ret = *this;\r\n    reset();\r\n    return ret;\r\n  }\r\n\r\n  /// \\group take\r\n  optional take() && {\r\n    optional ret = std::move(*this);\r\n    reset();\r\n    return ret;\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group take\r\n  optional take() const && {\r\n    optional ret = std::move(*this);\r\n    reset();\r\n    return ret;\r\n  }\r\n#endif\r\n\r\n  using value_type = T;\r\n\r\n  /// Constructs an optional that does not contain a value.\r\n  /// \\group ctor_empty\r\n  constexpr optional() noexcept = default;\r\n\r\n  /// \\group ctor_empty\r\n  constexpr optional(nullopt_t) noexcept {}\r\n\r\n  /// Copy constructor\r\n  ///\r\n  /// If `rhs` contains a value, the stored value is direct-initialized with\r\n  /// it. Otherwise, the constructed optional is empty.\r\n  TL_OPTIONAL_11_CONSTEXPR optional(const optional &rhs) = default;\r\n\r\n  /// Move constructor\r\n  ///\r\n  /// If `rhs` contains a value, the stored value is direct-initialized with\r\n  /// it. Otherwise, the constructed optional is empty.\r\n  TL_OPTIONAL_11_CONSTEXPR optional(optional &&rhs) = default;\r\n\r\n  /// Constructs the stored value in-place using the given arguments.\r\n  /// \\group in_place\r\n  /// \\synopsis template <class... Args> constexpr explicit optional(in_place_t, Args&&... args);\r\n  template <class... Args>\r\n  constexpr explicit optional(\r\n      detail::enable_if_t<std::is_constructible<T, Args...>::value, in_place_t>,\r\n      Args &&... args)\r\n      : base(in_place, std::forward<Args>(args)...) {}\r\n\r\n  /// \\group in_place\r\n  /// \\synopsis template <class U, class... Args>\\nconstexpr explicit optional(in_place_t, std::initializer_list<U>&, Args&&... args);\r\n  template <class U, class... Args>\r\n  TL_OPTIONAL_11_CONSTEXPR explicit optional(\r\n      detail::enable_if_t<std::is_constructible<T, std::initializer_list<U> &,\r\n                                                Args &&...>::value,\r\n                          in_place_t>,\r\n      std::initializer_list<U> il, Args &&... args) {\r\n    this->construct(il, std::forward<Args>(args)...);\r\n  }\r\n\r\n  /// Constructs the stored value with `u`.\r\n  /// \\synopsis template <class U=T> constexpr optional(U &&u);\r\n  template <\r\n      class U = T,\r\n      detail::enable_if_t<std::is_convertible<U &&, T>::value> * = nullptr,\r\n      detail::enable_forward_value<T, U> * = nullptr>\r\n  constexpr optional(U &&u) : base(in_place, std::forward<U>(u)) {}\r\n\r\n  /// \\exclude\r\n  template <\r\n      class U = T,\r\n      detail::enable_if_t<!std::is_convertible<U &&, T>::value> * = nullptr,\r\n      detail::enable_forward_value<T, U> * = nullptr>\r\n  constexpr explicit optional(U &&u) : base(in_place, std::forward<U>(u)) {}\r\n\r\n  /// Converting copy constructor.\r\n  /// \\synopsis template <class U> optional(const optional<U> &rhs);\r\n  template <\r\n      class U, detail::enable_from_other<T, U, const U &> * = nullptr,\r\n      detail::enable_if_t<std::is_convertible<const U &, T>::value> * = nullptr>\r\n  optional(const optional<U> &rhs) {\r\n    if (rhs.has_value()) {\r\n      this->construct(*rhs);\r\n    }\r\n  }\r\n\r\n  /// \\exclude\r\n  template <class U, detail::enable_from_other<T, U, const U &> * = nullptr,\r\n            detail::enable_if_t<!std::is_convertible<const U &, T>::value> * =\r\n                nullptr>\r\n  explicit optional(const optional<U> &rhs) {\r\n    if (rhs.has_value()) {\r\n      this->construct(*rhs);\r\n    }\r\n  }\r\n\r\n  /// Converting move constructor.\r\n  /// \\synopsis template <class U> optional(optional<U> &&rhs);\r\n  template <\r\n      class U, detail::enable_from_other<T, U, U &&> * = nullptr,\r\n      detail::enable_if_t<std::is_convertible<U &&, T>::value> * = nullptr>\r\n  optional(optional<U> &&rhs) {\r\n    if (rhs.has_value()) {\r\n      this->construct(std::move(*rhs));\r\n    }\r\n  }\r\n\r\n  /// \\exclude\r\n  template <\r\n      class U, detail::enable_from_other<T, U, U &&> * = nullptr,\r\n      detail::enable_if_t<!std::is_convertible<U &&, T>::value> * = nullptr>\r\n  explicit optional(optional<U> &&rhs) {\r\n    if (rhs.has_value()) {\r\n      this->construct(std::move(*rhs));\r\n    }\r\n  }\r\n\r\n  /// Destroys the stored value if there is one.\r\n  ~optional() = default;\r\n\r\n  /// Assignment to empty.\r\n  ///\r\n  /// Destroys the current value if there is one.\r\n  optional &operator=(nullopt_t) noexcept {\r\n    if (has_value()) {\r\n      this->m_value.~T();\r\n      this->m_has_value = false;\r\n    }\r\n\r\n    return *this;\r\n  }\r\n\r\n  /// Copy assignment.\r\n  ///\r\n  /// Copies the value from `rhs` if there is one. Otherwise resets the stored\r\n  /// value in `*this`.\r\n  optional &operator=(const optional &rhs) = default;\r\n\r\n  /// Move assignment.\r\n  ///\r\n  /// Moves the value from `rhs` if there is one. Otherwise resets the stored\r\n  /// value in `*this`.\r\n  optional &operator=(optional &&rhs) = default;\r\n\r\n  /// Assigns the stored value from `u`, destroying the old value if there was\r\n  /// one.\r\n  /// \\synopsis optional &operator=(U &&u);\r\n  template <class U = T, detail::enable_assign_forward<T, U> * = nullptr>\r\n  optional &operator=(U &&u) {\r\n    if (has_value()) {\r\n      this->m_value = std::forward<U>(u);\r\n    } else {\r\n      this->construct(std::forward<U>(u));\r\n    }\r\n\r\n    return *this;\r\n  }\r\n\r\n  /// Converting copy assignment operator.\r\n  ///\r\n  /// Copies the value from `rhs` if there is one. Otherwise resets the stored\r\n  /// value in `*this`.\r\n  /// \\synopsis optional &operator=(const optional<U> & rhs);\r\n  template <class U,\r\n            detail::enable_assign_from_other<T, U, const U &> * = nullptr>\r\n  optional &operator=(const optional<U> &rhs) {\r\n    if (has_value()) {\r\n      if (rhs.has_value()) {\r\n        this->m_value = *rhs;\r\n      } else {\r\n        this->hard_reset();\r\n      }\r\n    }\r\n\r\n    if (rhs.has_value()) {\r\n      this->construct(*rhs);\r\n    }\r\n\r\n    return *this;\r\n  }\r\n\r\n  // TO-DO check exception guarantee\r\n  /// Converting move assignment operator.\r\n  ///\r\n  /// Moves the value from `rhs` if there is one. Otherwise resets the stored\r\n  /// value in `*this`.\r\n  /// \\synopsis optional &operator=(optional<U> && rhs);\r\n  template <class U, detail::enable_assign_from_other<T, U, U> * = nullptr>\r\n  optional &operator=(optional<U> &&rhs) {\r\n    if (has_value()) {\r\n      if (rhs.has_value()) {\r\n        this->m_value = std::move(*rhs);\r\n      } else {\r\n        this->hard_reset();\r\n      }\r\n    }\r\n\r\n    if (rhs.has_value()) {\r\n      this->construct(std::move(*rhs));\r\n    }\r\n\r\n    return *this;\r\n  }\r\n\r\n  /// Constructs the value in-place, destroying the current one if there is\r\n  /// one.\r\n  /// \\group emplace\r\n  template <class... Args> T &emplace(Args &&... args) {\r\n    static_assert(std::is_constructible<T, Args &&...>::value,\r\n                  \"T must be constructible with Args\");\r\n\r\n    *this = nullopt;\r\n    this->construct(std::forward<Args>(args)...);\r\n    return value();\r\n  }\r\n\r\n  /// \\group emplace\r\n  /// \\synopsis template <class U, class... Args>\\nT& emplace(std::initializer_list<U> il, Args &&... args);\r\n  template <class U, class... Args>\r\n  detail::enable_if_t<\r\n      std::is_constructible<T, std::initializer_list<U> &, Args &&...>::value,\r\n      T &>\r\n  emplace(std::initializer_list<U> il, Args &&... args) {\r\n    *this = nullopt;\r\n    this->construct(il, std::forward<Args>(args)...);\r\n    return value();    \r\n  }\r\n\r\n  /// Swaps this optional with the other.\r\n  ///\r\n  /// If neither optionals have a value, nothing happens.\r\n  /// If both have a value, the values are swapped.\r\n  /// If one has a value, it is moved to the other and the movee is left\r\n  /// valueless.\r\n  void\r\n  swap(optional &rhs) noexcept(std::is_nothrow_move_constructible<T>::value\r\n                                   &&detail::is_nothrow_swappable<T>::value) {\r\n    if (has_value()) {\r\n      if (rhs.has_value()) {\r\n        using std::swap;\r\n        swap(**this, *rhs);\r\n      } else {\r\n        new (std::addressof(rhs.m_value)) T(std::move(this->m_value));\r\n        this->m_value.T::~T();\r\n      }\r\n    } else if (rhs.has_value()) {\r\n      new (std::addressof(this->m_value)) T(std::move(rhs.m_value));\r\n      rhs.m_value.T::~T();\r\n    }\r\n  }\r\n\r\n  /// \\returns a pointer to the stored value\r\n  /// \\requires a value is stored\r\n  /// \\group pointer\r\n  /// \\synopsis constexpr const T *operator->() const;\r\n  constexpr const T *operator->() const {\r\n    return std::addressof(this->m_value);\r\n  }\r\n\r\n  /// \\group pointer\r\n  /// \\synopsis constexpr T *operator->();\r\n  TL_OPTIONAL_11_CONSTEXPR T *operator->() {\r\n    return std::addressof(this->m_value);\r\n  }\r\n\r\n  /// \\returns the stored value\r\n  /// \\requires a value is stored\r\n  /// \\group deref\r\n  /// \\synopsis constexpr T &operator*();\r\n  TL_OPTIONAL_11_CONSTEXPR T &operator*() & { return this->m_value; }\r\n\r\n  /// \\group deref\r\n  /// \\synopsis constexpr const T &operator*() const;\r\n  constexpr const T &operator*() const & { return this->m_value; }\r\n\r\n  /// \\exclude\r\n  TL_OPTIONAL_11_CONSTEXPR T &&operator*() && {\r\n    return std::move(this->m_value);\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\exclude\r\n  constexpr const T &&operator*() const && { return std::move(this->m_value); }\r\n#endif\r\n\r\n  /// \\returns whether or not the optional has a value\r\n  /// \\group has_value\r\n  constexpr bool has_value() const noexcept { return this->m_has_value; }\r\n\r\n  /// \\group has_value\r\n  constexpr explicit operator bool() const noexcept {\r\n    return this->m_has_value;\r\n  }\r\n\r\n  /// \\returns the contained value if there is one, otherwise throws\r\n  /// [bad_optional_access]\r\n  /// \\group value\r\n  /// \\synopsis constexpr T &value();\r\n  TL_OPTIONAL_11_CONSTEXPR T &value() & {\r\n    if (has_value())\r\n      return this->m_value;\r\n    throw bad_optional_access();\r\n  }\r\n  /// \\group value\r\n  /// \\synopsis constexpr const T &value() const;\r\n  TL_OPTIONAL_11_CONSTEXPR const T &value() const & {\r\n    if (has_value())\r\n      return this->m_value;\r\n    throw bad_optional_access();\r\n  }\r\n  /// \\exclude\r\n  TL_OPTIONAL_11_CONSTEXPR T &&value() && {\r\n    if (has_value())\r\n      return std::move(this->m_value);\r\n    throw bad_optional_access();\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\exclude\r\n  TL_OPTIONAL_11_CONSTEXPR const T &&value() const && {\r\n    if (has_value())\r\n      return std::move(this->m_value);\r\n    throw bad_optional_access();\r\n  }\r\n#endif\r\n\r\n  /// \\returns the stored value if there is one, otherwise returns `u`\r\n  /// \\group value_or\r\n  template <class U> constexpr T value_or(U &&u) const & {\r\n    static_assert(std::is_copy_constructible<T>::value &&\r\n                      std::is_convertible<U &&, T>::value,\r\n                  \"T must be copy constructible and convertible from U\");\r\n    return has_value() ? **this : static_cast<T>(std::forward<U>(u));\r\n  }\r\n\r\n  /// \\group value_or\r\n  template <class U> TL_OPTIONAL_11_CONSTEXPR T value_or(U &&u) && {\r\n    static_assert(std::is_move_constructible<T>::value &&\r\n                      std::is_convertible<U &&, T>::value,\r\n                  \"T must be move constructible and convertible from U\");\r\n    return has_value() ? **this : static_cast<T>(std::forward<U>(u));\r\n  }\r\n\r\n  /// Destroys the stored value if one exists, making the optional empty\r\n  void reset() noexcept {\r\n    if (has_value()) {\r\n      this->m_value.~T();\r\n      this->m_has_value = false;\r\n    }\r\n  }\r\n}; // namespace tl\r\n\r\n/// \\group relop\r\n/// \\brief Compares two optional objects\r\n/// \\details If both optionals contain a value, they are compared with `T`s\r\n/// relational operators. Otherwise `lhs` and `rhs` are equal only if they are\r\n/// both empty, and `lhs` is less than `rhs` only if `rhs` is empty and `lhs`\r\n/// is not.\r\ntemplate <class T, class U>\r\ninline constexpr bool operator==(const optional<T> &lhs,\r\n                                 const optional<U> &rhs) {\r\n  return lhs.has_value() == rhs.has_value() &&\r\n         (!lhs.has_value() || *lhs == *rhs);\r\n}\r\n/// \\group relop\r\ntemplate <class T, class U>\r\ninline constexpr bool operator!=(const optional<T> &lhs,\r\n                                 const optional<U> &rhs) {\r\n  return lhs.has_value() != rhs.has_value() ||\r\n         (lhs.has_value() && *lhs != *rhs);\r\n}\r\n/// \\group relop\r\ntemplate <class T, class U>\r\ninline constexpr bool operator<(const optional<T> &lhs,\r\n                                const optional<U> &rhs) {\r\n  return rhs.has_value() && (!lhs.has_value() || *lhs < *rhs);\r\n}\r\n/// \\group relop\r\ntemplate <class T, class U>\r\ninline constexpr bool operator>(const optional<T> &lhs,\r\n                                const optional<U> &rhs) {\r\n  return lhs.has_value() && (!rhs.has_value() || *lhs > *rhs);\r\n}\r\n/// \\group relop\r\ntemplate <class T, class U>\r\ninline constexpr bool operator<=(const optional<T> &lhs,\r\n                                 const optional<U> &rhs) {\r\n  return !lhs.has_value() || (rhs.has_value() && *lhs <= *rhs);\r\n}\r\n/// \\group relop\r\ntemplate <class T, class U>\r\ninline constexpr bool operator>=(const optional<T> &lhs,\r\n                                 const optional<U> &rhs) {\r\n  return !rhs.has_value() || (lhs.has_value() && *lhs >= *rhs);\r\n}\r\n\r\n/// \\group relop_nullopt\r\n/// \\brief Compares an optional to a `nullopt`\r\n/// \\details Equivalent to comparing the optional to an empty optional\r\ntemplate <class T>\r\ninline constexpr bool operator==(const optional<T> &lhs, nullopt_t) noexcept {\r\n  return !lhs.has_value();\r\n}\r\n/// \\group relop_nullopt\r\ntemplate <class T>\r\ninline constexpr bool operator==(nullopt_t, const optional<T> &rhs) noexcept {\r\n  return !rhs.has_value();\r\n}\r\n/// \\group relop_nullopt\r\ntemplate <class T>\r\ninline constexpr bool operator!=(const optional<T> &lhs, nullopt_t) noexcept {\r\n  return lhs.has_value();\r\n}\r\n/// \\group relop_nullopt\r\ntemplate <class T>\r\ninline constexpr bool operator!=(nullopt_t, const optional<T> &rhs) noexcept {\r\n  return rhs.has_value();\r\n}\r\n/// \\group relop_nullopt\r\ntemplate <class T>\r\ninline constexpr bool operator<(const optional<T> &, nullopt_t) noexcept {\r\n  return false;\r\n}\r\n/// \\group relop_nullopt\r\ntemplate <class T>\r\ninline constexpr bool operator<(nullopt_t, const optional<T> &rhs) noexcept {\r\n  return rhs.has_value();\r\n}\r\n/// \\group relop_nullopt\r\ntemplate <class T>\r\ninline constexpr bool operator<=(const optional<T> &lhs, nullopt_t) noexcept {\r\n  return !lhs.has_value();\r\n}\r\n/// \\group relop_nullopt\r\ntemplate <class T>\r\ninline constexpr bool operator<=(nullopt_t, const optional<T> &) noexcept {\r\n  return true;\r\n}\r\n/// \\group relop_nullopt\r\ntemplate <class T>\r\ninline constexpr bool operator>(const optional<T> &lhs, nullopt_t) noexcept {\r\n  return lhs.has_value();\r\n}\r\n/// \\group relop_nullopt\r\ntemplate <class T>\r\ninline constexpr bool operator>(nullopt_t, const optional<T> &) noexcept {\r\n  return false;\r\n}\r\n/// \\group relop_nullopt\r\ntemplate <class T>\r\ninline constexpr bool operator>=(const optional<T> &, nullopt_t) noexcept {\r\n  return true;\r\n}\r\n/// \\group relop_nullopt\r\ntemplate <class T>\r\ninline constexpr bool operator>=(nullopt_t, const optional<T> &rhs) noexcept {\r\n  return !rhs.has_value();\r\n}\r\n\r\n/// \\group relop_t\r\n/// \\brief Compares the optional with a value.\r\n/// \\details If the optional has a value, it is compared with the other value\r\n/// using `T`s relational operators. Otherwise, the optional is considered\r\n/// less than the value.\r\ntemplate <class T, class U>\r\ninline constexpr bool operator==(const optional<T> &lhs, const U &rhs) {\r\n  return lhs.has_value() ? *lhs == rhs : false;\r\n}\r\n/// \\group relop_t\r\ntemplate <class T, class U>\r\ninline constexpr bool operator==(const U &lhs, const optional<T> &rhs) {\r\n  return rhs.has_value() ? lhs == *rhs : false;\r\n}\r\n/// \\group relop_t\r\ntemplate <class T, class U>\r\ninline constexpr bool operator!=(const optional<T> &lhs, const U &rhs) {\r\n  return lhs.has_value() ? *lhs != rhs : true;\r\n}\r\n/// \\group relop_t\r\ntemplate <class T, class U>\r\ninline constexpr bool operator!=(const U &lhs, const optional<T> &rhs) {\r\n  return rhs.has_value() ? lhs != *rhs : true;\r\n}\r\n/// \\group relop_t\r\ntemplate <class T, class U>\r\ninline constexpr bool operator<(const optional<T> &lhs, const U &rhs) {\r\n  return lhs.has_value() ? *lhs < rhs : true;\r\n}\r\n/// \\group relop_t\r\ntemplate <class T, class U>\r\ninline constexpr bool operator<(const U &lhs, const optional<T> &rhs) {\r\n  return rhs.has_value() ? lhs < *rhs : false;\r\n}\r\n/// \\group relop_t\r\ntemplate <class T, class U>\r\ninline constexpr bool operator<=(const optional<T> &lhs, const U &rhs) {\r\n  return lhs.has_value() ? *lhs <= rhs : true;\r\n}\r\n/// \\group relop_t\r\ntemplate <class T, class U>\r\ninline constexpr bool operator<=(const U &lhs, const optional<T> &rhs) {\r\n  return rhs.has_value() ? lhs <= *rhs : false;\r\n}\r\n/// \\group relop_t\r\ntemplate <class T, class U>\r\ninline constexpr bool operator>(const optional<T> &lhs, const U &rhs) {\r\n  return lhs.has_value() ? *lhs > rhs : false;\r\n}\r\n/// \\group relop_t\r\ntemplate <class T, class U>\r\ninline constexpr bool operator>(const U &lhs, const optional<T> &rhs) {\r\n  return rhs.has_value() ? lhs > *rhs : true;\r\n}\r\n/// \\group relop_t\r\ntemplate <class T, class U>\r\ninline constexpr bool operator>=(const optional<T> &lhs, const U &rhs) {\r\n  return lhs.has_value() ? *lhs >= rhs : false;\r\n}\r\n/// \\group relop_t\r\ntemplate <class T, class U>\r\ninline constexpr bool operator>=(const U &lhs, const optional<T> &rhs) {\r\n  return rhs.has_value() ? lhs >= *rhs : true;\r\n}\r\n\r\n/// \\synopsis template <class T>\\nvoid swap(optional<T> &lhs, optional<T> &rhs);\r\ntemplate <class T,\r\n          detail::enable_if_t<std::is_move_constructible<T>::value> * = nullptr,\r\n          detail::enable_if_t<detail::is_swappable<T>::value> * = nullptr>\r\nvoid swap(optional<T> &lhs,\r\n          optional<T> &rhs) noexcept(noexcept(lhs.swap(rhs))) {\r\n  return lhs.swap(rhs);\r\n}\r\n\r\nnamespace detail {\r\nstruct i_am_secret {};\r\n} // namespace detail\r\n\r\ntemplate <class T = detail::i_am_secret, class U,\r\n          class Ret =\r\n              detail::conditional_t<std::is_same<T, detail::i_am_secret>::value,\r\n                                    detail::decay_t<U>, T>>\r\ninline constexpr optional<Ret> make_optional(U &&v) {\r\n  return optional<Ret>(std::forward<U>(v));\r\n}\r\n\r\ntemplate <class T, class... Args>\r\ninline constexpr optional<T> make_optional(Args &&... args) {\r\n  return optional<T>(in_place, std::forward<Args>(args)...);\r\n}\r\ntemplate <class T, class U, class... Args>\r\ninline constexpr optional<T> make_optional(std::initializer_list<U> il,\r\n                                           Args &&... args) {\r\n  return optional<T>(in_place, il, std::forward<Args>(args)...);\r\n}\r\n\r\n#if __cplusplus >= 201703L\r\ntemplate <class T> optional(T)->optional<T>;\r\n#endif\r\n\r\n/// \\exclude\r\nnamespace detail {\r\n#ifdef TL_OPTIONAL_CXX14\r\ntemplate <class Opt, class F,\r\n          class Ret = decltype(detail::invoke(std::declval<F>(),\r\n                                              *std::declval<Opt>())),\r\n          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>\r\nconstexpr auto optional_map_impl(Opt &&opt, F &&f) {\r\n  return opt.has_value()\r\n             ? detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt))\r\n             : optional<Ret>(nullopt);\r\n}\r\n\r\ntemplate <class Opt, class F,\r\n          class Ret = decltype(detail::invoke(std::declval<F>(),\r\n                                              *std::declval<Opt>())),\r\n          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>\r\nauto optional_map_impl(Opt &&opt, F &&f) {\r\n  if (opt.has_value()) {\r\n    detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt));\r\n    return make_optional(monostate{});\r\n  }\r\n\r\n  return optional<monostate>(nullopt);\r\n}\r\n#else\r\ntemplate <class Opt, class F,\r\n          class Ret = decltype(detail::invoke(std::declval<F>(),\r\n                                              *std::declval<Opt>())),\r\n          detail::enable_if_t<!std::is_void<Ret>::value> * = nullptr>\r\n\r\nconstexpr auto optional_map_impl(Opt &&opt, F &&f) -> optional<Ret> {\r\n  return opt.has_value()\r\n             ? detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt))\r\n             : optional<Ret>(nullopt);\r\n}\r\n\r\ntemplate <class Opt, class F,\r\n          class Ret = decltype(detail::invoke(std::declval<F>(),\r\n                                              *std::declval<Opt>())),\r\n          detail::enable_if_t<std::is_void<Ret>::value> * = nullptr>\r\n\r\nauto optional_map_impl(Opt &&opt, F &&f) -> optional<monostate> {\r\n  if (opt.has_value()) {\r\n    detail::invoke(std::forward<F>(f), *std::forward<Opt>(opt));\r\n    return monostate{};\r\n  }\r\n\r\n  return nullopt;\r\n}\r\n#endif\r\n} // namespace detail\r\n\r\n/// Specialization for when `T` is a reference. `optional<T&>` acts similarly\r\n/// to a `T*`, but provides more operations and shows intent more clearly.\r\n///\r\n/// *Examples*:\r\n///\r\n/// ```\r\n/// int i = 42;\r\n/// tl::optional<int&> o = i;\r\n/// *o == 42; //true\r\n/// i = 12;\r\n/// *o = 12; //true\r\n/// &*o == &i; //true\r\n/// ```\r\n///\r\n/// Assignment has rebind semantics rather than assign-through semantics:\r\n///\r\n/// ```\r\n/// int j = 8;\r\n/// o = j;\r\n///\r\n/// &*o == &j; //true\r\n/// ```\r\ntemplate <class T> class optional<T &> {\r\npublic:\r\n// The different versions for C++14 and 11 are needed because deduced return\r\n// types are not SFINAE-safe. This provides better support for things like\r\n// generic lambdas. C.f.\r\n// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0826r0.html\r\n#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \\\r\n    !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)\r\n  /// \\group and_then\r\n  /// Carries out some operation which returns an optional on the stored\r\n  /// object if there is one. \\requires `std::invoke(std::forward<F>(f),\r\n  /// value())` returns a `std::optional<U>` for some `U`. \\returns Let `U` be\r\n  /// the result of `std::invoke(std::forward<F>(f), value())`. Returns a\r\n  /// `std::optional<U>`. The return value is empty if `*this` is empty,\r\n  /// otherwise the return value of `std::invoke(std::forward<F>(f), value())`\r\n  /// is returned.\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) &;\r\n  template <class F> TL_OPTIONAL_11_CONSTEXPR auto and_then(F &&f) & {\r\n    using result = detail::invoke_result_t<F, T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) &&;\r\n  template <class F> TL_OPTIONAL_11_CONSTEXPR auto and_then(F &&f) && {\r\n    using result = detail::invoke_result_t<F, T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) const &;\r\n  template <class F> constexpr auto and_then(F &&f) const & {\r\n    using result = detail::invoke_result_t<F, const T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) const &&;\r\n  template <class F> constexpr auto and_then(F &&f) const && {\r\n    using result = detail::invoke_result_t<F, const T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n#endif\r\n#else\r\n  /// \\group and_then\r\n  /// Carries out some operation which returns an optional on the stored\r\n  /// object if there is one. \\requires `std::invoke(std::forward<F>(f),\r\n  /// value())` returns a `std::optional<U>` for some `U`. \\returns Let `U` be\r\n  /// the result of `std::invoke(std::forward<F>(f), value())`. Returns a\r\n  /// `std::optional<U>`. The return value is empty if `*this` is empty,\r\n  /// otherwise the return value of `std::invoke(std::forward<F>(f), value())`\r\n  /// is returned.\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) &;\r\n  template <class F>\r\n  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T &> and_then(F &&f) & {\r\n    using result = detail::invoke_result_t<F, T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) &&;\r\n  template <class F>\r\n  TL_OPTIONAL_11_CONSTEXPR detail::invoke_result_t<F, T &> and_then(F &&f) && {\r\n    using result = detail::invoke_result_t<F, T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) const &;\r\n  template <class F>\r\n  constexpr detail::invoke_result_t<F, const T &> and_then(F &&f) const & {\r\n    using result = detail::invoke_result_t<F, const T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group and_then\r\n  /// \\synopsis template <class F>\\nconstexpr auto and_then(F &&f) const &&;\r\n  template <class F>\r\n  constexpr detail::invoke_result_t<F, const T &> and_then(F &&f) const && {\r\n    using result = detail::invoke_result_t<F, const T &>;\r\n    static_assert(detail::is_optional<result>::value,\r\n                  \"F must return an optional\");\r\n\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : result(nullopt);\r\n  }\r\n#endif\r\n#endif\r\n\r\n#if defined(TL_OPTIONAL_CXX14) && !defined(TL_OPTIONAL_GCC49) &&               \\\r\n    !defined(TL_OPTIONAL_GCC54) && !defined(TL_OPTIONAL_GCC55)\r\n  /// \\brief Carries out some operation on the stored object if there is one.\r\n  /// \\returns Let `U` be the result of `std::invoke(std::forward<F>(f),\r\n  /// value())`. Returns a `std::optional<U>`. The return value is empty if\r\n  /// `*this` is empty, otherwise an `optional<U>` is constructed from the\r\n  /// return value of `std::invoke(std::forward<F>(f), value())` and is\r\n  /// returned.\r\n  ///\r\n  /// \\group map\r\n  /// \\synopsis template <class F> constexpr auto map(F &&f) &;\r\n  template <class F> TL_OPTIONAL_11_CONSTEXPR auto map(F &&f) & {\r\n    return detail::optional_map_impl(*this, std::forward<F>(f));\r\n  }\r\n\r\n  /// \\group map\r\n  /// \\synopsis template <class F> constexpr auto map(F &&f) &&;\r\n  template <class F> TL_OPTIONAL_11_CONSTEXPR auto map(F &&f) && {\r\n    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));\r\n  }\r\n\r\n  /// \\group map\r\n  /// \\synopsis template <class F> constexpr auto map(F &&f) const&;\r\n  template <class F> constexpr auto map(F &&f) const & {\r\n    return detail::optional_map_impl(*this, std::forward<F>(f));\r\n  }\r\n\r\n  /// \\group map\r\n  /// \\synopsis template <class F> constexpr auto map(F &&f) const&&;\r\n  template <class F> constexpr auto map(F &&f) const && {\r\n    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));\r\n  }\r\n#else\r\n  /// \\brief Carries out some operation on the stored object if there is one.\r\n  /// \\returns Let `U` be the result of `std::invoke(std::forward<F>(f),\r\n  /// value())`. Returns a `std::optional<U>`. The return value is empty if\r\n  /// `*this` is empty, otherwise an `optional<U>` is constructed from the\r\n  /// return value of `std::invoke(std::forward<F>(f), value())` and is\r\n  /// returned.\r\n  ///\r\n  /// \\group map\r\n  /// \\synopsis template <class F> auto map(F &&f) &;\r\n  template <class F>\r\n  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(std::declval<optional &>(),\r\n                                                     std::declval<F &&>()))\r\n  map(F &&f) & {\r\n    return detail::optional_map_impl(*this, std::forward<F>(f));\r\n  }\r\n\r\n  /// \\group map\r\n  /// \\synopsis template <class F> auto map(F &&f) &&;\r\n  template <class F>\r\n  TL_OPTIONAL_11_CONSTEXPR decltype(detail::optional_map_impl(std::declval<optional &&>(),\r\n                                                     std::declval<F &&>()))\r\n  map(F &&f) && {\r\n    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));\r\n  }\r\n\r\n  /// \\group map\r\n  /// \\synopsis template <class F> auto map(F &&f) const&;\r\n  template <class F>\r\n  constexpr decltype(detail::optional_map_impl(std::declval<const optional &>(),\r\n                                      std::declval<F &&>()))\r\n  map(F &&f) const & {\r\n    return detail::optional_map_impl(*this, std::forward<F>(f));\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group map\r\n  /// \\synopsis template <class F> auto map(F &&f) const&&;\r\n  template <class F>\r\n  constexpr decltype(detail::optional_map_impl(std::declval<const optional &&>(),\r\n                                      std::declval<F &&>()))\r\n  map(F &&f) const && {\r\n    return detail::optional_map_impl(std::move(*this), std::forward<F>(f));\r\n  }\r\n#endif\r\n#endif\r\n\r\n  /// \\brief Calls `f` if the optional is empty\r\n  /// \\requires `std::invoke_result_t<F>` must be void or convertible to\r\n  /// `optional<T>`. \\effects If `*this` has a value, returns `*this`.\r\n  /// Otherwise, if `f` returns `void`, calls `std::forward<F>(f)` and returns\r\n  /// `std::nullopt`. Otherwise, returns `std::forward<F>(f)()`.\r\n  ///\r\n  /// \\group or_else\r\n  /// \\synopsis template <class F> optional<T> or_else (F &&f) &;\r\n  template <class F, detail::enable_if_ret_void<F> * = nullptr>\r\n  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) & {\r\n    if (has_value())\r\n      return *this;\r\n\r\n    std::forward<F>(f)();\r\n    return nullopt;\r\n  }\r\n\r\n  /// \\exclude\r\n  template <class F, detail::disable_if_ret_void<F> * = nullptr>\r\n  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) & {\r\n    return has_value() ? *this : std::forward<F>(f)();\r\n  }\r\n\r\n  /// \\group or_else\r\n  /// \\synopsis template <class F> optional<T> or_else (F &&f) &&;\r\n  template <class F, detail::enable_if_ret_void<F> * = nullptr>\r\n  optional<T> or_else(F &&f) && {\r\n    if (has_value())\r\n      return std::move(*this);\r\n\r\n    std::forward<F>(f)();\r\n    return nullopt;\r\n  }\r\n\r\n  /// \\exclude\r\n  template <class F, detail::disable_if_ret_void<F> * = nullptr>\r\n  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) && {\r\n    return has_value() ? std::move(*this) : std::forward<F>(f)();\r\n  }\r\n\r\n  /// \\group or_else\r\n  /// \\synopsis template <class F> optional<T> or_else (F &&f) const &;\r\n  template <class F, detail::enable_if_ret_void<F> * = nullptr>\r\n  optional<T> or_else(F &&f) const & {\r\n    if (has_value())\r\n      return *this;\r\n\r\n    std::forward<F>(f)();\r\n    return nullopt;\r\n  }\r\n\r\n  /// \\exclude\r\n  template <class F, detail::disable_if_ret_void<F> * = nullptr>\r\n  optional<T> TL_OPTIONAL_11_CONSTEXPR or_else(F &&f) const & {\r\n    return has_value() ? *this : std::forward<F>(f)();\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\exclude\r\n  template <class F, detail::enable_if_ret_void<F> * = nullptr>\r\n  optional<T> or_else(F &&f) const && {\r\n    if (has_value())\r\n      return std::move(*this);\r\n\r\n    std::forward<F>(f)();\r\n    return nullopt;\r\n  }\r\n\r\n  /// \\exclude\r\n  template <class F, detail::disable_if_ret_void<F> * = nullptr>\r\n  optional<T> or_else(F &&f) const && {\r\n    return has_value() ? std::move(*this) : std::forward<F>(f)();\r\n  }\r\n#endif\r\n\r\n  /// \\brief Maps the stored value with `f` if there is one, otherwise returns\r\n  /// `u`.\r\n  ///\r\n  /// \\details If there is a value stored, then `f` is called with `**this`\r\n  /// and the value is returned. Otherwise `u` is returned.\r\n  ///\r\n  /// \\group map_or\r\n  template <class F, class U> U map_or(F &&f, U &&u) & {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : std::forward<U>(u);\r\n  }\r\n\r\n  /// \\group map_or\r\n  template <class F, class U> U map_or(F &&f, U &&u) && {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : std::forward<U>(u);\r\n  }\r\n\r\n  /// \\group map_or\r\n  template <class F, class U> U map_or(F &&f, U &&u) const & {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : std::forward<U>(u);\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group map_or\r\n  template <class F, class U> U map_or(F &&f, U &&u) const && {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : std::forward<U>(u);\r\n  }\r\n#endif\r\n\r\n  /// \\brief Maps the stored value with `f` if there is one, otherwise calls\r\n  /// `u` and returns the result.\r\n  ///\r\n  /// \\details If there is a value stored, then `f` is\r\n  /// called with `**this` and the value is returned. Otherwise\r\n  /// `std::forward<U>(u)()` is returned.\r\n  ///\r\n  /// \\group map_or_else\r\n  /// \\synopsis template <class F, class U>\\nauto map_or_else(F &&f, U &&u) &;\r\n  template <class F, class U>\r\n  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) & {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : std::forward<U>(u)();\r\n  }\r\n\r\n  /// \\group map_or_else\r\n  /// \\synopsis template <class F, class U>\\nauto map_or_else(F &&f, U &&u)\r\n  /// &&;\r\n  template <class F, class U>\r\n  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) && {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : std::forward<U>(u)();\r\n  }\r\n\r\n  /// \\group map_or_else\r\n  /// \\synopsis template <class F, class U>\\nauto map_or_else(F &&f, U &&u)\r\n  /// const &;\r\n  template <class F, class U>\r\n  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) const & {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), **this)\r\n                       : std::forward<U>(u)();\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group map_or_else\r\n  /// \\synopsis template <class F, class U>\\nauto map_or_else(F &&f, U &&u)\r\n  /// const &&;\r\n  template <class F, class U>\r\n  detail::invoke_result_t<U> map_or_else(F &&f, U &&u) const && {\r\n    return has_value() ? detail::invoke(std::forward<F>(f), std::move(**this))\r\n                       : std::forward<U>(u)();\r\n  }\r\n#endif\r\n\r\n  /// \\returns `u` if `*this` has a value, otherwise an empty optional.\r\n  template <class U>\r\n  constexpr optional<typename std::decay<U>::type> conjunction(U &&u) const {\r\n    using result = optional<detail::decay_t<U>>;\r\n    return has_value() ? result{u} : result{nullopt};\r\n  }\r\n\r\n  /// \\returns `rhs` if `*this` is empty, otherwise the current value.\r\n  /// \\group disjunction\r\n  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional &rhs) & {\r\n    return has_value() ? *this : rhs;\r\n  }\r\n\r\n  /// \\group disjunction\r\n  constexpr optional disjunction(const optional &rhs) const & {\r\n    return has_value() ? *this : rhs;\r\n  }\r\n\r\n  /// \\group disjunction\r\n  TL_OPTIONAL_11_CONSTEXPR optional disjunction(const optional &rhs) && {\r\n    return has_value() ? std::move(*this) : rhs;\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group disjunction\r\n  constexpr optional disjunction(const optional &rhs) const && {\r\n    return has_value() ? std::move(*this) : rhs;\r\n  }\r\n#endif\r\n\r\n  /// \\group disjunction\r\n  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional &&rhs) & {\r\n    return has_value() ? *this : std::move(rhs);\r\n  }\r\n\r\n  /// \\group disjunction\r\n  constexpr optional disjunction(optional &&rhs) const & {\r\n    return has_value() ? *this : std::move(rhs);\r\n  }\r\n\r\n  /// \\group disjunction\r\n  TL_OPTIONAL_11_CONSTEXPR optional disjunction(optional &&rhs) && {\r\n    return has_value() ? std::move(*this) : std::move(rhs);\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group disjunction\r\n  constexpr optional disjunction(optional &&rhs) const && {\r\n    return has_value() ? std::move(*this) : std::move(rhs);\r\n  }\r\n#endif\r\n\r\n  /// Takes the value out of the optional, leaving it empty\r\n  /// \\group take\r\n  optional take() & {\r\n    optional ret = *this;\r\n    reset();\r\n    return ret;\r\n  }\r\n\r\n  /// \\group take\r\n  optional take() const & {\r\n    optional ret = *this;\r\n    reset();\r\n    return ret;\r\n  }\r\n\r\n  /// \\group take\r\n  optional take() && {\r\n    optional ret = std::move(*this);\r\n    reset();\r\n    return ret;\r\n  }\r\n\r\n#ifndef TL_OPTIONAL_NO_CONSTRR\r\n  /// \\group take\r\n  optional take() const && {\r\n    optional ret = std::move(*this);\r\n    reset();\r\n    return ret;\r\n  }\r\n#endif\r\n\r\n  using value_type = T &;\r\n\r\n  /// Constructs an optional that does not contain a value.\r\n  /// \\group ctor_empty\r\n  constexpr optional() noexcept : m_value(nullptr) {}\r\n\r\n  /// \\group ctor_empty\r\n  constexpr optional(nullopt_t) noexcept : m_value(nullptr) {}\r\n\r\n  /// Copy constructor\r\n  ///\r\n  /// If `rhs` contains a value, the stored value is direct-initialized with\r\n  /// it. Otherwise, the constructed optional is empty.\r\n  TL_OPTIONAL_11_CONSTEXPR optional(const optional &rhs) noexcept = default;\r\n\r\n  /// Move constructor\r\n  ///\r\n  /// If `rhs` contains a value, the stored value is direct-initialized with\r\n  /// it. Otherwise, the constructed optional is empty.\r\n  TL_OPTIONAL_11_CONSTEXPR optional(optional &&rhs) = default;\r\n\r\n  /// Constructs the stored value with `u`.\r\n  /// \\synopsis template <class U=T> constexpr optional(U &&u);\r\n  template <class U = T,\r\n            detail::enable_if_t<!detail::is_optional<detail::decay_t<U>>::value>\r\n                * = nullptr>\r\n  constexpr optional(U &&u) : m_value(std::addressof(u)) {\r\n    static_assert(std::is_lvalue_reference<U>::value, \"U must be an lvalue\");\r\n  }\r\n\r\n  /// \\exclude\r\n  template <class U>\r\n  constexpr explicit optional(const optional<U> &rhs) : optional(*rhs) {}\r\n\r\n  /// No-op\r\n  ~optional() = default;\r\n\r\n  /// Assignment to empty.\r\n  ///\r\n  /// Destroys the current value if there is one.\r\n  optional &operator=(nullopt_t) noexcept {\r\n    m_value = nullptr;\r\n    return *this;\r\n  }\r\n\r\n  /// Copy assignment.\r\n  ///\r\n  /// Rebinds this optional to the referee of `rhs` if there is one. Otherwise\r\n  /// resets the stored value in `*this`.\r\n  optional &operator=(const optional &rhs) = default;\r\n\r\n  /// Rebinds this optional to `u`.\r\n  ///\r\n  /// \\requires `U` must be an lvalue reference.\r\n  /// \\synopsis optional &operator=(U &&u);\r\n  template <class U = T,\r\n            detail::enable_if_t<!detail::is_optional<detail::decay_t<U>>::value>\r\n                * = nullptr>\r\n  optional &operator=(U &&u) {\r\n    static_assert(std::is_lvalue_reference<U>::value, \"U must be an lvalue\");\r\n    m_value = std::addressof(u);\r\n    return *this;\r\n  }\r\n\r\n  /// Converting copy assignment operator.\r\n  ///\r\n  /// Rebinds this optional to the referee of `rhs` if there is one. Otherwise\r\n  /// resets the stored value in `*this`.\r\n  template <class U> optional &operator=(const optional<U> &rhs) {\r\n    m_value = std::addressof(rhs.value());\r\n    return *this;\r\n  }\r\n\r\n  /// Constructs the value in-place, destroying the current one if there is\r\n  /// one.\r\n  ///\r\n  /// \\group emplace\r\n  template <class... Args> T &emplace(Args &&... args) noexcept {\r\n    static_assert(std::is_constructible<T, Args &&...>::value,\r\n                  \"T must be constructible with Args\");\r\n\r\n    *this = nullopt;\r\n    this->construct(std::forward<Args>(args)...);\r\n    return value();\r\n  }\r\n\r\n  /// Swaps this optional with the other.\r\n  ///\r\n  /// If neither optionals have a value, nothing happens.\r\n  /// If both have a value, the values are swapped.\r\n  /// If one has a value, it is moved to the other and the movee is left\r\n  /// valueless.\r\n  void swap(optional &rhs) noexcept { std::swap(m_value, rhs.m_value); }\r\n\r\n  /// \\returns a pointer to the stored value\r\n  /// \\requires a value is stored\r\n  /// \\group pointer\r\n  /// \\synopsis constexpr const T *operator->() const;\r\n  constexpr const T *operator->() const { return m_value; }\r\n\r\n  /// \\group pointer\r\n  /// \\synopsis constexpr T *operator->();\r\n  TL_OPTIONAL_11_CONSTEXPR T *operator->() { return m_value; }\r\n\r\n  /// \\returns the stored value\r\n  /// \\requires a value is stored\r\n  /// \\group deref\r\n  /// \\synopsis constexpr T &operator*();\r\n  TL_OPTIONAL_11_CONSTEXPR T &operator*() { return *m_value; }\r\n\r\n  /// \\group deref\r\n  /// \\synopsis constexpr const T &operator*() const;\r\n  constexpr const T &operator*() const { return *m_value; }\r\n\r\n  /// \\returns whether or not the optional has a value\r\n  /// \\group has_value\r\n  constexpr bool has_value() const noexcept { return m_value != nullptr; }\r\n\r\n  /// \\group has_value\r\n  constexpr explicit operator bool() const noexcept {\r\n    return m_value != nullptr;\r\n  }\r\n\r\n  /// \\returns the contained value if there is one, otherwise throws\r\n  /// [bad_optional_access]\r\n  /// \\group value\r\n  /// synopsis constexpr T &value();\r\n  TL_OPTIONAL_11_CONSTEXPR T &value() {\r\n    if (has_value())\r\n      return *m_value;\r\n    throw bad_optional_access();\r\n  }\r\n  /// \\group value\r\n  /// \\synopsis constexpr const T &value() const;\r\n  TL_OPTIONAL_11_CONSTEXPR const T &value() const {\r\n    if (has_value())\r\n      return *m_value;\r\n    throw bad_optional_access();\r\n  }\r\n\r\n  /// \\returns the stored value if there is one, otherwise returns `u`\r\n  /// \\group value_or\r\n  template <class U> constexpr T value_or(U &&u) const & {\r\n    static_assert(std::is_copy_constructible<T>::value &&\r\n                      std::is_convertible<U &&, T>::value,\r\n                  \"T must be copy constructible and convertible from U\");\r\n    return has_value() ? **this : static_cast<T>(std::forward<U>(u));\r\n  }\r\n\r\n  /// \\group value_or\r\n  template <class U> TL_OPTIONAL_11_CONSTEXPR T value_or(U &&u) && {\r\n    static_assert(std::is_move_constructible<T>::value &&\r\n                      std::is_convertible<U &&, T>::value,\r\n                  \"T must be move constructible and convertible from U\");\r\n    return has_value() ? **this : static_cast<T>(std::forward<U>(u));\r\n  }\r\n\r\n  /// Destroys the stored value if one exists, making the optional empty\r\n  void reset() noexcept { m_value = nullptr; }\r\n\r\nprivate:\r\n  T *m_value;\r\n}; // namespace tl\r\n\r\n\r\n\r\n} // namespace tl\r\n\r\nnamespace std {\r\n// TO-DO SFINAE\r\ntemplate <class T> struct hash<tl::optional<T>> {\r\n  ::std::size_t operator()(const tl::optional<T> &o) const {\r\n    if (!o.has_value())\r\n      return 0;\r\n\r\n    return std::hash<tl::detail::remove_const_t<T>>()(*o);\r\n  }\r\n};\r\n} // namespace std\r\n\r\n#endif\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RD/thirdparty/optional/tl/optional.hpp b/Plugins/Developer/RiderLink/Source/RD/thirdparty/optional/tl/optional.hpp
--- a/Plugins/Developer/RiderLink/Source/RD/thirdparty/optional/tl/optional.hpp	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RD/thirdparty/optional/tl/optional.hpp	(date 1720720014344)
@@ -351,7 +351,7 @@
 };
 #endif
 
-// The storage base manages the actual storage, and correctly propagates
+// The storage base n_BASIC_MPges the actual storage, and correctly propagates
 // trivial destruction from T. This case is for when T is not trivially
 // destructible.
 template <class T, bool = ::std::is_trivially_destructible<T>::value>
@@ -439,7 +439,7 @@
 #endif
 };
 
-// This class manages conditionally having a trivial copy constructor
+// This class n_BASIC_MPges conditionally having a trivial copy constructor
 // This specialization is for when T is trivially copy constructible
 template <class T, bool = TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T)>
 struct optional_copy_base : optional_operations_base<T> {
@@ -465,7 +465,7 @@
   optional_copy_base &operator=(optional_copy_base &&rhs) = default;
 };
 
-// This class manages conditionally having a trivial move constructor
+// This class n_BASIC_MPges conditionally having a trivial move constructor
 // Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
 // doesn't implement an analogue to std::is_trivially_move_constructible. We
 // have to make do with a non-trivial move constructor even if T is trivially
@@ -496,7 +496,7 @@
   optional_move_base &operator=(optional_move_base &&rhs) = default;
 };
 
-// This class manages conditionally having a trivial copy assignment operator
+// This class n_BASIC_MPges conditionally having a trivial copy assignment operator
 template <class T, bool = TL_OPTIONAL_IS_TRIVIALLY_COPY_ASSIGNABLE(T) &&
                           TL_OPTIONAL_IS_TRIVIALLY_COPY_CONSTRUCTIBLE(T) &&
                           TL_OPTIONAL_IS_TRIVIALLY_DESTRUCTIBLE(T)>
@@ -520,7 +520,7 @@
   operator=(optional_copy_assign_base &&rhs) = default;
 };
 
-// This class manages conditionally having a trivial move assignment operator
+// This class n_BASIC_MPges conditionally having a trivial move assignment operator
 // Unfortunately there's no way to achieve this in GCC < 5 AFAIK, since it
 // doesn't implement an analogue to std::is_trivially_move_assignable. We have
 // to make do with a non-trivial move assignment operator even if T is trivially
@@ -678,7 +678,7 @@
 };
 
 /// An optional object is an object that contains the storage for another
-/// object and manages the lifetime of this contained object, if any. The
+/// object and n_BASIC_MPges the lifetime of this contained object, if any. The
 /// contained object may be initialized after the optional object has been
 /// initialized, and may be destroyed before the optional object has been
 /// destroyed. The initialization state of the contained object is tracked by
Index: Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># spdlog\r\n\r\nVery fast, header-only/compiled, C++ logging library. [![Build Status](https://app.travis-ci.com/gabime/spdlog.svg?branch=v1.x)](https://app.travis-ci.com/gabime/spdlog)&nbsp; [![Build status](https://ci.appveyor.com/api/projects/status/d2jnxclg20vd0o50?svg=true&branch=v1.x)](https://ci.appveyor.com/project/gabime/spdlog) [![Release](https://img.shields.io/github/release/gabime/spdlog.svg)](https://github.com/gabime/spdlog/releases/latest)\r\n\r\n## Install \r\n#### Header only version\r\nCopy the include [folder](https://github.com/gabime/spdlog/tree/v1.x/include/spdlog) to your build tree and use a C++11 compiler.\r\n\r\n#### Static lib version (recommended - much faster compile times)\r\n```console\r\n$ git clone https://github.com/gabime/spdlog.git\r\n$ cd spdlog && mkdir build && cd build\r\n$ cmake .. && make -j\r\n```\r\n      \r\n   see example [CMakeLists.txt](https://github.com/gabime/spdlog/blob/v1.x/example/CMakeLists.txt) on how to use.\r\n\r\n## Platforms\r\n * Linux, FreeBSD, OpenBSD, Solaris, AIX\r\n * Windows (msvc 2013+, cygwin)\r\n * macOS (clang 3.5+)\r\n * Android\r\n\r\n## Package managers:\r\n* Debian: `sudo apt install libspdlog-dev`\r\n* Homebrew: `brew install spdlog`\r\n* MacPorts: `sudo port install spdlog`\r\n* FreeBSD:  `pkg install spdlog`\r\n* Fedora: `dnf install spdlog`\r\n* Gentoo: `emerge dev-libs/spdlog`\r\n* Arch Linux: `pacman -S spdlog`\r\n* vcpkg: `vcpkg install spdlog`\r\n* conan: `spdlog/[>=1.4.1]`\r\n* conda: `conda install -c conda-forge spdlog`\r\n* build2: ```depends: spdlog ^1.8.2```\r\n\r\n\r\n## Features\r\n* Very fast (see [benchmarks](#benchmarks) below).\r\n* Headers only or compiled\r\n* Feature rich formatting, using the excellent [fmt](https://github.com/fmtlib/fmt) library.\r\n* Asynchronous mode (optional)\r\n* [Custom](https://github.com/gabime/spdlog/wiki/3.-Custom-formatting) formatting.\r\n* Multi/Single threaded loggers.\r\n* Various log targets:\r\n    * Rotating log files.\r\n    * Daily log files.\r\n    * Console logging (colors supported).\r\n    * syslog.\r\n    * Windows event log.\r\n    * Windows debugger (```OutputDebugString(..)```).\r\n    * Easily [extendable](https://github.com/gabime/spdlog/wiki/4.-Sinks#implementing-your-own-sink) with custom log targets.\r\n* Log filtering - log levels can be modified in runtime as well as in compile time.\r\n* Support for loading log levels from argv or from environment var.\r\n* [Backtrace](#backtrace-support) support - store debug messages in a ring buffer and display later on demand.\r\n \r\n## Usage samples\r\n\r\n#### Basic usage\r\n```c++\r\n#include \"spdlog/spdlog.h\"\r\n\r\nint main() \r\n{\r\n    spdlog::info(\"Welcome to spdlog!\");\r\n    spdlog::error(\"Some error message with arg: {}\", 1);\r\n    \r\n    spdlog::warn(\"Easy padding in numbers like {:08d}\", 12);\r\n    spdlog::critical(\"Support for int: {0:d};  hex: {0:x};  oct: {0:o}; bin: {0:b}\", 42);\r\n    spdlog::info(\"Support for floats {:03.2f}\", 1.23456);\r\n    spdlog::info(\"Positional args are {1} {0}..\", \"too\", \"supported\");\r\n    spdlog::info(\"{:<30}\", \"left aligned\");\r\n    \r\n    spdlog::set_level(spdlog::level::debug); // Set global log level to debug\r\n    spdlog::debug(\"This message should be displayed..\");    \r\n    \r\n    // change log pattern\r\n    spdlog::set_pattern(\"[%H:%M:%S %z] [%n] [%^---%L---%$] [thread %t] %v\");\r\n    \r\n    // Compile time log levels\r\n    // define SPDLOG_ACTIVE_LEVEL to desired level\r\n    SPDLOG_TRACE(\"Some trace message with param {}\", 42);\r\n    SPDLOG_DEBUG(\"Some debug message\");\r\n}\r\n\r\n```\r\n---\r\n#### Create stdout/stderr logger object\r\n```c++\r\n#include \"spdlog/spdlog.h\"\r\n#include \"spdlog/sinks/stdout_color_sinks.h\"\r\nvoid stdout_example()\r\n{\r\n    // create color multi threaded logger\r\n    auto console = spdlog::stdout_color_mt(\"console\");    \r\n    auto err_logger = spdlog::stderr_color_mt(\"stderr\");    \r\n    spdlog::get(\"console\")->info(\"loggers can be retrieved from a global registry using the spdlog::get(logger_name)\");\r\n}\r\n```\r\n\r\n---\r\n#### Basic file logger\r\n```c++\r\n#include \"spdlog/sinks/basic_file_sink.h\"\r\nvoid basic_logfile_example()\r\n{\r\n    try \r\n    {\r\n        auto logger = spdlog::basic_logger_mt(\"basic_logger\", \"logs/basic-log.txt\");\r\n    }\r\n    catch (const spdlog::spdlog_ex &ex)\r\n    {\r\n        std::cout << \"Log init failed: \" << ex.what() << std::endl;\r\n    }\r\n}\r\n```\r\n---\r\n#### Rotating files\r\n```c++\r\n#include \"spdlog/sinks/rotating_file_sink.h\"\r\nvoid rotating_example()\r\n{\r\n    // Create a file rotating logger with 5mb size max and 3 rotated files\r\n    auto max_size = 1048576 * 5;\r\n    auto max_files = 3;\r\n    auto logger = spdlog::rotating_logger_mt(\"some_logger_name\", \"logs/rotating.txt\", max_size, max_files);\r\n}\r\n```\r\n\r\n---\r\n#### Daily files\r\n```c++\r\n\r\n#include \"spdlog/sinks/daily_file_sink.h\"\r\nvoid daily_example()\r\n{\r\n    // Create a daily logger - a new file is created every day on 2:30am\r\n    auto logger = spdlog::daily_logger_mt(\"daily_logger\", \"logs/daily.txt\", 2, 30);\r\n}\r\n\r\n```\r\n\r\n---\r\n#### Backtrace support\r\n```c++\r\n// Debug messages can be stored in a ring buffer instead of being logged immediately.\r\n// This is useful in order to display debug logs only when really needed (e.g. when error happens).\r\n// When needed, call dump_backtrace() to see them.\r\n\r\nspdlog::enable_backtrace(32); // Store the latest 32 messages in a buffer. Older messages will be dropped.\r\n// or my_logger->enable_backtrace(32)..\r\nfor(int i = 0; i < 100; i++)\r\n{\r\n  spdlog::debug(\"Backtrace message {}\", i); // not logged yet..\r\n}\r\n// e.g. if some error happened:\r\nspdlog::dump_backtrace(); // log them now! show the last 32 messages\r\n\r\n// or my_logger->dump_backtrace(32)..\r\n```\r\n\r\n---\r\n#### Periodic flush\r\n```c++\r\n// periodically flush all *registered* loggers every 3 seconds:\r\n// warning: only use if all your loggers are thread safe (\"_mt\" loggers)\r\nspdlog::flush_every(std::chrono::seconds(3));\r\n\r\n```\r\n\r\n---\r\n#### Stopwatch\r\n```c++\r\n// Stopwatch support for spdlog\r\n#include \"spdlog/stopwatch.h\"\r\nvoid stopwatch_example()\r\n{\r\n    spdlog::stopwatch sw;    \r\n    spdlog::debug(\"Elapsed {}\", sw);\r\n    spdlog::debug(\"Elapsed {:.3}\", sw);       \r\n}\r\n\r\n```\r\n\r\n---\r\n#### Log binary data in hex\r\n```c++\r\n// many types of std::container<char> types can be used.\r\n// ranges are supported too.\r\n// format flags:\r\n// {:X} - print in uppercase.\r\n// {:s} - don't separate each byte with space.\r\n// {:p} - don't print the position on each line start.\r\n// {:n} - don't split the output to lines.\r\n// {:a} - show ASCII if :n is not set.\r\n\r\n#include \"spdlog/fmt/bin_to_hex.h\"\r\n\r\nvoid binary_example()\r\n{\r\n    auto console = spdlog::get(\"console\");\r\n    std::array<char, 80> buf;\r\n    console->info(\"Binary example: {}\", spdlog::to_hex(buf));\r\n    console->info(\"Another binary example:{:n}\", spdlog::to_hex(std::begin(buf), std::begin(buf) + 10));\r\n    // more examples:\r\n    // logger->info(\"uppercase: {:X}\", spdlog::to_hex(buf));\r\n    // logger->info(\"uppercase, no delimiters: {:Xs}\", spdlog::to_hex(buf));\r\n    // logger->info(\"uppercase, no delimiters, no position info: {:Xsp}\", spdlog::to_hex(buf));\r\n}\r\n\r\n```\r\n\r\n---\r\n#### Logger with multi sinks - each with different format and log level\r\n```c++\r\n\r\n// create logger with 2 targets with different log levels and formats.\r\n// the console will show only warnings or errors, while the file will log all.\r\nvoid multi_sink_example()\r\n{\r\n    auto console_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt>();\r\n    console_sink->set_level(spdlog::level::warn);\r\n    console_sink->set_pattern(\"[multi_sink_example] [%^%l%$] %v\");\r\n\r\n    auto file_sink = std::make_shared<spdlog::sinks::basic_file_sink_mt>(\"logs/multisink.txt\", true);\r\n    file_sink->set_level(spdlog::level::trace);\r\n\r\n    spdlog::logger logger(\"multi_sink\", {console_sink, file_sink});\r\n    logger.set_level(spdlog::level::debug);\r\n    logger.warn(\"this should appear in both console and file\");\r\n    logger.info(\"this message should not appear in the console, only in the file\");\r\n}\r\n```\r\n\r\n---\r\n#### Asynchronous logging\r\n```c++\r\n#include \"spdlog/async.h\"\r\n#include \"spdlog/sinks/basic_file_sink.h\"\r\nvoid async_example()\r\n{\r\n    // default thread pool settings can be modified *before* creating the async logger:\r\n    // spdlog::init_thread_pool(8192, 1); // queue with 8k items and 1 backing thread.\r\n    auto async_file = spdlog::basic_logger_mt<spdlog::async_factory>(\"async_file_logger\", \"logs/async_log.txt\");\r\n    // alternatively:\r\n    // auto async_file = spdlog::create_async<spdlog::sinks::basic_file_sink_mt>(\"async_file_logger\", \"logs/async_log.txt\");   \r\n}\r\n\r\n```\r\n\r\n---\r\n#### Asynchronous logger with multi sinks  \r\n```c++\r\n#include \"spdlog/sinks/stdout_color_sinks.h\"\r\n#include \"spdlog/sinks/rotating_file_sink.h\"\r\n\r\nvoid multi_sink_example2()\r\n{\r\n    spdlog::init_thread_pool(8192, 1);\r\n    auto stdout_sink = std::make_shared<spdlog::sinks::stdout_color_sink_mt >();\r\n    auto rotating_sink = std::make_shared<spdlog::sinks::rotating_file_sink_mt>(\"mylog.txt\", 1024*1024*10, 3);\r\n    std::vector<spdlog::sink_ptr> sinks {stdout_sink, rotating_sink};\r\n    auto logger = std::make_shared<spdlog::async_logger>(\"loggername\", sinks.begin(), sinks.end(), spdlog::thread_pool(), spdlog::async_overflow_policy::block);\r\n    spdlog::register_logger(logger);\r\n}\r\n```\r\n \r\n---\r\n#### User defined types\r\n```c++\r\n// user defined types logging by implementing operator<<\r\n#include \"spdlog/fmt/ostr.h\" // must be included\r\nstruct my_type\r\n{\r\n    int i;\r\n    template<typename OStream>\r\n    friend OStream &operator<<(OStream &os, const my_type &c)\r\n    {\r\n        return os << \"[my_type i=\" << c.i << \"]\";\r\n    }\r\n};\r\n\r\nvoid user_defined_example()\r\n{\r\n    spdlog::get(\"console\")->info(\"user defined type: {}\", my_type{14});\r\n}\r\n\r\n```\r\n\r\n---\r\n#### User defined flags in the log pattern\r\n```c++ \r\n// Log patterns can contain custom flags.\r\n// the following example will add new flag '%*' - which will be bound to a <my_formatter_flag> instance.\r\n#include \"spdlog/pattern_formatter.h\"\r\nclass my_formatter_flag : public spdlog::custom_flag_formatter\r\n{\r\npublic:\r\n    void format(const spdlog::details::log_msg &, const std::tm &, spdlog::memory_buf_t &dest) override\r\n    {\r\n        std::string some_txt = \"custom-flag\";\r\n        dest.append(some_txt.data(), some_txt.data() + some_txt.size());\r\n    }\r\n\r\n    std::unique_ptr<custom_flag_formatter> clone() const override\r\n    {\r\n        return spdlog::details::make_unique<my_formatter_flag>();\r\n    }\r\n};\r\n\r\nvoid custom_flags_example()\r\n{    \r\n    auto formatter = std::make_unique<spdlog::pattern_formatter>();\r\n    formatter->add_flag<my_formatter_flag>('*').set_pattern(\"[%n] [%*] [%^%l%$] %v\");\r\n    spdlog::set_formatter(std::move(formatter));\r\n}\r\n\r\n```\r\n\r\n---\r\n#### Custom error handler\r\n```c++\r\nvoid err_handler_example()\r\n{\r\n    // can be set globally or per logger(logger->set_error_handler(..))\r\n    spdlog::set_error_handler([](const std::string &msg) { spdlog::get(\"console\")->error(\"*** LOGGER ERROR ***: {}\", msg); });\r\n    spdlog::get(\"console\")->info(\"some invalid message to trigger an error {}{}{}{}\", 3);\r\n}\r\n\r\n```\r\n\r\n---\r\n#### syslog \r\n```c++\r\n#include \"spdlog/sinks/syslog_sink.h\"\r\nvoid syslog_example()\r\n{\r\n    std::string ident = \"spdlog-example\";\r\n    auto syslog_logger = spdlog::syslog_logger_mt(\"syslog\", ident, LOG_PID);\r\n    syslog_logger->warn(\"This is warning that will end up in syslog.\");\r\n}\r\n```\r\n---\r\n#### Android example \r\n```c++\r\n#include \"spdlog/sinks/android_sink.h\"\r\nvoid android_example()\r\n{\r\n    std::string tag = \"spdlog-android\";\r\n    auto android_logger = spdlog::android_logger_mt(\"android\", tag);\r\n    android_logger->critical(\"Use \\\"adb shell logcat\\\" to view this message.\");\r\n}\r\n```\r\n\r\n---\r\n#### Load log levels from env variable or from argv\r\n\r\n```c++\r\n#include \"spdlog/cfg/env.h\"\r\nint main (int argc, char *argv[])\r\n{\r\n    spdlog::cfg::load_env_levels();\r\n    // or from command line:\r\n    // ./example SPDLOG_LEVEL=info,mylogger=trace\r\n    // #include \"spdlog/cfg/argv.h\" // for loading levels from argv\r\n    // spdlog::cfg::load_argv_levels(argc, argv);\r\n}\r\n```\r\nSo then you can:\r\n\r\n```console\r\n$ export SPDLOG_LEVEL=info,mylogger=trace\r\n$ ./example\r\n```\r\n\r\n\r\n---\r\n#### Log file open/close event handlers\r\n```c++\r\n// You can get callbacks from spdlog before/after log file has been opened or closed. \r\n// This is useful for cleanup procedures or for adding someting the start/end of the log files.\r\nvoid file_events_example()\r\n{\r\n    // pass the spdlog::file_event_handlers to file sinks for open/close log file notifications\r\n    spdlog::file_event_handlers handlers;\r\n    handlers.before_open = [](spdlog::filename_t filename) { spdlog::info(\"Before opening {}\", filename); };\r\n    handlers.after_open = [](spdlog::filename_t filename, std::FILE *fstream) { fputs(\"After opening\\n\", fstream); };\r\n    handlers.before_close = [](spdlog::filename_t filename, std::FILE *fstream) { fputs(\"Before closing\\n\", fstream); };\r\n    handlers.after_close = [](spdlog::filename_t filename) { spdlog::info(\"After closing {}\", filename); };\r\n    auto my_logger = spdlog::basic_logger_st(\"some_logger\", \"logs/events-sample.txt\", true, handlers);        \r\n}\r\n```\r\n\r\n---\r\n#### Replace the Default Logger\r\n```c++\r\nvoid replace_default_logger_example()\r\n{\r\n    auto new_logger = spdlog::basic_logger_mt(\"new_default_logger\", \"logs/new-default-log.txt\", true);\r\n    spdlog::set_default_logger(new_logger);\r\n    spdlog::info(\"new logger log message\");\r\n}\r\n```\r\n\r\n---\r\n## Benchmarks\r\n\r\nBelow are some [benchmarks](https://github.com/gabime/spdlog/blob/v1.x/bench/bench.cpp) done in Ubuntu 64 bit, Intel i7-4770 CPU @ 3.40GHz\r\n\r\n#### Synchronous mode\r\n```\r\n[info] **************************************************************\r\n[info] Single thread, 1,000,000 iterations\r\n[info] **************************************************************\r\n[info] basic_st         Elapsed: 0.17 secs        5,777,626/sec\r\n[info] rotating_st      Elapsed: 0.18 secs        5,475,894/sec\r\n[info] daily_st         Elapsed: 0.20 secs        5,062,659/sec\r\n[info] empty_logger     Elapsed: 0.07 secs       14,127,300/sec\r\n[info] **************************************************************\r\n[info] C-string (400 bytes). Single thread, 1,000,000 iterations\r\n[info] **************************************************************\r\n[info] basic_st         Elapsed: 0.41 secs        2,412,483/sec\r\n[info] rotating_st      Elapsed: 0.72 secs        1,389,196/sec\r\n[info] daily_st         Elapsed: 0.42 secs        2,393,298/sec\r\n[info] null_st          Elapsed: 0.04 secs       27,446,957/sec\r\n[info] **************************************************************\r\n[info] 10 threads, competing over the same logger object, 1,000,000 iterations\r\n[info] **************************************************************\r\n[info] basic_mt         Elapsed: 0.60 secs        1,659,613/sec\r\n[info] rotating_mt      Elapsed: 0.62 secs        1,612,493/sec\r\n[info] daily_mt         Elapsed: 0.61 secs        1,638,305/sec\r\n[info] null_mt          Elapsed: 0.16 secs        6,272,758/sec\r\n```\r\n#### Asynchronous mode\r\n```\r\n[info] -------------------------------------------------\r\n[info] Messages     : 1,000,000\r\n[info] Threads      : 10\r\n[info] Queue        : 8,192 slots\r\n[info] Queue memory : 8,192 x 272 = 2,176 KB \r\n[info] -------------------------------------------------\r\n[info] \r\n[info] *********************************\r\n[info] Queue Overflow Policy: block\r\n[info] *********************************\r\n[info] Elapsed: 1.70784 secs     585,535/sec\r\n[info] Elapsed: 1.69805 secs     588,910/sec\r\n[info] Elapsed: 1.7026 secs      587,337/sec\r\n[info] \r\n[info] *********************************\r\n[info] Queue Overflow Policy: overrun\r\n[info] *********************************\r\n[info] Elapsed: 0.372816 secs    2,682,285/sec\r\n[info] Elapsed: 0.379758 secs    2,633,255/sec\r\n[info] Elapsed: 0.373532 secs    2,677,147/sec\r\n\r\n```\r\n\r\n## Documentation\r\nDocumentation can be found in the [wiki](https://github.com/gabime/spdlog/wiki/1.-QuickStart) pages.\r\n\r\n---\r\n\r\nThanks to [JetBrains](https://www.jetbrains.com/?from=spdlog) for donating product licenses to help develop **spdlog** <a href=\"https://www.jetbrains.com/?from=spdlog\"><img src=\"logos/jetbrains-variant-4.svg\" width=\"94\" align=\"center\" /></a>\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/README.md b/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/README.md
--- a/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/README.md	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/README.md	(date 1720720014735)
@@ -21,7 +21,7 @@
  * macOS (clang 3.5+)
  * Android
 
-## Package managers:
+## Package n_BASIC_MPgers:
 * Debian: `sudo apt install libspdlog-dev`
 * Homebrew: `brew install spdlog`
 * MacPorts: `sudo port install spdlog`
Index: .idea/.idea.FIM/.idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoGeneratedRunConfigurationManager\">\r\n    <projectFile>../../UE5/UE_5.4/Engine/Source/Programs/AutomationTool/AutomationTool.csproj</projectFile>\r\n    <projectFile profileName=\"EpicGames.AspNet\">../../UE5/UE_5.4/Engine/Source/Programs/Shared/EpicGames.AspNet/EpicGames.AspNet.csproj</projectFile>\r\n    <projectFile>../../UE5/UE_5.4/Engine/Source/Programs/UnrealBuildTool/UnrealBuildTool.csproj</projectFile>\r\n    <projectFile>Intermediate/ProjectFiles/FIM.vcxproj</projectFile>\r\n    <projectFile>Intermediate/ProjectFiles/UE5.vcxproj</projectFile>\r\n  </component>\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"f92a8d84-b83d-40be-9614-c4e3720ee1fd\" name=\"Changes\" comment=\"\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/.idea.FIM/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/.idea.FIM/.idea/workspace.xml\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <favorite-branches>\r\n      <branch-storage>\r\n        <map>\r\n          <entry type=\"LOCAL\">\r\n            <value>\r\n              <list>\r\n                <branch-info repo=\"$PROJECT_DIR$\" source=\"saxon877559@gmail.com\" />\r\n              </list>\r\n            </value>\r\n          </entry>\r\n        </map>\r\n      </branch-storage>\r\n    </favorite-branches>\r\n    <option name=\"PUSH_TAGS\">\r\n      <GitPushTagMode>\r\n        <option name=\"argument\" value=\"--follow-tags\" />\r\n        <option name=\"title\" value=\"Current Branch\" />\r\n      </GitPushTagMode>\r\n    </option>\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"saxon877559@gmail.com\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;LuxSaxon&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/LuxSaxon/FIM.git&quot;,\r\n    &quot;accountId&quot;: &quot;c30d5a9a-83b7-4939-a0bb-e4b335b11ba1&quot;\r\n  },\r\n  &quot;recentNewPullRequestHead&quot;: {\r\n    &quot;server&quot;: {\r\n      &quot;useHttp&quot;: false,\r\n      &quot;host&quot;: &quot;github.com&quot;,\r\n      &quot;port&quot;: null,\r\n      &quot;suffix&quot;: null\r\n    },\r\n    &quot;owner&quot;: &quot;LuxSaxon&quot;,\r\n    &quot;repository&quot;: &quot;FIM&quot;\r\n  }\r\n}</component>\r\n  <component name=\"HighlightingSettingsPerFile\">\r\n    <setting file=\"file://$PROJECT_DIR$/../../UE5/UE_5.1/Engine/Source/Runtime/Core/Public/Experimental/Containers/HazardPointer.h\" root0=\"SKIP_HIGHLIGHTING\" />\r\n    <setting file=\"file://$PROJECT_DIR$/../../UE5/UE_5.1/Engine/Source/UnrealEditor.Target.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n    <setting file=\"file://$PROJECT_DIR$/../../UE5/UE_5.1/Engine/Source/UnrealGame.Target.cs\" root0=\"FORCE_HIGHLIGHTING\" />\r\n  </component>\r\n  <component name=\"MarkdownSettingsMigration\">\r\n    <option name=\"stateVersion\" value=\"1\" />\r\n  </component>\r\n  <component name=\"MetaFilesCheckinStateConfiguration\" checkMetaFiles=\"true\" />\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 2\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2ZLU22gTLAzaD3MdaJjrelVhNgA\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"C++ Project.FIM.executor\": \"Run\",\r\n    \"RunOnceActivity.OpenProjectViewOnStart\": \"true\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"git-widget-placeholder\": \"saxon877559@gmail.com\",\r\n    \"ignore.virus.scanning.warn.message\": \"true\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\r\n    \"nodejs_package_manager_path\": \"npm\",\r\n    \"settings.editor.selected.configurable\": \"preferences.keymap\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  },\r\n  \"keyToStringList\": {\r\n    \"rider.external.source.directories\": [\r\n      \"C:\\\\Users\\\\ASUS\\\\AppData\\\\Roaming\\\\JetBrains\\\\Rider2024.1\\\\resharper-host\\\\DecompilerCache\",\r\n      \"C:\\\\Users\\\\ASUS\\\\AppData\\\\Roaming\\\\JetBrains\\\\Rider2024.1\\\\resharper-host\\\\SourcesCache\",\r\n      \"C:\\\\Users\\\\ASUS\\\\AppData\\\\Local\\\\Symbols\\\\src\"\r\n    ]\r\n  }\r\n}]]></component>\r\n  <component name=\"RunManager\" selected=\"C++ Project.FIM\">\r\n    <configuration name=\"FIM\" type=\"CppProject\" factoryName=\"C++ Project\">\r\n      <configuration_1>\r\n        <option name=\"CONFIGURATION\" value=\"DebugGame Editor\" />\r\n        <option name=\"PLATFORM\" value=\"Win64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/FIM.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"FORCE_CONSOLE\" />\r\n      </configuration_1>\r\n      <configuration_2>\r\n        <option name=\"CONFIGURATION\" value=\"Shipping\" />\r\n        <option name=\"PLATFORM\" value=\"Win64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/FIM.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"FORCE_CONSOLE\" />\r\n      </configuration_2>\r\n      <configuration_3>\r\n        <option name=\"CONFIGURATION\" value=\"DebugGame\" />\r\n        <option name=\"PLATFORM\" value=\"Win64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/FIM.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"FORCE_CONSOLE\" />\r\n      </configuration_3>\r\n      <configuration_4>\r\n        <option name=\"CONFIGURATION\" value=\"Development Editor\" />\r\n        <option name=\"PLATFORM\" value=\"Win64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/FIM.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"FORCE_CONSOLE\" />\r\n      </configuration_4>\r\n      <configuration_5>\r\n        <option name=\"CONFIGURATION\" value=\"Development\" />\r\n        <option name=\"PLATFORM\" value=\"Win64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/FIM.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"FORCE_CONSOLE\" />\r\n      </configuration_5>\r\n      <option name=\"DEFAULT_PROJECT_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/FIM.vcxproj\" />\r\n      <option name=\"AUTO_SELECT_PRIORITY\" value=\"0\" />\r\n      <method v=\"2\">\r\n        <option name=\"Build\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"UE5\" type=\"CppProject\" factoryName=\"C++ Project\">\r\n      <configuration_1>\r\n        <option name=\"CONFIGURATION\" value=\"Development Editor\" />\r\n        <option name=\"PLATFORM\" value=\"Win64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_1>\r\n      <configuration_2>\r\n        <option name=\"CONFIGURATION\" value=\"DebugGame\" />\r\n        <option name=\"PLATFORM\" value=\"IOS\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_2>\r\n      <configuration_3>\r\n        <option name=\"CONFIGURATION\" value=\"DebugGame Editor\" />\r\n        <option name=\"PLATFORM\" value=\"IOS\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_3>\r\n      <configuration_4>\r\n        <option name=\"CONFIGURATION\" value=\"Shipping\" />\r\n        <option name=\"PLATFORM\" value=\"Win64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_4>\r\n      <configuration_5>\r\n        <option name=\"CONFIGURATION\" value=\"DebugGame\" />\r\n        <option name=\"PLATFORM\" value=\"Win64-arm64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_5>\r\n      <configuration_6>\r\n        <option name=\"CONFIGURATION\" value=\"Development Editor\" />\r\n        <option name=\"PLATFORM\" value=\"Win64-arm64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_6>\r\n      <configuration_7>\r\n        <option name=\"CONFIGURATION\" value=\"Shipping\" />\r\n        <option name=\"PLATFORM\" value=\"Win64-arm64ec\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_7>\r\n      <configuration_8>\r\n        <option name=\"CONFIGURATION\" value=\"Development Editor\" />\r\n        <option name=\"PLATFORM\" value=\"IOS\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_8>\r\n      <configuration_9>\r\n        <option name=\"CONFIGURATION\" value=\"DebugGame\" />\r\n        <option name=\"PLATFORM\" value=\"Win64-arm64ec\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_9>\r\n      <configuration_10>\r\n        <option name=\"CONFIGURATION\" value=\"Shipping\" />\r\n        <option name=\"PLATFORM\" value=\"IOS\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_10>\r\n      <configuration_11>\r\n        <option name=\"CONFIGURATION\" value=\"Development Editor\" />\r\n        <option name=\"PLATFORM\" value=\"Win64-arm64ec\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_11>\r\n      <configuration_12>\r\n        <option name=\"CONFIGURATION\" value=\"Development\" />\r\n        <option name=\"PLATFORM\" value=\"Win64-arm64ec\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_12>\r\n      <configuration_13>\r\n        <option name=\"CONFIGURATION\" value=\"DebugGame Editor\" />\r\n        <option name=\"PLATFORM\" value=\"Win64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_13>\r\n      <configuration_14>\r\n        <option name=\"CONFIGURATION\" value=\"Development\" />\r\n        <option name=\"PLATFORM\" value=\"Win64-arm64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_14>\r\n      <configuration_15>\r\n        <option name=\"CONFIGURATION\" value=\"Development\" />\r\n        <option name=\"PLATFORM\" value=\"IOS\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_15>\r\n      <configuration_16>\r\n        <option name=\"CONFIGURATION\" value=\"Shipping\" />\r\n        <option name=\"PLATFORM\" value=\"Win64-arm64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_16>\r\n      <configuration_17>\r\n        <option name=\"CONFIGURATION\" value=\"DebugGame\" />\r\n        <option name=\"PLATFORM\" value=\"Win64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_17>\r\n      <configuration_18>\r\n        <option name=\"CONFIGURATION\" value=\"DebugGame Editor\" />\r\n        <option name=\"PLATFORM\" value=\"Win64-arm64ec\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_18>\r\n      <configuration_19>\r\n        <option name=\"CONFIGURATION\" value=\"DebugGame Editor\" />\r\n        <option name=\"PLATFORM\" value=\"Win64-arm64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_19>\r\n      <configuration_20>\r\n        <option name=\"CONFIGURATION\" value=\"Development\" />\r\n        <option name=\"PLATFORM\" value=\"Win64\" />\r\n        <option name=\"PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n        <option name=\"CURRENT_LAUNCH_PROFILE\" value=\"Local\" />\r\n        <option name=\"EXE_PATH\" value=\"$(LocalDebuggerCommand)\" />\r\n        <option name=\"PROGRAM_PARAMETERS\" value=\"$(LocalDebuggerCommandArguments)\" />\r\n        <option name=\"WORKING_DIRECTORY\" value=\"$(LocalDebuggerWorkingDirectory)\" />\r\n        <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n        <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n        <option name=\"TERMINAL_INTERACTION_BEHAVIOR\" value=\"AUTO_DETECT\" />\r\n      </configuration_20>\r\n      <option name=\"DEFAULT_PROJECT_PATH\" value=\"$PROJECT_DIR$/Intermediate/ProjectFiles/UE5.vcxproj\" />\r\n      <option name=\"AUTO_SELECT_PRIORITY\" value=\"10000\" />\r\n      <method v=\"2\">\r\n        <option name=\"Build\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"AutomationTool\" type=\"DotNetProject\" factoryName=\".NET Project\">\r\n      <option name=\"EXE_PATH\" value=\"\" />\r\n      <option name=\"PROGRAM_PARAMETERS\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n      <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n      <option name=\"USE_MONO\" value=\"0\" />\r\n      <option name=\"RUNTIME_ARGUMENTS\" value=\"\" />\r\n      <option name=\"PROJECT_PATH\" value=\"$PROJECT_DIR$/../../UE5/UE_5.4/Engine/Source/Programs/AutomationTool/AutomationTool.csproj\" />\r\n      <option name=\"PROJECT_EXE_PATH_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_ARGUMENTS_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_WORKING_DIRECTORY_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_KIND\" value=\"DotNetCore\" />\r\n      <option name=\"PROJECT_TFM\" value=\"\" />\r\n      <method v=\"2\">\r\n        <option name=\"Build\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"UnrealBuildTool\" type=\"DotNetProject\" factoryName=\".NET Project\">\r\n      <option name=\"EXE_PATH\" value=\"\" />\r\n      <option name=\"PROGRAM_PARAMETERS\" value=\"\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"\" />\r\n      <option name=\"PASS_PARENT_ENVS\" value=\"1\" />\r\n      <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n      <option name=\"USE_MONO\" value=\"0\" />\r\n      <option name=\"RUNTIME_ARGUMENTS\" value=\"\" />\r\n      <option name=\"PROJECT_PATH\" value=\"$PROJECT_DIR$/../../UE5/UE_5.4/Engine/Source/Programs/UnrealBuildTool/UnrealBuildTool.csproj\" />\r\n      <option name=\"PROJECT_EXE_PATH_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_ARGUMENTS_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_WORKING_DIRECTORY_TRACKING\" value=\"1\" />\r\n      <option name=\"PROJECT_KIND\" value=\"DotNetCore\" />\r\n      <option name=\"PROJECT_TFM\" value=\"\" />\r\n      <method v=\"2\">\r\n        <option name=\"Build\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"EpicGames.AspNet\" type=\"LaunchSettings\" factoryName=\".NET Launch Settings Profile\">\r\n      <option name=\"LAUNCH_PROFILE_PROJECT_FILE_PATH\" value=\"$PROJECT_DIR$/../../UE5/UE_5.4/Engine/Source/Programs/Shared/EpicGames.AspNet/EpicGames.AspNet.csproj\" />\r\n      <option name=\"LAUNCH_PROFILE_TFM\" value=\"net6.0\" />\r\n      <option name=\"LAUNCH_PROFILE_NAME\" value=\"EpicGames.AspNet\" />\r\n      <option name=\"USE_EXTERNAL_CONSOLE\" value=\"0\" />\r\n      <option name=\"USE_MONO\" value=\"0\" />\r\n      <option name=\"RUNTIME_ARGUMENTS\" value=\"\" />\r\n      <option name=\"GENERATE_APPLICATIONHOST_CONFIG\" value=\"1\" />\r\n      <option name=\"SHOW_IIS_EXPRESS_OUTPUT\" value=\"0\" />\r\n      <option name=\"SEND_DEBUG_REQUEST\" value=\"1\" />\r\n      <option name=\"ADDITIONAL_IIS_EXPRESS_ARGUMENTS\" value=\"\" />\r\n      <method v=\"2\">\r\n        <option name=\"Build\" />\r\n      </method>\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"f92a8d84-b83d-40be-9614-c4e3720ee1fd\" name=\"Changes\" comment=\"\" />\r\n      <created>1702200643213</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1702200643213</updated>\r\n      <workItem from=\"1702200646742\" duration=\"36000\" />\r\n      <workItem from=\"1702200788191\" duration=\"21000\" />\r\n      <workItem from=\"1702200824200\" duration=\"668000\" />\r\n      <workItem from=\"1709540962194\" duration=\"1000000\" />\r\n      <workItem from=\"1715359879089\" duration=\"158000\" />\r\n      <workItem from=\"1715360071635\" duration=\"234000\" />\r\n      <workItem from=\"1715360403443\" duration=\"120000\" />\r\n      <workItem from=\"1715360559656\" duration=\"54000\" />\r\n      <workItem from=\"1715360843338\" duration=\"751000\" />\r\n      <workItem from=\"1715361650857\" duration=\"258000\" />\r\n      <workItem from=\"1715414668616\" duration=\"23000\" />\r\n      <workItem from=\"1715419982491\" duration=\"232000\" />\r\n      <workItem from=\"1715421214647\" duration=\"993000\" />\r\n      <workItem from=\"1716018748523\" duration=\"140000\" />\r\n      <workItem from=\"1716019679463\" duration=\"2328000\" />\r\n      <workItem from=\"1716734520108\" duration=\"2098000\" />\r\n      <workItem from=\"1716737182642\" duration=\"1442000\" />\r\n      <workItem from=\"1716738805703\" duration=\"13000\" />\r\n      <workItem from=\"1716741126733\" duration=\"980000\" />\r\n      <workItem from=\"1716742552205\" duration=\"8000\" />\r\n      <workItem from=\"1716742710053\" duration=\"130000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"Revert &quot;Fix Error&quot;&#10;&#10;This reverts commit c6e2f507\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1716737299133</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1716737299133</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"Revert to the original hit method\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1716741456824</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1716741456824</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"3\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"UnityCheckinConfiguration\" checkUnsavedScenes=\"true\" />\r\n  <component name=\"UnityProjectConfiguration\" hasMinimizedUI=\"false\" />\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State>\r\n              <option name=\"FILTERS\">\r\n                <map>\r\n                  <entry key=\"branch\">\r\n                    <value>\r\n                      <list>\r\n                        <option value=\"saxon877559@gmail.com\" />\r\n                      </list>\r\n                    </value>\r\n                  </entry>\r\n                </map>\r\n              </option>\r\n            </State>\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <option name=\"CLEAR_INITIAL_COMMIT_MESSAGE\" value=\"true\" />\r\n    <MESSAGE value=\"Revert &quot;Fix Error&quot;&#10;&#10;This reverts commit c6e2f507\" />\r\n    <MESSAGE value=\"Revert to the original hit method\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"Revert to the original hit method\" />\r\n  </component>\r\n  <component name=\"XSLT-Support.FileAssociations.UIState\">\r\n    <expand />\r\n    <select />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.FIM/.idea/workspace.xml b/.idea/.idea.FIM/.idea/workspace.xml
--- a/.idea/.idea.FIM/.idea/workspace.xml	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/.idea/.idea.FIM/.idea/workspace.xml	(date 1723250758162)
@@ -13,6 +13,63 @@
   <component name="ChangeListManager">
     <list default="true" id="f92a8d84-b83d-40be-9614-c4e3720ee1fd" name="Changes" comment="">
       <change beforePath="$PROJECT_DIR$/.idea/.idea.FIM/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/.idea.FIM/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/.vsconfig" beforeDir="false" afterPath="$PROJECT_DIR$/.vsconfig" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Config/DefaultEngine.ini" beforeDir="false" afterPath="$PROJECT_DIR$/Config/DefaultEngine.ini" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Config/DefaultGame.ini" beforeDir="false" afterPath="$PROJECT_DIR$/Config/DefaultGame.ini" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Config/DefaultGameplayTags.ini" beforeDir="false" afterPath="$PROJECT_DIR$/Config/DefaultGameplayTags.ini" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Config/DefaultInput.ini" beforeDir="false" afterPath="$PROJECT_DIR$/Config/DefaultInput.ini" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/Frank_RPG_Dual/Animations/Frank_Dual_Rootmotion/Frank_RPG_Dual_Air_Combo_Start.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/Frank_RPG_Dual/Animations/Frank_Dual_Rootmotion/Frank_RPG_Dual_Air_Combo_Start.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/Frank_RPG_Dual/Animations/Frank_Dual_Rootmotion/Frank_RPG_Dual_Air_Combo_Start_ZeroHeight.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/Frank_RPG_Dual/Animations/Frank_Dual_Rootmotion/Frank_RPG_Dual_Air_Combo_Start_ZeroHeight.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Animation_Notifies/ANS_MeleeAttack.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Animation_Notifies/ANS_MeleeAttack.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Animation_Notifies/AN_AttachWeaponActor_L.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Animation_Notifies/AN_AttachWeaponActor_L.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Animation_Notifies/AN_AttachWeaponActor_R.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Animation_Notifies/AN_AttachWeaponActor_R.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Animation_Notifies/AN_SlightShak.uasset" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Quinn/Normal_Attack_Combo1/Frank_RPG_Dual_Combo01_1_Retargeted_Montage.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Quinn/Normal_Attack_Combo1/Frank_RPG_Dual_Combo01_1_Retargeted_Montage.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Quinn/Normal_Attack_Combo1/Frank_RPG_Dual_Combo01_2_Retargeted_Montage.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Quinn/Normal_Attack_Combo1/Frank_RPG_Dual_Combo01_2_Retargeted_Montage.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Quinn/Normal_Attack_Combo1/Frank_RPG_Dual_Combo01_3_Retargeted_Montage.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Quinn/Normal_Attack_Combo1/Frank_RPG_Dual_Combo01_3_Retargeted_Montage.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Quinn/Normal_Attack_Combo1/Frank_RPG_Dual_Combo01_4_Retargeted_Montage.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Animations/Quinn/Normal_Attack_Combo1/Frank_RPG_Dual_Combo01_4_Retargeted_Montage.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/GA_AI_Melee.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/GA_AI_Melee.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/GA_Melee.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/GA_Melee.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/GE_Defense.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/GE_Defense.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/GE_MeleeDamage.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/GE_MeleeDamage.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/GE_Melee_Cooldown.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/GE_Melee_Cooldown.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/InitialDataTable.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Abilities/InitialDataTable.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/AdvanceAI/BB_AdvanceAI.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/AdvanceAI/BB_AdvanceAI.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/AdvanceAI/BT_AdvanceAI.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/AdvanceAI/BT_AdvanceAI.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/BP_BaseClasses/BP_AdvanceAI_Auto8.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/BP_BaseClasses/BP_AdvanceAI_Auto8.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/BP_BaseClasses/BP_TestCharacter.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/BP_BaseClasses/BP_TestCharacter.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/BP_BaseClasses/GhostTail/BP_GhostCharacter.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/BP_BaseClasses/GhostTail/BP_GhostCharacter.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/CameraShake/BP_HeavyShake.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/CameraShake/BP_HeavyShake.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/CameraShake/BP_SlightShake.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/CameraShake/BP_SlightShake.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Equipment/BP_BaseEquipment.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Equipment/BP_BaseEquipment.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Equipment/BP_BaseEquippable.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Equipment/BP_BaseEquippable.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Equipment/BP_BaseSword_L.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Equipment/BP_BaseSword_L.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Equipment/BP_BaseSword_R.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Equipment/BP_BaseSword_R.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Equipment/BP_BaseWeapon.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/Equipment/BP_BaseWeapon.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/UI/UMG_EnemyUI.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/UI/UMG_EnemyUI.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/UI/UMG_PlayerUI.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/UI/UMG_PlayerUI.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/WorldSetting/TestGameMode.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ProjectFIM/Blueprints/WorldSetting/TestGameMode.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/StarterContent/Architecture/Floor_400x400.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/StarterContent/Architecture/Floor_400x400.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/StarterContent/HDRI/HDRI_Epic_Courtyard_Daylight.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/StarterContent/HDRI/HDRI_Epic_Courtyard_Daylight.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/ThirdPerson/Maps/ThirdPersonMap.umap" beforeDir="false" afterPath="$PROJECT_DIR$/Content/ThirdPerson/Maps/ThirdPersonMap.umap" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/Weapon_Pack/Mesh/Weapons/Weapons_Kit/SM_Sword.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/Weapon_Pack/Mesh/Weapons/Weapons_Kit/SM_Sword.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Content/__ExternalActors__/ThirdPerson/Maps/ThirdPersonMap/A/50/IRZH3U8SIA6AIB9E54A5YZ.uasset" beforeDir="false" afterPath="$PROJECT_DIR$/Content/__ExternalActors__/ThirdPerson/Maps/ThirdPersonMap/A/50/IRZH3U8SIA6AIB9E54A5YZ.uasset" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/CTPL/LICENSE" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/CTPL/LICENSE" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.h" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/clsocket/src/SimpleSocket.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/optional/tl/optional.hpp" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/optional/tl/optional.hpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/README.md" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format-inl.h" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format-inl.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format.h" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/string-view-lite/README.md" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/string-view-lite/README.md" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/BlueprintProvider.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/BlueprintProvider.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/RiderBlueprint.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/RiderBlueprint.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RiderGameControl/Private/RiderGameControl.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RiderGameControl/Private/RiderGameControl.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RiderLink/Private/ProtocolFactory.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RiderLink/Private/ProtocolFactory.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Source/FIM/Private/FIMCharacter.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/Source/FIM/Private/FIMCharacter.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Source/FIM/Private/SAttributeSet.cpp" beforeDir="false" afterPath="$PROJECT_DIR$/Source/FIM/Private/SAttributeSet.cpp" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Source/FIM/Public/FIMCharacter.h" beforeDir="false" afterPath="$PROJECT_DIR$/Source/FIM/Public/FIMCharacter.h" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/Source/FIM/Public/SAttributeSet.h" beforeDir="false" afterPath="$PROJECT_DIR$/Source/FIM/Public/SAttributeSet.h" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -69,6 +126,8 @@
   }
 }</component>
   <component name="HighlightingSettingsPerFile">
+    <setting file="file://$PROJECT_DIR$/Intermediate/Build/Win64/UnrealEditor/Inc/FIM/UHT/FIMCharacter.gen.cpp" root0="FORCE_HIGHLIGHTING" />
+    <setting file="file://$PROJECT_DIR$/Plugins/Developer/RiderLink/Source/RD/thirdparty/spdlog/include/spdlog/fmt/bundled/format-inl.h" root0="SKIP_HIGHLIGHTING" />
     <setting file="file://$PROJECT_DIR$/../../UE5/UE_5.1/Engine/Source/Runtime/Core/Public/Experimental/Containers/HazardPointer.h" root0="SKIP_HIGHLIGHTING" />
     <setting file="file://$PROJECT_DIR$/../../UE5/UE_5.1/Engine/Source/UnrealEditor.Target.cs" root0="FORCE_HIGHLIGHTING" />
     <setting file="file://$PROJECT_DIR$/../../UE5/UE_5.1/Engine/Source/UnrealGame.Target.cs" root0="FORCE_HIGHLIGHTING" />
@@ -85,29 +144,29 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    "C++ Project.FIM.executor": "Run",
-    "RunOnceActivity.OpenProjectViewOnStart": "true",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "git-widget-placeholder": "saxon877559@gmail.com",
-    "ignore.virus.scanning.warn.message": "true",
-    "node.js.detected.package.eslint": "true",
-    "node.js.detected.package.tslint": "true",
-    "node.js.selected.package.eslint": "(autodetect)",
-    "node.js.selected.package.tslint": "(autodetect)",
-    "nodejs_package_manager_path": "npm",
-    "settings.editor.selected.configurable": "preferences.keymap",
-    "vue.rearranger.settings.migration": "true"
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;C++ Project.FIM.executor&quot;: &quot;Run&quot;,
+    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;20240706__AddLV&quot;,
+    &quot;ignore.virus.scanning.warn.message&quot;: &quot;true&quot;,
+    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
+    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
+    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
+    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
+    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
+    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.keymap&quot;,
+    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
   },
-  "keyToStringList": {
-    "rider.external.source.directories": [
-      "C:\\Users\\ASUS\\AppData\\Roaming\\JetBrains\\Rider2024.1\\resharper-host\\DecompilerCache",
-      "C:\\Users\\ASUS\\AppData\\Roaming\\JetBrains\\Rider2024.1\\resharper-host\\SourcesCache",
-      "C:\\Users\\ASUS\\AppData\\Local\\Symbols\\src"
+  &quot;keyToStringList&quot;: {
+    &quot;rider.external.source.directories&quot;: [
+      &quot;C:\\Users\\ASUS\\AppData\\Roaming\\JetBrains\\Rider2024.1\\resharper-host\\DecompilerCache&quot;,
+      &quot;C:\\Users\\ASUS\\AppData\\Roaming\\JetBrains\\Rider2024.1\\resharper-host\\SourcesCache&quot;,
+      &quot;C:\\Users\\ASUS\\AppData\\Local\\Symbols\\src&quot;
     ]
   }
-}]]></component>
+}</component>
   <component name="RunManager" selected="C++ Project.FIM">
     <configuration name="FIM" type="CppProject" factoryName="C++ Project">
       <configuration_1>
@@ -504,6 +563,32 @@
       <workItem from="1716741126733" duration="980000" />
       <workItem from="1716742552205" duration="8000" />
       <workItem from="1716742710053" duration="130000" />
+      <workItem from="1716742931015" duration="815000" />
+      <workItem from="1716744050582" duration="4324000" />
+      <workItem from="1716833383421" duration="3918000" />
+      <workItem from="1717620142325" duration="1554000" />
+      <workItem from="1718637369142" duration="4962000" />
+      <workItem from="1718813391709" duration="4099000" />
+      <workItem from="1718891299943" duration="1339000" />
+      <workItem from="1719156316245" duration="2718000" />
+      <workItem from="1719748295268" duration="604000" />
+      <workItem from="1719749155940" duration="2319000" />
+      <workItem from="1719761675321" duration="218000" />
+      <workItem from="1719761951636" duration="1514000" />
+      <workItem from="1720018120309" duration="2071000" />
+      <workItem from="1720021695995" duration="11996000" />
+      <workItem from="1720340751398" duration="14428000" />
+      <workItem from="1720622541963" duration="1570000" />
+      <workItem from="1720705828419" duration="17215000" />
+      <workItem from="1720892240269" duration="518000" />
+      <workItem from="1720894024662" duration="2000" />
+      <workItem from="1720894599422" duration="3896000" />
+      <workItem from="1721055285692" duration="12218000" />
+      <workItem from="1721314463328" duration="1900000" />
+      <workItem from="1721526455507" duration="21315000" />
+      <workItem from="1722350475961" duration="175000" />
+      <workItem from="1722678438411" duration="7538000" />
+      <workItem from="1723216747266" duration="1872000" />
     </task>
     <task id="LOCAL-00001" summary="Revert &quot;Fix Error&quot;&#10;&#10;This reverts commit c6e2f507">
       <option name="closed" value="true" />
@@ -521,7 +606,15 @@
       <option name="project" value="LOCAL" />
       <updated>1716741456824</updated>
     </task>
-    <option name="localTasksCounter" value="3" />
+    <task id="LOCAL-00003" summary="Revert &quot;update current version but undone the attack detect system&quot;&#10;&#10;This reverts commit b967307e">
+      <option name="closed" value="true" />
+      <created>1716742957811</created>
+      <option name="number" value="00003" />
+      <option name="presentableId" value="LOCAL-00003" />
+      <option name="project" value="LOCAL" />
+      <updated>1716742957811</updated>
+    </task>
+    <option name="localTasksCounter" value="4" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -540,7 +633,7 @@
                   <entry key="branch">
                     <value>
                       <list>
-                        <option value="saxon877559@gmail.com" />
+                        <option value="20240706_AddLV" />
                       </list>
                     </value>
                   </entry>
@@ -556,7 +649,8 @@
     <option name="CLEAR_INITIAL_COMMIT_MESSAGE" value="true" />
     <MESSAGE value="Revert &quot;Fix Error&quot;&#10;&#10;This reverts commit c6e2f507" />
     <MESSAGE value="Revert to the original hit method" />
-    <option name="LAST_COMMIT_MESSAGE" value="Revert to the original hit method" />
+    <MESSAGE value="Revert &quot;update current version but undone the attack detect system&quot;&#10;&#10;This reverts commit b967307e" />
+    <option name="LAST_COMMIT_MESSAGE" value="Revert &quot;update current version but undone the attack detect system&quot;&#10;&#10;This reverts commit b967307e" />
   </component>
   <component name="XSLT-Support.FileAssociations.UIState">
     <expand />
Index: Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/BlueprintProvider.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"BlueprintProvider.hpp\"\r\n\r\n#include \"Async/Async.h\"\r\n\r\n#include \"AssetEditorMessages.h\"\r\n#include \"BlueprintEditor.h\"\r\n#include \"MessageEndpointBuilder.h\"\r\n#include \"MessageEndpoint.h\"\r\n#include \"Kismet2/KismetEditorUtilities.h\"\r\n#include \"Runtime/Launch/Resources/Version.h\"\r\n\r\n#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 23\r\n#include \"Toolkits/AssetEditorManager.h\"\r\n#endif\r\n#include \"Kismet2/BlueprintEditorUtils.h\"\r\n#include \"Model/RdEditorProtocol/RdEditorModel/RdEditorModel.Pregenerated.h\"\r\n\r\n#if ENGINE_MAJOR_VERSION < 5\r\n#include \"AssetData.h\"\r\n#else\r\n#include \"AssetRegistry/AssetData.h\"\r\n#endif\r\n\r\nvoid BluePrintProvider::AddAsset(FAssetData const& AssetData) {\r\n#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 23\r\n    UObject* cls = AssetData.GetAsset();\r\n#else\r\n    UObject* cls = AssetData.FastGetAsset();\r\n#endif\r\n    if (cls) {\r\n        UBlueprint* Blueprint = Cast<UBlueprint>(cls);\r\n        if (Blueprint && Blueprint->IsValidLowLevel()) {\r\n\r\n        }\r\n    }\r\n}\r\n\r\nbool BluePrintProvider::IsBlueprint(FString const& pathName) {\r\n    return FPackageName::IsValidObjectPath(pathName);\r\n}\r\n\r\nvoid BluePrintProvider::OpenBlueprint(JetBrains::EditorPlugin::BlueprintReference const& BlueprintReference, TSharedPtr<FMessageEndpoint, ESPMode::ThreadSafe> const& messageEndpoint) {\r\n    // Just to create asset manager if it wasn't created already\r\n    const FString AssetPathName = BlueprintReference.get_pathName();\r\n    FGuid AssetGuid;\r\n    bool bIsValidGuid = FGuid::Parse(BlueprintReference.get_guid(), AssetGuid);\r\n#if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 23\r\n    FAssetEditorManager::Get();\r\n    messageEndpoint->Publish(new FAssetEditorRequestOpenAsset(AssetPathName), EMessageScope::Process);\r\n#else\r\n    AsyncTask(ENamedThreads::GameThread, [AssetPathName, AssetGuid, bIsValidGuid]()\r\n    {\r\n        // An asset needs loading\r\n        UPackage* Package = LoadPackage(nullptr, *AssetPathName, LOAD_NoRedirects);\r\n\r\n        if (Package)\r\n        {\r\n            Package->FullyLoad();\r\n\r\n            const FString AssetName = FPaths::GetBaseFilename(AssetPathName);\r\n            UObject* Object = FindObject<UObject>(Package, *AssetName);\r\n            const UBlueprint* Blueprint = Cast<UBlueprint>(Object);\r\n\r\n            if(bIsValidGuid && Blueprint != nullptr)\r\n            {\r\n                UEdGraphNode* EdGraphNode = FBlueprintEditorUtils::GetNodeByGUID(Blueprint, AssetGuid);\r\n                if(EdGraphNode != nullptr)\r\n                {\r\n                    FKismetEditorUtilities::BringKismetToFocusAttentionOnObject(EdGraphNode); \r\n                }\r\n                else\r\n                {\r\n                    FKismetEditorUtilities::BringKismetToFocusAttentionOnObject(Blueprint);\r\n                }\r\n            }\r\n            else if(Object != nullptr)\r\n            {      \r\n                GEditor->GetEditorSubsystem<UAssetEditorSubsystem>()->OpenEditorForAsset(Object);         \r\n            }\r\n        }\r\n    });\r\n#endif\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/BlueprintProvider.cpp b/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/BlueprintProvider.cpp
--- a/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/BlueprintProvider.cpp	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Plugins/Developer/RiderLink/Source/RiderBlueprint/Private/BlueprintProvider.cpp	(date 1720720014534)
@@ -10,7 +10,7 @@
 #include "Runtime/Launch/Resources/Version.h"
 
 #if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 23
-#include "Toolkits/AssetEditorManager.h"
+#include "Toolkits/AssetEditorn_BASIC_MPger.h"
 #endif
 #include "Kismet2/BlueprintEditorUtils.h"
 #include "Model/RdEditorProtocol/RdEditorModel/RdEditorModel.Pregenerated.h"
@@ -40,12 +40,12 @@
 }
 
 void BluePrintProvider::OpenBlueprint(JetBrains::EditorPlugin::BlueprintReference const& BlueprintReference, TSharedPtr<FMessageEndpoint, ESPMode::ThreadSafe> const& messageEndpoint) {
-    // Just to create asset manager if it wasn't created already
+    // Just to create asset n_BASIC_MPger if it wasn't created already
     const FString AssetPathName = BlueprintReference.get_pathName();
     FGuid AssetGuid;
     bool bIsValidGuid = FGuid::Parse(BlueprintReference.get_guid(), AssetGuid);
 #if ENGINE_MAJOR_VERSION == 4 && ENGINE_MINOR_VERSION <= 23
-    FAssetEditorManager::Get();
+    FAssetEditorn_BASIC_MPger::Get();
     messageEndpoint->Publish(new FAssetEditorRequestOpenAsset(AssetPathName), EMessageScope::Process);
 #else
     AsyncTask(ENamedThreads::GameThread, [AssetPathName, AssetGuid, bIsValidGuid]()
Index: Source/FIM/Private/SAttributeSet.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>// Fill out your copyright notice in the Description page of Project Settings.\r\n\r\n\r\n#include \"SAttributeSet.h\"\r\n#include \"GameplayEffect.h\"\r\n#include \"GameplayEffectExtension.h\"\r\n#include \"Net/UnrealNetwork.h\"\r\n\r\nUSAttributeSet::USAttributeSet()\r\n{\r\n\r\n}\r\n\r\nvoid USAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data)\r\n{\r\n\tSuper::PostGameplayEffectExecute(Data);\r\n\r\n\tif (Data.EvaluatedData.Attribute == GetHealthAttribute())\r\n\t{\r\n\t\tSetHealth(FMath::Clamp(GetHealth(), 0.0f, GetMaxHealth()));\r\n\t}\r\n\tif (Data.EvaluatedData.Attribute == GetManaAttribute())\r\n\t{\r\n\t\tSetMana(FMath::Clamp(GetMana(), 0.0f, GetMaxMana()));\r\n\t}\r\n\tif (Data.EvaluatedData.Attribute == GetStaminaAttribute())\r\n\t{\r\n\t\tSetStamina(FMath::Clamp(GetStamina(), 0.0f, GetMaxStamina()));\r\n\t}\r\n\tif (Data.EvaluatedData.Attribute == GetAttackPowerAttribute())\r\n\t{\r\n\t\tSetAttackPower(FMath::Clamp(GetAttackPower(), 0.0f, GetMaxAttackPower()));\r\n\t}\r\n}\r\n\r\nvoid USAttributeSet::GetLifetimeReplicatedProps(TArray<FLifetimeProperty>& OutLifetimeProps) const\r\n{\r\n\tSuper::GetLifetimeReplicatedProps(OutLifetimeProps);\r\n\r\n\tDOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Health, COND_None, REPNOTIFY_Always);\r\n\tDOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Mana, COND_None, REPNOTIFY_Always);\r\n\tDOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Stamina, COND_None, REPNOTIFY_Always);\r\n\tDOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, AttackPower, COND_None, REPNOTIFY_Always);\r\n\tDOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always);\r\n\tDOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, MaxMana, COND_None, REPNOTIFY_Always);\r\n\tDOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, MaxStamina, COND_None, REPNOTIFY_Always);\r\n\tDOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, MaxAttackPower, COND_None, REPNOTIFY_Always);\r\n}\r\n\r\nvoid USAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth)\r\n{\r\n\tGAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, Health, OldHealth);\r\n}\r\n\r\nvoid USAttributeSet::OnRep_Mana(const FGameplayAttributeData& OldMana)\r\n{\r\n\tGAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, Mana, OldMana);\r\n}\r\n\r\nvoid USAttributeSet::OnRep_Stamina(const FGameplayAttributeData& OldStamina)\r\n{\r\n\tGAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, Stamina, OldStamina);\r\n}\r\n\r\nvoid USAttributeSet::OnRep_AttackPower(const FGameplayAttributeData& OldAttackPower)\r\n{\r\n\tGAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, AttackPower, OldAttackPower);\r\n}\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/Source/FIM/Private/SAttributeSet.cpp b/Source/FIM/Private/SAttributeSet.cpp
--- a/Source/FIM/Private/SAttributeSet.cpp	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/Source/FIM/Private/SAttributeSet.cpp	(date 1720720109257)
@@ -8,28 +8,59 @@
 
 USAttributeSet::USAttributeSet()
 {
-
 }
 
 void USAttributeSet::PostGameplayEffectExecute(const struct FGameplayEffectModCallbackData& Data)
 {
 	Super::PostGameplayEffectExecute(Data);
 
-	if (Data.EvaluatedData.Attribute == GetHealthAttribute())
+	if (Data.EvaluatedData.Attribute == Getn_BASIC_HPAttribute())
+	{
+		Setn_BASIC_HP(FMath::Clamp(Getn_BASIC_HP(), 0.0f, GetMaxn_BASIC_HP()));
+	}
+	if (Data.EvaluatedData.Attribute == Getn_BASIC_MPAttribute())
+	{
+		Setn_BASIC_MP(FMath::Clamp(Getn_BASIC_MP(), 0.0f, GetMaxn_BASIC_MP()));
+	}
+	if (Data.EvaluatedData.Attribute == Getn_BASIC_SPAttribute())
+	{
+		Setn_BASIC_SP(FMath::Clamp(Getn_BASIC_SP(), 0.0f, GetMaxn_BASIC_SP()));
+	}
+	if (Data.EvaluatedData.Attribute == Getn_BAISC_DPAttribute())
+	{
+		Setn_BAISC_DP(FMath::Clamp(Getn_BAISC_DP(), 0.0f, GetMaxn_BAISC_DP()));
+	}
+	if (Data.EvaluatedData.Attribute == Getn_LVAttribute())
+	{
+		Setn_LV(FMath::Clamp(Getn_LV(), 0.0f, GetMaxn_LV()));
+	}
+	if (Data.EvaluatedData.Attribute == Getn_EXPAttribute())
+	{
+		Setn_EXP(FMath::Clamp(Getn_EXP(), 0.0f, GetMaxn_EXP()));
+	}
+	if (Data.EvaluatedData.Attribute == Getn_BAISC_DATKAttribute())
+	{
+		Setn_BAISC_DATK(FMath::Clamp(Getn_BAISC_DATK(), 0.0f, GetMaxn_BAISC_DATK()));
+	}
+	if (Data.EvaluatedData.Attribute == Getn_BAISC_DDEFAttribute())
+	{
+		Setn_BAISC_DDEF(FMath::Clamp(Getn_BAISC_DDEF(), 0.0f, GetMaxn_BAISC_DDEF()));
+	}
+	if (Data.EvaluatedData.Attribute == Getn_BAISC_MOVE_SPEEDAttribute())
 	{
-		SetHealth(FMath::Clamp(GetHealth(), 0.0f, GetMaxHealth()));
+		Setn_BAISC_MOVE_SPEED(FMath::Clamp(Getn_BAISC_MOVE_SPEED(), 0.0f, GetMaxn_BAISC_MOVE_SPEED()));
 	}
-	if (Data.EvaluatedData.Attribute == GetManaAttribute())
+	if (Data.EvaluatedData.Attribute == Getn_BAISC_ATTACK_SPEEDAttribute())
 	{
-		SetMana(FMath::Clamp(GetMana(), 0.0f, GetMaxMana()));
+		Setn_BAISC_ATTACK_SPEED(FMath::Clamp(Getn_BAISC_ATTACK_SPEED(), 0.0f, GetMaxn_BAISC_ATTACK_SPEED()));
 	}
-	if (Data.EvaluatedData.Attribute == GetStaminaAttribute())
+	if (Data.EvaluatedData.Attribute == Getn_CRIAttribute())
 	{
-		SetStamina(FMath::Clamp(GetStamina(), 0.0f, GetMaxStamina()));
+		Setn_CRI(FMath::Clamp(Getn_CRI(), 0.0f, GetMaxn_CRI()));
 	}
-	if (Data.EvaluatedData.Attribute == GetAttackPowerAttribute())
+	if (Data.EvaluatedData.Attribute == Getn_CRI_PROPORTIONAttribute())
 	{
-		SetAttackPower(FMath::Clamp(GetAttackPower(), 0.0f, GetMaxAttackPower()));
+		Setn_CRI_PROPORTION(FMath::Clamp(Getn_CRI_PROPORTION(), 0.0f, GetMaxn_CRI_PROPORTION()));
 	}
 }
 
@@ -37,35 +68,88 @@
 {
 	Super::GetLifetimeReplicatedProps(OutLifetimeProps);
 
-	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Health, COND_None, REPNOTIFY_Always);
-	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Mana, COND_None, REPNOTIFY_Always);
-	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Stamina, COND_None, REPNOTIFY_Always);
-	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, AttackPower, COND_None, REPNOTIFY_Always);
-	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, MaxHealth, COND_None, REPNOTIFY_Always);
-	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, MaxMana, COND_None, REPNOTIFY_Always);
-	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, MaxStamina, COND_None, REPNOTIFY_Always);
-	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, MaxAttackPower, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_BASIC_HP, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_BASIC_MP, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_BASIC_SP, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_BAISC_DP, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_LV, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_EXP, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_BAISC_DATK, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_BAISC_DDEF, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_BAISC_MOVE_SPEED, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_BAISC_ATTACK_SPEED, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_CRI, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, n_CRI_PROPORTION, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_BASIC_HP, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_BASIC_MP, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_BASIC_SP, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_BAISC_DP, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_LV, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_EXP, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_BAISC_DATK, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_BAISC_DDEF, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_BAISC_MOVE_SPEED, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_BAISC_ATTACK_SPEED, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_CRI, COND_None, REPNOTIFY_Always);
+	DOREPLIFETIME_CONDITION_NOTIFY(USAttributeSet, Maxn_CRI_PROPORTION, COND_None, REPNOTIFY_Always);
 }
 
-void USAttributeSet::OnRep_Health(const FGameplayAttributeData& OldHealth)
+void USAttributeSet::OnRep_n_BASIC_HP(const FGameplayAttributeData& Oldn_BASIC_HP)
 {
-	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, Health, OldHealth);
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_BASIC_HP, Oldn_BASIC_HP);
 }
 
-void USAttributeSet::OnRep_Mana(const FGameplayAttributeData& OldMana)
+void USAttributeSet::OnRep_n_BASIC_MP(const FGameplayAttributeData& Oldn_BASIC_MP)
 {
-	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, Mana, OldMana);
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_BASIC_MP, Oldn_BASIC_MP);
 }
 
-void USAttributeSet::OnRep_Stamina(const FGameplayAttributeData& OldStamina)
+void USAttributeSet::OnRep_n_BASIC_SP(const FGameplayAttributeData& Oldn_BASIC_SP)
 {
-	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, Stamina, OldStamina);
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_BASIC_SP, Oldn_BASIC_SP);
 }
 
-void USAttributeSet::OnRep_AttackPower(const FGameplayAttributeData& OldAttackPower)
+void USAttributeSet::OnRep_n_BAISC_DP(const FGameplayAttributeData& Oldn_BAISC_DP)
 {
-	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, AttackPower, OldAttackPower);
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_BAISC_DP, Oldn_BAISC_DP);
 }
 
+void USAttributeSet::OnRep_n_LV(const FGameplayAttributeData& Oldn_LV)
+{
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_LV, Oldn_LV);
+}
 
+void USAttributeSet::OnRep_n_EXP(const FGameplayAttributeData& Oldn_EXP)
+{
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_EXP, Oldn_EXP);
+}
 
+void USAttributeSet::OnRep_n_BAISC_DATK(const FGameplayAttributeData& Oldn_BAISC_DATK)
+{
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_BAISC_DATK, Oldn_BAISC_DATK);
+}
+
+void USAttributeSet::OnRep_n_BAISC_DDEF(const FGameplayAttributeData& Oldn_BAISC_DDEF)
+{
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_BAISC_DDEF, Oldn_BAISC_DDEF);
+}
+
+void USAttributeSet::OnRep_n_BAISC_MOVE_SPEED(const FGameplayAttributeData& Oldn_BAISC_MOVE_SPEED)
+{
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_BAISC_MOVE_SPEED, Oldn_BAISC_MOVE_SPEED);
+}
+
+void USAttributeSet::OnRep_n_BAISC_ATTACK_SPEED(const FGameplayAttributeData& Oldn_BAISC_ATTACK_SPEED)
+{
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_BAISC_ATTACK_SPEED, Oldn_BAISC_ATTACK_SPEED);
+}
+
+void USAttributeSet::OnRep_n_CRI(const FGameplayAttributeData& Oldn_CRI)
+{
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_CRI, Oldn_CRI);
+}
+
+void USAttributeSet::OnRep_n_CRI_PROPORTION(const FGameplayAttributeData& Oldn_CRI_PROPORTION)
+{
+	GAMEPLAYATTRIBUTE_REPNOTIFY(USAttributeSet, n_CRI_PROPORTION, Oldn_CRI_PROPORTION);
+}
Index: .vsconfig
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\r\n  \"version\": \"1.0\",\r\n  \"components\": [\r\n    \"Microsoft.Net.Component.4.6.2.TargetingPack\",\r\n    \"Microsoft.VisualStudio.Component.VC.14.38.17.8.x86.x64\",\r\n    \"Microsoft.VisualStudio.Component.VC.Tools.x86.x64\",\r\n    \"Microsoft.VisualStudio.Component.Windows10SDK.22621\",\r\n    \"Microsoft.VisualStudio.Workload.CoreEditor\",\r\n    \"Microsoft.VisualStudio.Workload.ManagedDesktop\",\r\n    \"Microsoft.VisualStudio.Workload.NativeDesktop\",\r\n    \"Microsoft.VisualStudio.Workload.NativeGame\"\r\n  ]\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.vsconfig b/.vsconfig
--- a/.vsconfig	(revision 9da19b5d229590d84cc2f2d7aa91fc3525eb7a76)
+++ b/.vsconfig	(date 1720720014338)
@@ -6,7 +6,7 @@
     "Microsoft.VisualStudio.Component.VC.Tools.x86.x64",
     "Microsoft.VisualStudio.Component.Windows10SDK.22621",
     "Microsoft.VisualStudio.Workload.CoreEditor",
-    "Microsoft.VisualStudio.Workload.ManagedDesktop",
+    "Microsoft.VisualStudio.Workload.n_BASIC_MPgedDesktop",
     "Microsoft.VisualStudio.Workload.NativeDesktop",
     "Microsoft.VisualStudio.Workload.NativeGame"
   ]
